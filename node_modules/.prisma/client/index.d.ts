
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model Cliente
 * 
 */
export type Cliente = $Result.DefaultSelection<Prisma.$ClientePayload>
/**
 * Model Proprietario
 * 
 */
export type Proprietario = $Result.DefaultSelection<Prisma.$ProprietarioPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Lavanderia
 * 
 */
export type Lavanderia = $Result.DefaultSelection<Prisma.$LavanderiaPayload>
/**
 * Model Maquina
 * 
 */
export type Maquina = $Result.DefaultSelection<Prisma.$MaquinaPayload>
/**
 * Model Relatorio
 * 
 */
export type Relatorio = $Result.DefaultSelection<Prisma.$RelatorioPayload>
/**
 * Model Reserva
 * 
 */
export type Reserva = $Result.DefaultSelection<Prisma.$ReservaPayload>
/**
 * Model Avaliacao
 * 
 */
export type Avaliacao = $Result.DefaultSelection<Prisma.$AvaliacaoPayload>
/**
 * Model Pagamento
 * 
 */
export type Pagamento = $Result.DefaultSelection<Prisma.$PagamentoPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TipoUsuario: {
  CLIENTE: 'CLIENTE',
  PROPRIETARIO: 'PROPRIETARIO',
  ADMIN: 'ADMIN'
};

export type TipoUsuario = (typeof TipoUsuario)[keyof typeof TipoUsuario]


export const Niveis_privilegio: {
  PLANO_BASICO: 'PLANO_BASICO',
  PLANO_PREMIUM: 'PLANO_PREMIUM'
};

export type Niveis_privilegio = (typeof Niveis_privilegio)[keyof typeof Niveis_privilegio]


export const Tipo_maquina: {
  LAVADORA: 'LAVADORA',
  SECADORA: 'SECADORA'
};

export type Tipo_maquina = (typeof Tipo_maquina)[keyof typeof Tipo_maquina]


export const Status_maquina: {
  DISPONIVEL: 'DISPONIVEL',
  EM_USO: 'EM_USO',
  EM_MANUTENCAO: 'EM_MANUTENCAO'
};

export type Status_maquina = (typeof Status_maquina)[keyof typeof Status_maquina]


export const Status_reserva: {
  FEITA: 'FEITA',
  EM_ANDAMENTO: 'EM_ANDAMENTO',
  CANCELADA: 'CANCELADA'
};

export type Status_reserva = (typeof Status_reserva)[keyof typeof Status_reserva]


export const Metodo_Pagamento: {
  PIX: 'PIX'
};

export type Metodo_Pagamento = (typeof Metodo_Pagamento)[keyof typeof Metodo_Pagamento]


export const Status_Pagamento: {
  FEITO: 'FEITO',
  PENDENTE: 'PENDENTE',
  CANCELADO: 'CANCELADO'
};

export type Status_Pagamento = (typeof Status_Pagamento)[keyof typeof Status_Pagamento]

}

export type TipoUsuario = $Enums.TipoUsuario

export const TipoUsuario: typeof $Enums.TipoUsuario

export type Niveis_privilegio = $Enums.Niveis_privilegio

export const Niveis_privilegio: typeof $Enums.Niveis_privilegio

export type Tipo_maquina = $Enums.Tipo_maquina

export const Tipo_maquina: typeof $Enums.Tipo_maquina

export type Status_maquina = $Enums.Status_maquina

export const Status_maquina: typeof $Enums.Status_maquina

export type Status_reserva = $Enums.Status_reserva

export const Status_reserva: typeof $Enums.Status_reserva

export type Metodo_Pagamento = $Enums.Metodo_Pagamento

export const Metodo_Pagamento: typeof $Enums.Metodo_Pagamento

export type Status_Pagamento = $Enums.Status_Pagamento

export const Status_Pagamento: typeof $Enums.Status_Pagamento

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Usuarios
 * const usuarios = await prisma.usuario.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs>;

  /**
   * `prisma.cliente`: Exposes CRUD operations for the **Cliente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientes
    * const clientes = await prisma.cliente.findMany()
    * ```
    */
  get cliente(): Prisma.ClienteDelegate<ExtArgs>;

  /**
   * `prisma.proprietario`: Exposes CRUD operations for the **Proprietario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proprietarios
    * const proprietarios = await prisma.proprietario.findMany()
    * ```
    */
  get proprietario(): Prisma.ProprietarioDelegate<ExtArgs>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs>;

  /**
   * `prisma.lavanderia`: Exposes CRUD operations for the **Lavanderia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lavanderias
    * const lavanderias = await prisma.lavanderia.findMany()
    * ```
    */
  get lavanderia(): Prisma.LavanderiaDelegate<ExtArgs>;

  /**
   * `prisma.maquina`: Exposes CRUD operations for the **Maquina** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Maquinas
    * const maquinas = await prisma.maquina.findMany()
    * ```
    */
  get maquina(): Prisma.MaquinaDelegate<ExtArgs>;

  /**
   * `prisma.relatorio`: Exposes CRUD operations for the **Relatorio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Relatorios
    * const relatorios = await prisma.relatorio.findMany()
    * ```
    */
  get relatorio(): Prisma.RelatorioDelegate<ExtArgs>;

  /**
   * `prisma.reserva`: Exposes CRUD operations for the **Reserva** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservas
    * const reservas = await prisma.reserva.findMany()
    * ```
    */
  get reserva(): Prisma.ReservaDelegate<ExtArgs>;

  /**
   * `prisma.avaliacao`: Exposes CRUD operations for the **Avaliacao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Avaliacaos
    * const avaliacaos = await prisma.avaliacao.findMany()
    * ```
    */
  get avaliacao(): Prisma.AvaliacaoDelegate<ExtArgs>;

  /**
   * `prisma.pagamento`: Exposes CRUD operations for the **Pagamento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pagamentos
    * const pagamentos = await prisma.pagamento.findMany()
    * ```
    */
  get pagamento(): Prisma.PagamentoDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Usuario: 'Usuario',
    Cliente: 'Cliente',
    Proprietario: 'Proprietario',
    Admin: 'Admin',
    Lavanderia: 'Lavanderia',
    Maquina: 'Maquina',
    Relatorio: 'Relatorio',
    Reserva: 'Reserva',
    Avaliacao: 'Avaliacao',
    Pagamento: 'Pagamento'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "usuario" | "cliente" | "proprietario" | "admin" | "lavanderia" | "maquina" | "relatorio" | "reserva" | "avaliacao" | "pagamento"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      Cliente: {
        payload: Prisma.$ClientePayload<ExtArgs>
        fields: Prisma.ClienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClienteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClienteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          findFirst: {
            args: Prisma.ClienteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClienteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          findMany: {
            args: Prisma.ClienteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>[]
          }
          create: {
            args: Prisma.ClienteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          createMany: {
            args: Prisma.ClienteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClienteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>[]
          }
          delete: {
            args: Prisma.ClienteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          update: {
            args: Prisma.ClienteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          deleteMany: {
            args: Prisma.ClienteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClienteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClienteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientePayload>
          }
          aggregate: {
            args: Prisma.ClienteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCliente>
          }
          groupBy: {
            args: Prisma.ClienteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClienteCountArgs<ExtArgs>
            result: $Utils.Optional<ClienteCountAggregateOutputType> | number
          }
        }
      }
      Proprietario: {
        payload: Prisma.$ProprietarioPayload<ExtArgs>
        fields: Prisma.ProprietarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProprietarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProprietarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProprietarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProprietarioPayload>
          }
          findFirst: {
            args: Prisma.ProprietarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProprietarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProprietarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProprietarioPayload>
          }
          findMany: {
            args: Prisma.ProprietarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProprietarioPayload>[]
          }
          create: {
            args: Prisma.ProprietarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProprietarioPayload>
          }
          createMany: {
            args: Prisma.ProprietarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProprietarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProprietarioPayload>[]
          }
          delete: {
            args: Prisma.ProprietarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProprietarioPayload>
          }
          update: {
            args: Prisma.ProprietarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProprietarioPayload>
          }
          deleteMany: {
            args: Prisma.ProprietarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProprietarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProprietarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProprietarioPayload>
          }
          aggregate: {
            args: Prisma.ProprietarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProprietario>
          }
          groupBy: {
            args: Prisma.ProprietarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProprietarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProprietarioCountArgs<ExtArgs>
            result: $Utils.Optional<ProprietarioCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Lavanderia: {
        payload: Prisma.$LavanderiaPayload<ExtArgs>
        fields: Prisma.LavanderiaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LavanderiaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LavanderiaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LavanderiaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LavanderiaPayload>
          }
          findFirst: {
            args: Prisma.LavanderiaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LavanderiaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LavanderiaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LavanderiaPayload>
          }
          findMany: {
            args: Prisma.LavanderiaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LavanderiaPayload>[]
          }
          create: {
            args: Prisma.LavanderiaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LavanderiaPayload>
          }
          createMany: {
            args: Prisma.LavanderiaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LavanderiaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LavanderiaPayload>[]
          }
          delete: {
            args: Prisma.LavanderiaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LavanderiaPayload>
          }
          update: {
            args: Prisma.LavanderiaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LavanderiaPayload>
          }
          deleteMany: {
            args: Prisma.LavanderiaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LavanderiaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LavanderiaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LavanderiaPayload>
          }
          aggregate: {
            args: Prisma.LavanderiaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLavanderia>
          }
          groupBy: {
            args: Prisma.LavanderiaGroupByArgs<ExtArgs>
            result: $Utils.Optional<LavanderiaGroupByOutputType>[]
          }
          count: {
            args: Prisma.LavanderiaCountArgs<ExtArgs>
            result: $Utils.Optional<LavanderiaCountAggregateOutputType> | number
          }
        }
      }
      Maquina: {
        payload: Prisma.$MaquinaPayload<ExtArgs>
        fields: Prisma.MaquinaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaquinaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaquinaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaquinaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaquinaPayload>
          }
          findFirst: {
            args: Prisma.MaquinaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaquinaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaquinaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaquinaPayload>
          }
          findMany: {
            args: Prisma.MaquinaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaquinaPayload>[]
          }
          create: {
            args: Prisma.MaquinaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaquinaPayload>
          }
          createMany: {
            args: Prisma.MaquinaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaquinaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaquinaPayload>[]
          }
          delete: {
            args: Prisma.MaquinaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaquinaPayload>
          }
          update: {
            args: Prisma.MaquinaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaquinaPayload>
          }
          deleteMany: {
            args: Prisma.MaquinaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaquinaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaquinaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaquinaPayload>
          }
          aggregate: {
            args: Prisma.MaquinaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaquina>
          }
          groupBy: {
            args: Prisma.MaquinaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaquinaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaquinaCountArgs<ExtArgs>
            result: $Utils.Optional<MaquinaCountAggregateOutputType> | number
          }
        }
      }
      Relatorio: {
        payload: Prisma.$RelatorioPayload<ExtArgs>
        fields: Prisma.RelatorioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RelatorioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatorioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RelatorioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatorioPayload>
          }
          findFirst: {
            args: Prisma.RelatorioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatorioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RelatorioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatorioPayload>
          }
          findMany: {
            args: Prisma.RelatorioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatorioPayload>[]
          }
          create: {
            args: Prisma.RelatorioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatorioPayload>
          }
          createMany: {
            args: Prisma.RelatorioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RelatorioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatorioPayload>[]
          }
          delete: {
            args: Prisma.RelatorioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatorioPayload>
          }
          update: {
            args: Prisma.RelatorioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatorioPayload>
          }
          deleteMany: {
            args: Prisma.RelatorioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RelatorioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RelatorioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RelatorioPayload>
          }
          aggregate: {
            args: Prisma.RelatorioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelatorio>
          }
          groupBy: {
            args: Prisma.RelatorioGroupByArgs<ExtArgs>
            result: $Utils.Optional<RelatorioGroupByOutputType>[]
          }
          count: {
            args: Prisma.RelatorioCountArgs<ExtArgs>
            result: $Utils.Optional<RelatorioCountAggregateOutputType> | number
          }
        }
      }
      Reserva: {
        payload: Prisma.$ReservaPayload<ExtArgs>
        fields: Prisma.ReservaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReservaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReservaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload>
          }
          findFirst: {
            args: Prisma.ReservaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReservaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload>
          }
          findMany: {
            args: Prisma.ReservaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload>[]
          }
          create: {
            args: Prisma.ReservaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload>
          }
          createMany: {
            args: Prisma.ReservaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReservaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload>[]
          }
          delete: {
            args: Prisma.ReservaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload>
          }
          update: {
            args: Prisma.ReservaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload>
          }
          deleteMany: {
            args: Prisma.ReservaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReservaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReservaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservaPayload>
          }
          aggregate: {
            args: Prisma.ReservaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReserva>
          }
          groupBy: {
            args: Prisma.ReservaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReservaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReservaCountArgs<ExtArgs>
            result: $Utils.Optional<ReservaCountAggregateOutputType> | number
          }
        }
      }
      Avaliacao: {
        payload: Prisma.$AvaliacaoPayload<ExtArgs>
        fields: Prisma.AvaliacaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AvaliacaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AvaliacaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>
          }
          findFirst: {
            args: Prisma.AvaliacaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AvaliacaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>
          }
          findMany: {
            args: Prisma.AvaliacaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>[]
          }
          create: {
            args: Prisma.AvaliacaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>
          }
          createMany: {
            args: Prisma.AvaliacaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AvaliacaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>[]
          }
          delete: {
            args: Prisma.AvaliacaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>
          }
          update: {
            args: Prisma.AvaliacaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>
          }
          deleteMany: {
            args: Prisma.AvaliacaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AvaliacaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AvaliacaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvaliacaoPayload>
          }
          aggregate: {
            args: Prisma.AvaliacaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAvaliacao>
          }
          groupBy: {
            args: Prisma.AvaliacaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AvaliacaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.AvaliacaoCountArgs<ExtArgs>
            result: $Utils.Optional<AvaliacaoCountAggregateOutputType> | number
          }
        }
      }
      Pagamento: {
        payload: Prisma.$PagamentoPayload<ExtArgs>
        fields: Prisma.PagamentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PagamentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PagamentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          findFirst: {
            args: Prisma.PagamentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PagamentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          findMany: {
            args: Prisma.PagamentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>[]
          }
          create: {
            args: Prisma.PagamentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          createMany: {
            args: Prisma.PagamentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PagamentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>[]
          }
          delete: {
            args: Prisma.PagamentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          update: {
            args: Prisma.PagamentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          deleteMany: {
            args: Prisma.PagamentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PagamentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PagamentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          aggregate: {
            args: Prisma.PagamentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePagamento>
          }
          groupBy: {
            args: Prisma.PagamentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PagamentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PagamentoCountArgs<ExtArgs>
            result: $Utils.Optional<PagamentoCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ClienteCountOutputType
   */

  export type ClienteCountOutputType = {
    reservas: number
    avaliacoes: number
  }

  export type ClienteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservas?: boolean | ClienteCountOutputTypeCountReservasArgs
    avaliacoes?: boolean | ClienteCountOutputTypeCountAvaliacoesArgs
  }

  // Custom InputTypes
  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteCountOutputType
     */
    select?: ClienteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountReservasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservaWhereInput
  }

  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountAvaliacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvaliacaoWhereInput
  }


  /**
   * Count Type ProprietarioCountOutputType
   */

  export type ProprietarioCountOutputType = {
    lavanderias: number
    Relatorios: number
  }

  export type ProprietarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lavanderias?: boolean | ProprietarioCountOutputTypeCountLavanderiasArgs
    Relatorios?: boolean | ProprietarioCountOutputTypeCountRelatoriosArgs
  }

  // Custom InputTypes
  /**
   * ProprietarioCountOutputType without action
   */
  export type ProprietarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProprietarioCountOutputType
     */
    select?: ProprietarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProprietarioCountOutputType without action
   */
  export type ProprietarioCountOutputTypeCountLavanderiasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LavanderiaWhereInput
  }

  /**
   * ProprietarioCountOutputType without action
   */
  export type ProprietarioCountOutputTypeCountRelatoriosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelatorioWhereInput
  }


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    relatorios: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relatorios?: boolean | AdminCountOutputTypeCountRelatoriosArgs
  }

  // Custom InputTypes
  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountRelatoriosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelatorioWhereInput
  }


  /**
   * Count Type LavanderiaCountOutputType
   */

  export type LavanderiaCountOutputType = {
    maquinas: number
    avaliacoes: number
  }

  export type LavanderiaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    maquinas?: boolean | LavanderiaCountOutputTypeCountMaquinasArgs
    avaliacoes?: boolean | LavanderiaCountOutputTypeCountAvaliacoesArgs
  }

  // Custom InputTypes
  /**
   * LavanderiaCountOutputType without action
   */
  export type LavanderiaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LavanderiaCountOutputType
     */
    select?: LavanderiaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LavanderiaCountOutputType without action
   */
  export type LavanderiaCountOutputTypeCountMaquinasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaquinaWhereInput
  }

  /**
   * LavanderiaCountOutputType without action
   */
  export type LavanderiaCountOutputTypeCountAvaliacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvaliacaoWhereInput
  }


  /**
   * Count Type MaquinaCountOutputType
   */

  export type MaquinaCountOutputType = {
    reservas: number
  }

  export type MaquinaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservas?: boolean | MaquinaCountOutputTypeCountReservasArgs
  }

  // Custom InputTypes
  /**
   * MaquinaCountOutputType without action
   */
  export type MaquinaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaquinaCountOutputType
     */
    select?: MaquinaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaquinaCountOutputType without action
   */
  export type MaquinaCountOutputTypeCountReservasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: string | null
    nome: string | null
    email: string | null
    senha: string | null
    tipo: $Enums.TipoUsuario | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    email: string | null
    senha: string | null
    tipo: $Enums.TipoUsuario | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    nome: number
    email: number
    senha: number
    tipo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsuarioMinAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    tipo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    tipo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    nome?: true
    email?: true
    senha?: true
    tipo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: string
    nome: string
    email: string
    senha: string
    tipo: $Enums.TipoUsuario
    createdAt: Date
    updatedAt: Date
    _count: UsuarioCountAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    tipo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cliente?: boolean | Usuario$clienteArgs<ExtArgs>
    proprietario?: boolean | Usuario$proprietarioArgs<ExtArgs>
    admin?: boolean | Usuario$adminArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    tipo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    id?: boolean
    nome?: boolean
    email?: boolean
    senha?: boolean
    tipo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | Usuario$clienteArgs<ExtArgs>
    proprietario?: boolean | Usuario$proprietarioArgs<ExtArgs>
    admin?: boolean | Usuario$adminArgs<ExtArgs>
  }
  export type UsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      cliente: Prisma.$ClientePayload<ExtArgs> | null
      proprietario: Prisma.$ProprietarioPayload<ExtArgs> | null
      admin: Prisma.$AdminPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      email: string
      senha: string
      tipo: $Enums.TipoUsuario
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {UsuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cliente<T extends Usuario$clienteArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$clienteArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    proprietario<T extends Usuario$proprietarioArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$proprietarioArgs<ExtArgs>>): Prisma__ProprietarioClient<$Result.GetResult<Prisma.$ProprietarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    admin<T extends Usuario$adminArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */ 
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'String'>
    readonly nome: FieldRef<"Usuario", 'String'>
    readonly email: FieldRef<"Usuario", 'String'>
    readonly senha: FieldRef<"Usuario", 'String'>
    readonly tipo: FieldRef<"Usuario", 'TipoUsuario'>
    readonly createdAt: FieldRef<"Usuario", 'DateTime'>
    readonly updatedAt: FieldRef<"Usuario", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario createManyAndReturn
   */
  export type UsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario.cliente
   */
  export type Usuario$clienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    where?: ClienteWhereInput
  }

  /**
   * Usuario.proprietario
   */
  export type Usuario$proprietarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proprietario
     */
    select?: ProprietarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProprietarioInclude<ExtArgs> | null
    where?: ProprietarioWhereInput
  }

  /**
   * Usuario.admin
   */
  export type Usuario$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model Cliente
   */

  export type AggregateCliente = {
    _count: ClienteCountAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  export type ClienteMinAggregateOutputType = {
    id: string | null
    usuarioId: string | null
  }

  export type ClienteMaxAggregateOutputType = {
    id: string | null
    usuarioId: string | null
  }

  export type ClienteCountAggregateOutputType = {
    id: number
    usuarioId: number
    _all: number
  }


  export type ClienteMinAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type ClienteMaxAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type ClienteCountAggregateInputType = {
    id?: true
    usuarioId?: true
    _all?: true
  }

  export type ClienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cliente to aggregate.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clientes
    **/
    _count?: true | ClienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClienteMaxAggregateInputType
  }

  export type GetClienteAggregateType<T extends ClienteAggregateArgs> = {
        [P in keyof T & keyof AggregateCliente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCliente[P]>
      : GetScalarType<T[P], AggregateCliente[P]>
  }




  export type ClienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClienteWhereInput
    orderBy?: ClienteOrderByWithAggregationInput | ClienteOrderByWithAggregationInput[]
    by: ClienteScalarFieldEnum[] | ClienteScalarFieldEnum
    having?: ClienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClienteCountAggregateInputType | true
    _min?: ClienteMinAggregateInputType
    _max?: ClienteMaxAggregateInputType
  }

  export type ClienteGroupByOutputType = {
    id: string
    usuarioId: string
    _count: ClienteCountAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  type GetClienteGroupByPayload<T extends ClienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClienteGroupByOutputType[P]>
            : GetScalarType<T[P], ClienteGroupByOutputType[P]>
        }
      >
    >


  export type ClienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    reservas?: boolean | Cliente$reservasArgs<ExtArgs>
    avaliacoes?: boolean | Cliente$avaliacoesArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cliente"]>

  export type ClienteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cliente"]>

  export type ClienteSelectScalar = {
    id?: boolean
    usuarioId?: boolean
  }

  export type ClienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    reservas?: boolean | Cliente$reservasArgs<ExtArgs>
    avaliacoes?: boolean | Cliente$avaliacoesArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClienteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $ClientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cliente"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
      reservas: Prisma.$ReservaPayload<ExtArgs>[]
      avaliacoes: Prisma.$AvaliacaoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usuarioId: string
    }, ExtArgs["result"]["cliente"]>
    composites: {}
  }

  type ClienteGetPayload<S extends boolean | null | undefined | ClienteDefaultArgs> = $Result.GetResult<Prisma.$ClientePayload, S>

  type ClienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClienteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClienteCountAggregateInputType | true
    }

  export interface ClienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cliente'], meta: { name: 'Cliente' } }
    /**
     * Find zero or one Cliente that matches the filter.
     * @param {ClienteFindUniqueArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClienteFindUniqueArgs>(args: SelectSubset<T, ClienteFindUniqueArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cliente that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClienteFindUniqueOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClienteFindUniqueOrThrowArgs>(args: SelectSubset<T, ClienteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cliente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindFirstArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClienteFindFirstArgs>(args?: SelectSubset<T, ClienteFindFirstArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cliente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindFirstOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClienteFindFirstOrThrowArgs>(args?: SelectSubset<T, ClienteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientes
     * const clientes = await prisma.cliente.findMany()
     * 
     * // Get first 10 Clientes
     * const clientes = await prisma.cliente.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clienteWithIdOnly = await prisma.cliente.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClienteFindManyArgs>(args?: SelectSubset<T, ClienteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cliente.
     * @param {ClienteCreateArgs} args - Arguments to create a Cliente.
     * @example
     * // Create one Cliente
     * const Cliente = await prisma.cliente.create({
     *   data: {
     *     // ... data to create a Cliente
     *   }
     * })
     * 
     */
    create<T extends ClienteCreateArgs>(args: SelectSubset<T, ClienteCreateArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clientes.
     * @param {ClienteCreateManyArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const cliente = await prisma.cliente.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClienteCreateManyArgs>(args?: SelectSubset<T, ClienteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clientes and returns the data saved in the database.
     * @param {ClienteCreateManyAndReturnArgs} args - Arguments to create many Clientes.
     * @example
     * // Create many Clientes
     * const cliente = await prisma.cliente.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clientes and only return the `id`
     * const clienteWithIdOnly = await prisma.cliente.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClienteCreateManyAndReturnArgs>(args?: SelectSubset<T, ClienteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Cliente.
     * @param {ClienteDeleteArgs} args - Arguments to delete one Cliente.
     * @example
     * // Delete one Cliente
     * const Cliente = await prisma.cliente.delete({
     *   where: {
     *     // ... filter to delete one Cliente
     *   }
     * })
     * 
     */
    delete<T extends ClienteDeleteArgs>(args: SelectSubset<T, ClienteDeleteArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cliente.
     * @param {ClienteUpdateArgs} args - Arguments to update one Cliente.
     * @example
     * // Update one Cliente
     * const cliente = await prisma.cliente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClienteUpdateArgs>(args: SelectSubset<T, ClienteUpdateArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clientes.
     * @param {ClienteDeleteManyArgs} args - Arguments to filter Clientes to delete.
     * @example
     * // Delete a few Clientes
     * const { count } = await prisma.cliente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClienteDeleteManyArgs>(args?: SelectSubset<T, ClienteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientes
     * const cliente = await prisma.cliente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClienteUpdateManyArgs>(args: SelectSubset<T, ClienteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cliente.
     * @param {ClienteUpsertArgs} args - Arguments to update or create a Cliente.
     * @example
     * // Update or create a Cliente
     * const cliente = await prisma.cliente.upsert({
     *   create: {
     *     // ... data to create a Cliente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cliente we want to update
     *   }
     * })
     */
    upsert<T extends ClienteUpsertArgs>(args: SelectSubset<T, ClienteUpsertArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteCountArgs} args - Arguments to filter Clientes to count.
     * @example
     * // Count the number of Clientes
     * const count = await prisma.cliente.count({
     *   where: {
     *     // ... the filter for the Clientes we want to count
     *   }
     * })
    **/
    count<T extends ClienteCountArgs>(
      args?: Subset<T, ClienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClienteAggregateArgs>(args: Subset<T, ClienteAggregateArgs>): Prisma.PrismaPromise<GetClienteAggregateType<T>>

    /**
     * Group by Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClienteGroupByArgs['orderBy'] }
        : { orderBy?: ClienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cliente model
   */
  readonly fields: ClienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cliente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reservas<T extends Cliente$reservasArgs<ExtArgs> = {}>(args?: Subset<T, Cliente$reservasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "findMany"> | Null>
    avaliacoes<T extends Cliente$avaliacoesArgs<ExtArgs> = {}>(args?: Subset<T, Cliente$avaliacoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cliente model
   */ 
  interface ClienteFieldRefs {
    readonly id: FieldRef<"Cliente", 'String'>
    readonly usuarioId: FieldRef<"Cliente", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Cliente findUnique
   */
  export type ClienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente findUniqueOrThrow
   */
  export type ClienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente findFirst
   */
  export type ClienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente findFirstOrThrow
   */
  export type ClienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Cliente to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente findMany
   */
  export type ClienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter, which Clientes to fetch.
     */
    where?: ClienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClienteOrderByWithRelationInput | ClienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clientes.
     */
    cursor?: ClienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }

  /**
   * Cliente create
   */
  export type ClienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The data needed to create a Cliente.
     */
    data: XOR<ClienteCreateInput, ClienteUncheckedCreateInput>
  }

  /**
   * Cliente createMany
   */
  export type ClienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clientes.
     */
    data: ClienteCreateManyInput | ClienteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cliente createManyAndReturn
   */
  export type ClienteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Clientes.
     */
    data: ClienteCreateManyInput | ClienteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cliente update
   */
  export type ClienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The data needed to update a Cliente.
     */
    data: XOR<ClienteUpdateInput, ClienteUncheckedUpdateInput>
    /**
     * Choose, which Cliente to update.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente updateMany
   */
  export type ClienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clientes.
     */
    data: XOR<ClienteUpdateManyMutationInput, ClienteUncheckedUpdateManyInput>
    /**
     * Filter which Clientes to update
     */
    where?: ClienteWhereInput
  }

  /**
   * Cliente upsert
   */
  export type ClienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * The filter to search for the Cliente to update in case it exists.
     */
    where: ClienteWhereUniqueInput
    /**
     * In case the Cliente found by the `where` argument doesn't exist, create a new Cliente with this data.
     */
    create: XOR<ClienteCreateInput, ClienteUncheckedCreateInput>
    /**
     * In case the Cliente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClienteUpdateInput, ClienteUncheckedUpdateInput>
  }

  /**
   * Cliente delete
   */
  export type ClienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
    /**
     * Filter which Cliente to delete.
     */
    where: ClienteWhereUniqueInput
  }

  /**
   * Cliente deleteMany
   */
  export type ClienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clientes to delete
     */
    where?: ClienteWhereInput
  }

  /**
   * Cliente.reservas
   */
  export type Cliente$reservasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    where?: ReservaWhereInput
    orderBy?: ReservaOrderByWithRelationInput | ReservaOrderByWithRelationInput[]
    cursor?: ReservaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservaScalarFieldEnum | ReservaScalarFieldEnum[]
  }

  /**
   * Cliente.avaliacoes
   */
  export type Cliente$avaliacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    where?: AvaliacaoWhereInput
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    cursor?: AvaliacaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[]
  }

  /**
   * Cliente without action
   */
  export type ClienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cliente
     */
    select?: ClienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClienteInclude<ExtArgs> | null
  }


  /**
   * Model Proprietario
   */

  export type AggregateProprietario = {
    _count: ProprietarioCountAggregateOutputType | null
    _min: ProprietarioMinAggregateOutputType | null
    _max: ProprietarioMaxAggregateOutputType | null
  }

  export type ProprietarioMinAggregateOutputType = {
    id: string | null
    usuarioId: string | null
    nivel_privilegio: $Enums.Niveis_privilegio | null
  }

  export type ProprietarioMaxAggregateOutputType = {
    id: string | null
    usuarioId: string | null
    nivel_privilegio: $Enums.Niveis_privilegio | null
  }

  export type ProprietarioCountAggregateOutputType = {
    id: number
    usuarioId: number
    nivel_privilegio: number
    _all: number
  }


  export type ProprietarioMinAggregateInputType = {
    id?: true
    usuarioId?: true
    nivel_privilegio?: true
  }

  export type ProprietarioMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    nivel_privilegio?: true
  }

  export type ProprietarioCountAggregateInputType = {
    id?: true
    usuarioId?: true
    nivel_privilegio?: true
    _all?: true
  }

  export type ProprietarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proprietario to aggregate.
     */
    where?: ProprietarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proprietarios to fetch.
     */
    orderBy?: ProprietarioOrderByWithRelationInput | ProprietarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProprietarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proprietarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proprietarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Proprietarios
    **/
    _count?: true | ProprietarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProprietarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProprietarioMaxAggregateInputType
  }

  export type GetProprietarioAggregateType<T extends ProprietarioAggregateArgs> = {
        [P in keyof T & keyof AggregateProprietario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProprietario[P]>
      : GetScalarType<T[P], AggregateProprietario[P]>
  }




  export type ProprietarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProprietarioWhereInput
    orderBy?: ProprietarioOrderByWithAggregationInput | ProprietarioOrderByWithAggregationInput[]
    by: ProprietarioScalarFieldEnum[] | ProprietarioScalarFieldEnum
    having?: ProprietarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProprietarioCountAggregateInputType | true
    _min?: ProprietarioMinAggregateInputType
    _max?: ProprietarioMaxAggregateInputType
  }

  export type ProprietarioGroupByOutputType = {
    id: string
    usuarioId: string
    nivel_privilegio: $Enums.Niveis_privilegio
    _count: ProprietarioCountAggregateOutputType | null
    _min: ProprietarioMinAggregateOutputType | null
    _max: ProprietarioMaxAggregateOutputType | null
  }

  type GetProprietarioGroupByPayload<T extends ProprietarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProprietarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProprietarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProprietarioGroupByOutputType[P]>
            : GetScalarType<T[P], ProprietarioGroupByOutputType[P]>
        }
      >
    >


  export type ProprietarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    nivel_privilegio?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    lavanderias?: boolean | Proprietario$lavanderiasArgs<ExtArgs>
    Relatorios?: boolean | Proprietario$RelatoriosArgs<ExtArgs>
    _count?: boolean | ProprietarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proprietario"]>

  export type ProprietarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    nivel_privilegio?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proprietario"]>

  export type ProprietarioSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    nivel_privilegio?: boolean
  }

  export type ProprietarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    lavanderias?: boolean | Proprietario$lavanderiasArgs<ExtArgs>
    Relatorios?: boolean | Proprietario$RelatoriosArgs<ExtArgs>
    _count?: boolean | ProprietarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProprietarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $ProprietarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Proprietario"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
      lavanderias: Prisma.$LavanderiaPayload<ExtArgs>[]
      Relatorios: Prisma.$RelatorioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usuarioId: string
      nivel_privilegio: $Enums.Niveis_privilegio
    }, ExtArgs["result"]["proprietario"]>
    composites: {}
  }

  type ProprietarioGetPayload<S extends boolean | null | undefined | ProprietarioDefaultArgs> = $Result.GetResult<Prisma.$ProprietarioPayload, S>

  type ProprietarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProprietarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProprietarioCountAggregateInputType | true
    }

  export interface ProprietarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Proprietario'], meta: { name: 'Proprietario' } }
    /**
     * Find zero or one Proprietario that matches the filter.
     * @param {ProprietarioFindUniqueArgs} args - Arguments to find a Proprietario
     * @example
     * // Get one Proprietario
     * const proprietario = await prisma.proprietario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProprietarioFindUniqueArgs>(args: SelectSubset<T, ProprietarioFindUniqueArgs<ExtArgs>>): Prisma__ProprietarioClient<$Result.GetResult<Prisma.$ProprietarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Proprietario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProprietarioFindUniqueOrThrowArgs} args - Arguments to find a Proprietario
     * @example
     * // Get one Proprietario
     * const proprietario = await prisma.proprietario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProprietarioFindUniqueOrThrowArgs>(args: SelectSubset<T, ProprietarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProprietarioClient<$Result.GetResult<Prisma.$ProprietarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Proprietario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProprietarioFindFirstArgs} args - Arguments to find a Proprietario
     * @example
     * // Get one Proprietario
     * const proprietario = await prisma.proprietario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProprietarioFindFirstArgs>(args?: SelectSubset<T, ProprietarioFindFirstArgs<ExtArgs>>): Prisma__ProprietarioClient<$Result.GetResult<Prisma.$ProprietarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Proprietario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProprietarioFindFirstOrThrowArgs} args - Arguments to find a Proprietario
     * @example
     * // Get one Proprietario
     * const proprietario = await prisma.proprietario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProprietarioFindFirstOrThrowArgs>(args?: SelectSubset<T, ProprietarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProprietarioClient<$Result.GetResult<Prisma.$ProprietarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Proprietarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProprietarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proprietarios
     * const proprietarios = await prisma.proprietario.findMany()
     * 
     * // Get first 10 Proprietarios
     * const proprietarios = await prisma.proprietario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proprietarioWithIdOnly = await prisma.proprietario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProprietarioFindManyArgs>(args?: SelectSubset<T, ProprietarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProprietarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Proprietario.
     * @param {ProprietarioCreateArgs} args - Arguments to create a Proprietario.
     * @example
     * // Create one Proprietario
     * const Proprietario = await prisma.proprietario.create({
     *   data: {
     *     // ... data to create a Proprietario
     *   }
     * })
     * 
     */
    create<T extends ProprietarioCreateArgs>(args: SelectSubset<T, ProprietarioCreateArgs<ExtArgs>>): Prisma__ProprietarioClient<$Result.GetResult<Prisma.$ProprietarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Proprietarios.
     * @param {ProprietarioCreateManyArgs} args - Arguments to create many Proprietarios.
     * @example
     * // Create many Proprietarios
     * const proprietario = await prisma.proprietario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProprietarioCreateManyArgs>(args?: SelectSubset<T, ProprietarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Proprietarios and returns the data saved in the database.
     * @param {ProprietarioCreateManyAndReturnArgs} args - Arguments to create many Proprietarios.
     * @example
     * // Create many Proprietarios
     * const proprietario = await prisma.proprietario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Proprietarios and only return the `id`
     * const proprietarioWithIdOnly = await prisma.proprietario.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProprietarioCreateManyAndReturnArgs>(args?: SelectSubset<T, ProprietarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProprietarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Proprietario.
     * @param {ProprietarioDeleteArgs} args - Arguments to delete one Proprietario.
     * @example
     * // Delete one Proprietario
     * const Proprietario = await prisma.proprietario.delete({
     *   where: {
     *     // ... filter to delete one Proprietario
     *   }
     * })
     * 
     */
    delete<T extends ProprietarioDeleteArgs>(args: SelectSubset<T, ProprietarioDeleteArgs<ExtArgs>>): Prisma__ProprietarioClient<$Result.GetResult<Prisma.$ProprietarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Proprietario.
     * @param {ProprietarioUpdateArgs} args - Arguments to update one Proprietario.
     * @example
     * // Update one Proprietario
     * const proprietario = await prisma.proprietario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProprietarioUpdateArgs>(args: SelectSubset<T, ProprietarioUpdateArgs<ExtArgs>>): Prisma__ProprietarioClient<$Result.GetResult<Prisma.$ProprietarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Proprietarios.
     * @param {ProprietarioDeleteManyArgs} args - Arguments to filter Proprietarios to delete.
     * @example
     * // Delete a few Proprietarios
     * const { count } = await prisma.proprietario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProprietarioDeleteManyArgs>(args?: SelectSubset<T, ProprietarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proprietarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProprietarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proprietarios
     * const proprietario = await prisma.proprietario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProprietarioUpdateManyArgs>(args: SelectSubset<T, ProprietarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Proprietario.
     * @param {ProprietarioUpsertArgs} args - Arguments to update or create a Proprietario.
     * @example
     * // Update or create a Proprietario
     * const proprietario = await prisma.proprietario.upsert({
     *   create: {
     *     // ... data to create a Proprietario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proprietario we want to update
     *   }
     * })
     */
    upsert<T extends ProprietarioUpsertArgs>(args: SelectSubset<T, ProprietarioUpsertArgs<ExtArgs>>): Prisma__ProprietarioClient<$Result.GetResult<Prisma.$ProprietarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Proprietarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProprietarioCountArgs} args - Arguments to filter Proprietarios to count.
     * @example
     * // Count the number of Proprietarios
     * const count = await prisma.proprietario.count({
     *   where: {
     *     // ... the filter for the Proprietarios we want to count
     *   }
     * })
    **/
    count<T extends ProprietarioCountArgs>(
      args?: Subset<T, ProprietarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProprietarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proprietario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProprietarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProprietarioAggregateArgs>(args: Subset<T, ProprietarioAggregateArgs>): Prisma.PrismaPromise<GetProprietarioAggregateType<T>>

    /**
     * Group by Proprietario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProprietarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProprietarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProprietarioGroupByArgs['orderBy'] }
        : { orderBy?: ProprietarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProprietarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProprietarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Proprietario model
   */
  readonly fields: ProprietarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Proprietario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProprietarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lavanderias<T extends Proprietario$lavanderiasArgs<ExtArgs> = {}>(args?: Subset<T, Proprietario$lavanderiasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LavanderiaPayload<ExtArgs>, T, "findMany"> | Null>
    Relatorios<T extends Proprietario$RelatoriosArgs<ExtArgs> = {}>(args?: Subset<T, Proprietario$RelatoriosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelatorioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Proprietario model
   */ 
  interface ProprietarioFieldRefs {
    readonly id: FieldRef<"Proprietario", 'String'>
    readonly usuarioId: FieldRef<"Proprietario", 'String'>
    readonly nivel_privilegio: FieldRef<"Proprietario", 'Niveis_privilegio'>
  }
    

  // Custom InputTypes
  /**
   * Proprietario findUnique
   */
  export type ProprietarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proprietario
     */
    select?: ProprietarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProprietarioInclude<ExtArgs> | null
    /**
     * Filter, which Proprietario to fetch.
     */
    where: ProprietarioWhereUniqueInput
  }

  /**
   * Proprietario findUniqueOrThrow
   */
  export type ProprietarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proprietario
     */
    select?: ProprietarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProprietarioInclude<ExtArgs> | null
    /**
     * Filter, which Proprietario to fetch.
     */
    where: ProprietarioWhereUniqueInput
  }

  /**
   * Proprietario findFirst
   */
  export type ProprietarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proprietario
     */
    select?: ProprietarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProprietarioInclude<ExtArgs> | null
    /**
     * Filter, which Proprietario to fetch.
     */
    where?: ProprietarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proprietarios to fetch.
     */
    orderBy?: ProprietarioOrderByWithRelationInput | ProprietarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proprietarios.
     */
    cursor?: ProprietarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proprietarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proprietarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proprietarios.
     */
    distinct?: ProprietarioScalarFieldEnum | ProprietarioScalarFieldEnum[]
  }

  /**
   * Proprietario findFirstOrThrow
   */
  export type ProprietarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proprietario
     */
    select?: ProprietarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProprietarioInclude<ExtArgs> | null
    /**
     * Filter, which Proprietario to fetch.
     */
    where?: ProprietarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proprietarios to fetch.
     */
    orderBy?: ProprietarioOrderByWithRelationInput | ProprietarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proprietarios.
     */
    cursor?: ProprietarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proprietarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proprietarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proprietarios.
     */
    distinct?: ProprietarioScalarFieldEnum | ProprietarioScalarFieldEnum[]
  }

  /**
   * Proprietario findMany
   */
  export type ProprietarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proprietario
     */
    select?: ProprietarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProprietarioInclude<ExtArgs> | null
    /**
     * Filter, which Proprietarios to fetch.
     */
    where?: ProprietarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proprietarios to fetch.
     */
    orderBy?: ProprietarioOrderByWithRelationInput | ProprietarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Proprietarios.
     */
    cursor?: ProprietarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proprietarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proprietarios.
     */
    skip?: number
    distinct?: ProprietarioScalarFieldEnum | ProprietarioScalarFieldEnum[]
  }

  /**
   * Proprietario create
   */
  export type ProprietarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proprietario
     */
    select?: ProprietarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProprietarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Proprietario.
     */
    data: XOR<ProprietarioCreateInput, ProprietarioUncheckedCreateInput>
  }

  /**
   * Proprietario createMany
   */
  export type ProprietarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Proprietarios.
     */
    data: ProprietarioCreateManyInput | ProprietarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Proprietario createManyAndReturn
   */
  export type ProprietarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proprietario
     */
    select?: ProprietarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Proprietarios.
     */
    data: ProprietarioCreateManyInput | ProprietarioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProprietarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Proprietario update
   */
  export type ProprietarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proprietario
     */
    select?: ProprietarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProprietarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Proprietario.
     */
    data: XOR<ProprietarioUpdateInput, ProprietarioUncheckedUpdateInput>
    /**
     * Choose, which Proprietario to update.
     */
    where: ProprietarioWhereUniqueInput
  }

  /**
   * Proprietario updateMany
   */
  export type ProprietarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Proprietarios.
     */
    data: XOR<ProprietarioUpdateManyMutationInput, ProprietarioUncheckedUpdateManyInput>
    /**
     * Filter which Proprietarios to update
     */
    where?: ProprietarioWhereInput
  }

  /**
   * Proprietario upsert
   */
  export type ProprietarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proprietario
     */
    select?: ProprietarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProprietarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Proprietario to update in case it exists.
     */
    where: ProprietarioWhereUniqueInput
    /**
     * In case the Proprietario found by the `where` argument doesn't exist, create a new Proprietario with this data.
     */
    create: XOR<ProprietarioCreateInput, ProprietarioUncheckedCreateInput>
    /**
     * In case the Proprietario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProprietarioUpdateInput, ProprietarioUncheckedUpdateInput>
  }

  /**
   * Proprietario delete
   */
  export type ProprietarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proprietario
     */
    select?: ProprietarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProprietarioInclude<ExtArgs> | null
    /**
     * Filter which Proprietario to delete.
     */
    where: ProprietarioWhereUniqueInput
  }

  /**
   * Proprietario deleteMany
   */
  export type ProprietarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proprietarios to delete
     */
    where?: ProprietarioWhereInput
  }

  /**
   * Proprietario.lavanderias
   */
  export type Proprietario$lavanderiasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lavanderia
     */
    select?: LavanderiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LavanderiaInclude<ExtArgs> | null
    where?: LavanderiaWhereInput
    orderBy?: LavanderiaOrderByWithRelationInput | LavanderiaOrderByWithRelationInput[]
    cursor?: LavanderiaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LavanderiaScalarFieldEnum | LavanderiaScalarFieldEnum[]
  }

  /**
   * Proprietario.Relatorios
   */
  export type Proprietario$RelatoriosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relatorio
     */
    select?: RelatorioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatorioInclude<ExtArgs> | null
    where?: RelatorioWhereInput
    orderBy?: RelatorioOrderByWithRelationInput | RelatorioOrderByWithRelationInput[]
    cursor?: RelatorioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelatorioScalarFieldEnum | RelatorioScalarFieldEnum[]
  }

  /**
   * Proprietario without action
   */
  export type ProprietarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proprietario
     */
    select?: ProprietarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProprietarioInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    usuarioId: string | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    usuarioId: string | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    usuarioId: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    usuarioId?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    usuarioId?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    usuarioId: string
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    relatorios?: boolean | Admin$relatoriosArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    usuarioId?: boolean
  }

  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
    relatorios?: boolean | Admin$relatoriosArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
      relatorios: Prisma.$RelatorioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usuarioId: string
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    relatorios<T extends Admin$relatoriosArgs<ExtArgs> = {}>(args?: Subset<T, Admin$relatoriosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelatorioPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */ 
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly usuarioId: FieldRef<"Admin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
  }

  /**
   * Admin.relatorios
   */
  export type Admin$relatoriosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relatorio
     */
    select?: RelatorioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatorioInclude<ExtArgs> | null
    where?: RelatorioWhereInput
    orderBy?: RelatorioOrderByWithRelationInput | RelatorioOrderByWithRelationInput[]
    cursor?: RelatorioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RelatorioScalarFieldEnum | RelatorioScalarFieldEnum[]
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model Lavanderia
   */

  export type AggregateLavanderia = {
    _count: LavanderiaCountAggregateOutputType | null
    _avg: LavanderiaAvgAggregateOutputType | null
    _sum: LavanderiaSumAggregateOutputType | null
    _min: LavanderiaMinAggregateOutputType | null
    _max: LavanderiaMaxAggregateOutputType | null
  }

  export type LavanderiaAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type LavanderiaSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
  }

  export type LavanderiaMinAggregateOutputType = {
    id: string | null
    nomeFantasia: string | null
    razaoSocial: string | null
    endereco: string | null
    telefone: string | null
    horarioAbertura: string | null
    horarioFechamento: string | null
    descricao: string | null
    fotoUrl: string | null
    latitude: number | null
    longitude: number | null
    proprietario_id: string | null
    destaque: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LavanderiaMaxAggregateOutputType = {
    id: string | null
    nomeFantasia: string | null
    razaoSocial: string | null
    endereco: string | null
    telefone: string | null
    horarioAbertura: string | null
    horarioFechamento: string | null
    descricao: string | null
    fotoUrl: string | null
    latitude: number | null
    longitude: number | null
    proprietario_id: string | null
    destaque: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LavanderiaCountAggregateOutputType = {
    id: number
    nomeFantasia: number
    razaoSocial: number
    endereco: number
    telefone: number
    horarioAbertura: number
    horarioFechamento: number
    descricao: number
    fotoUrl: number
    latitude: number
    longitude: number
    proprietario_id: number
    destaque: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LavanderiaAvgAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type LavanderiaSumAggregateInputType = {
    latitude?: true
    longitude?: true
  }

  export type LavanderiaMinAggregateInputType = {
    id?: true
    nomeFantasia?: true
    razaoSocial?: true
    endereco?: true
    telefone?: true
    horarioAbertura?: true
    horarioFechamento?: true
    descricao?: true
    fotoUrl?: true
    latitude?: true
    longitude?: true
    proprietario_id?: true
    destaque?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LavanderiaMaxAggregateInputType = {
    id?: true
    nomeFantasia?: true
    razaoSocial?: true
    endereco?: true
    telefone?: true
    horarioAbertura?: true
    horarioFechamento?: true
    descricao?: true
    fotoUrl?: true
    latitude?: true
    longitude?: true
    proprietario_id?: true
    destaque?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LavanderiaCountAggregateInputType = {
    id?: true
    nomeFantasia?: true
    razaoSocial?: true
    endereco?: true
    telefone?: true
    horarioAbertura?: true
    horarioFechamento?: true
    descricao?: true
    fotoUrl?: true
    latitude?: true
    longitude?: true
    proprietario_id?: true
    destaque?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LavanderiaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lavanderia to aggregate.
     */
    where?: LavanderiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lavanderias to fetch.
     */
    orderBy?: LavanderiaOrderByWithRelationInput | LavanderiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LavanderiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lavanderias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lavanderias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lavanderias
    **/
    _count?: true | LavanderiaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LavanderiaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LavanderiaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LavanderiaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LavanderiaMaxAggregateInputType
  }

  export type GetLavanderiaAggregateType<T extends LavanderiaAggregateArgs> = {
        [P in keyof T & keyof AggregateLavanderia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLavanderia[P]>
      : GetScalarType<T[P], AggregateLavanderia[P]>
  }




  export type LavanderiaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LavanderiaWhereInput
    orderBy?: LavanderiaOrderByWithAggregationInput | LavanderiaOrderByWithAggregationInput[]
    by: LavanderiaScalarFieldEnum[] | LavanderiaScalarFieldEnum
    having?: LavanderiaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LavanderiaCountAggregateInputType | true
    _avg?: LavanderiaAvgAggregateInputType
    _sum?: LavanderiaSumAggregateInputType
    _min?: LavanderiaMinAggregateInputType
    _max?: LavanderiaMaxAggregateInputType
  }

  export type LavanderiaGroupByOutputType = {
    id: string
    nomeFantasia: string
    razaoSocial: string
    endereco: string
    telefone: string | null
    horarioAbertura: string | null
    horarioFechamento: string | null
    descricao: string | null
    fotoUrl: string | null
    latitude: number | null
    longitude: number | null
    proprietario_id: string
    destaque: boolean
    createdAt: Date
    updatedAt: Date
    _count: LavanderiaCountAggregateOutputType | null
    _avg: LavanderiaAvgAggregateOutputType | null
    _sum: LavanderiaSumAggregateOutputType | null
    _min: LavanderiaMinAggregateOutputType | null
    _max: LavanderiaMaxAggregateOutputType | null
  }

  type GetLavanderiaGroupByPayload<T extends LavanderiaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LavanderiaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LavanderiaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LavanderiaGroupByOutputType[P]>
            : GetScalarType<T[P], LavanderiaGroupByOutputType[P]>
        }
      >
    >


  export type LavanderiaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nomeFantasia?: boolean
    razaoSocial?: boolean
    endereco?: boolean
    telefone?: boolean
    horarioAbertura?: boolean
    horarioFechamento?: boolean
    descricao?: boolean
    fotoUrl?: boolean
    latitude?: boolean
    longitude?: boolean
    proprietario_id?: boolean
    destaque?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    proprietario?: boolean | ProprietarioDefaultArgs<ExtArgs>
    maquinas?: boolean | Lavanderia$maquinasArgs<ExtArgs>
    avaliacoes?: boolean | Lavanderia$avaliacoesArgs<ExtArgs>
    _count?: boolean | LavanderiaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lavanderia"]>

  export type LavanderiaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nomeFantasia?: boolean
    razaoSocial?: boolean
    endereco?: boolean
    telefone?: boolean
    horarioAbertura?: boolean
    horarioFechamento?: boolean
    descricao?: boolean
    fotoUrl?: boolean
    latitude?: boolean
    longitude?: boolean
    proprietario_id?: boolean
    destaque?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    proprietario?: boolean | ProprietarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lavanderia"]>

  export type LavanderiaSelectScalar = {
    id?: boolean
    nomeFantasia?: boolean
    razaoSocial?: boolean
    endereco?: boolean
    telefone?: boolean
    horarioAbertura?: boolean
    horarioFechamento?: boolean
    descricao?: boolean
    fotoUrl?: boolean
    latitude?: boolean
    longitude?: boolean
    proprietario_id?: boolean
    destaque?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LavanderiaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proprietario?: boolean | ProprietarioDefaultArgs<ExtArgs>
    maquinas?: boolean | Lavanderia$maquinasArgs<ExtArgs>
    avaliacoes?: boolean | Lavanderia$avaliacoesArgs<ExtArgs>
    _count?: boolean | LavanderiaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LavanderiaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proprietario?: boolean | ProprietarioDefaultArgs<ExtArgs>
  }

  export type $LavanderiaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lavanderia"
    objects: {
      proprietario: Prisma.$ProprietarioPayload<ExtArgs>
      maquinas: Prisma.$MaquinaPayload<ExtArgs>[]
      avaliacoes: Prisma.$AvaliacaoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nomeFantasia: string
      razaoSocial: string
      endereco: string
      telefone: string | null
      horarioAbertura: string | null
      horarioFechamento: string | null
      descricao: string | null
      fotoUrl: string | null
      latitude: number | null
      longitude: number | null
      proprietario_id: string
      destaque: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lavanderia"]>
    composites: {}
  }

  type LavanderiaGetPayload<S extends boolean | null | undefined | LavanderiaDefaultArgs> = $Result.GetResult<Prisma.$LavanderiaPayload, S>

  type LavanderiaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LavanderiaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LavanderiaCountAggregateInputType | true
    }

  export interface LavanderiaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lavanderia'], meta: { name: 'Lavanderia' } }
    /**
     * Find zero or one Lavanderia that matches the filter.
     * @param {LavanderiaFindUniqueArgs} args - Arguments to find a Lavanderia
     * @example
     * // Get one Lavanderia
     * const lavanderia = await prisma.lavanderia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LavanderiaFindUniqueArgs>(args: SelectSubset<T, LavanderiaFindUniqueArgs<ExtArgs>>): Prisma__LavanderiaClient<$Result.GetResult<Prisma.$LavanderiaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lavanderia that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LavanderiaFindUniqueOrThrowArgs} args - Arguments to find a Lavanderia
     * @example
     * // Get one Lavanderia
     * const lavanderia = await prisma.lavanderia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LavanderiaFindUniqueOrThrowArgs>(args: SelectSubset<T, LavanderiaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LavanderiaClient<$Result.GetResult<Prisma.$LavanderiaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lavanderia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LavanderiaFindFirstArgs} args - Arguments to find a Lavanderia
     * @example
     * // Get one Lavanderia
     * const lavanderia = await prisma.lavanderia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LavanderiaFindFirstArgs>(args?: SelectSubset<T, LavanderiaFindFirstArgs<ExtArgs>>): Prisma__LavanderiaClient<$Result.GetResult<Prisma.$LavanderiaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lavanderia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LavanderiaFindFirstOrThrowArgs} args - Arguments to find a Lavanderia
     * @example
     * // Get one Lavanderia
     * const lavanderia = await prisma.lavanderia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LavanderiaFindFirstOrThrowArgs>(args?: SelectSubset<T, LavanderiaFindFirstOrThrowArgs<ExtArgs>>): Prisma__LavanderiaClient<$Result.GetResult<Prisma.$LavanderiaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lavanderias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LavanderiaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lavanderias
     * const lavanderias = await prisma.lavanderia.findMany()
     * 
     * // Get first 10 Lavanderias
     * const lavanderias = await prisma.lavanderia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lavanderiaWithIdOnly = await prisma.lavanderia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LavanderiaFindManyArgs>(args?: SelectSubset<T, LavanderiaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LavanderiaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lavanderia.
     * @param {LavanderiaCreateArgs} args - Arguments to create a Lavanderia.
     * @example
     * // Create one Lavanderia
     * const Lavanderia = await prisma.lavanderia.create({
     *   data: {
     *     // ... data to create a Lavanderia
     *   }
     * })
     * 
     */
    create<T extends LavanderiaCreateArgs>(args: SelectSubset<T, LavanderiaCreateArgs<ExtArgs>>): Prisma__LavanderiaClient<$Result.GetResult<Prisma.$LavanderiaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lavanderias.
     * @param {LavanderiaCreateManyArgs} args - Arguments to create many Lavanderias.
     * @example
     * // Create many Lavanderias
     * const lavanderia = await prisma.lavanderia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LavanderiaCreateManyArgs>(args?: SelectSubset<T, LavanderiaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lavanderias and returns the data saved in the database.
     * @param {LavanderiaCreateManyAndReturnArgs} args - Arguments to create many Lavanderias.
     * @example
     * // Create many Lavanderias
     * const lavanderia = await prisma.lavanderia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lavanderias and only return the `id`
     * const lavanderiaWithIdOnly = await prisma.lavanderia.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LavanderiaCreateManyAndReturnArgs>(args?: SelectSubset<T, LavanderiaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LavanderiaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Lavanderia.
     * @param {LavanderiaDeleteArgs} args - Arguments to delete one Lavanderia.
     * @example
     * // Delete one Lavanderia
     * const Lavanderia = await prisma.lavanderia.delete({
     *   where: {
     *     // ... filter to delete one Lavanderia
     *   }
     * })
     * 
     */
    delete<T extends LavanderiaDeleteArgs>(args: SelectSubset<T, LavanderiaDeleteArgs<ExtArgs>>): Prisma__LavanderiaClient<$Result.GetResult<Prisma.$LavanderiaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lavanderia.
     * @param {LavanderiaUpdateArgs} args - Arguments to update one Lavanderia.
     * @example
     * // Update one Lavanderia
     * const lavanderia = await prisma.lavanderia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LavanderiaUpdateArgs>(args: SelectSubset<T, LavanderiaUpdateArgs<ExtArgs>>): Prisma__LavanderiaClient<$Result.GetResult<Prisma.$LavanderiaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lavanderias.
     * @param {LavanderiaDeleteManyArgs} args - Arguments to filter Lavanderias to delete.
     * @example
     * // Delete a few Lavanderias
     * const { count } = await prisma.lavanderia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LavanderiaDeleteManyArgs>(args?: SelectSubset<T, LavanderiaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lavanderias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LavanderiaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lavanderias
     * const lavanderia = await prisma.lavanderia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LavanderiaUpdateManyArgs>(args: SelectSubset<T, LavanderiaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lavanderia.
     * @param {LavanderiaUpsertArgs} args - Arguments to update or create a Lavanderia.
     * @example
     * // Update or create a Lavanderia
     * const lavanderia = await prisma.lavanderia.upsert({
     *   create: {
     *     // ... data to create a Lavanderia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lavanderia we want to update
     *   }
     * })
     */
    upsert<T extends LavanderiaUpsertArgs>(args: SelectSubset<T, LavanderiaUpsertArgs<ExtArgs>>): Prisma__LavanderiaClient<$Result.GetResult<Prisma.$LavanderiaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lavanderias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LavanderiaCountArgs} args - Arguments to filter Lavanderias to count.
     * @example
     * // Count the number of Lavanderias
     * const count = await prisma.lavanderia.count({
     *   where: {
     *     // ... the filter for the Lavanderias we want to count
     *   }
     * })
    **/
    count<T extends LavanderiaCountArgs>(
      args?: Subset<T, LavanderiaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LavanderiaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lavanderia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LavanderiaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LavanderiaAggregateArgs>(args: Subset<T, LavanderiaAggregateArgs>): Prisma.PrismaPromise<GetLavanderiaAggregateType<T>>

    /**
     * Group by Lavanderia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LavanderiaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LavanderiaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LavanderiaGroupByArgs['orderBy'] }
        : { orderBy?: LavanderiaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LavanderiaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLavanderiaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lavanderia model
   */
  readonly fields: LavanderiaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lavanderia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LavanderiaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proprietario<T extends ProprietarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProprietarioDefaultArgs<ExtArgs>>): Prisma__ProprietarioClient<$Result.GetResult<Prisma.$ProprietarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    maquinas<T extends Lavanderia$maquinasArgs<ExtArgs> = {}>(args?: Subset<T, Lavanderia$maquinasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaquinaPayload<ExtArgs>, T, "findMany"> | Null>
    avaliacoes<T extends Lavanderia$avaliacoesArgs<ExtArgs> = {}>(args?: Subset<T, Lavanderia$avaliacoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lavanderia model
   */ 
  interface LavanderiaFieldRefs {
    readonly id: FieldRef<"Lavanderia", 'String'>
    readonly nomeFantasia: FieldRef<"Lavanderia", 'String'>
    readonly razaoSocial: FieldRef<"Lavanderia", 'String'>
    readonly endereco: FieldRef<"Lavanderia", 'String'>
    readonly telefone: FieldRef<"Lavanderia", 'String'>
    readonly horarioAbertura: FieldRef<"Lavanderia", 'String'>
    readonly horarioFechamento: FieldRef<"Lavanderia", 'String'>
    readonly descricao: FieldRef<"Lavanderia", 'String'>
    readonly fotoUrl: FieldRef<"Lavanderia", 'String'>
    readonly latitude: FieldRef<"Lavanderia", 'Float'>
    readonly longitude: FieldRef<"Lavanderia", 'Float'>
    readonly proprietario_id: FieldRef<"Lavanderia", 'String'>
    readonly destaque: FieldRef<"Lavanderia", 'Boolean'>
    readonly createdAt: FieldRef<"Lavanderia", 'DateTime'>
    readonly updatedAt: FieldRef<"Lavanderia", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lavanderia findUnique
   */
  export type LavanderiaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lavanderia
     */
    select?: LavanderiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LavanderiaInclude<ExtArgs> | null
    /**
     * Filter, which Lavanderia to fetch.
     */
    where: LavanderiaWhereUniqueInput
  }

  /**
   * Lavanderia findUniqueOrThrow
   */
  export type LavanderiaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lavanderia
     */
    select?: LavanderiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LavanderiaInclude<ExtArgs> | null
    /**
     * Filter, which Lavanderia to fetch.
     */
    where: LavanderiaWhereUniqueInput
  }

  /**
   * Lavanderia findFirst
   */
  export type LavanderiaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lavanderia
     */
    select?: LavanderiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LavanderiaInclude<ExtArgs> | null
    /**
     * Filter, which Lavanderia to fetch.
     */
    where?: LavanderiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lavanderias to fetch.
     */
    orderBy?: LavanderiaOrderByWithRelationInput | LavanderiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lavanderias.
     */
    cursor?: LavanderiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lavanderias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lavanderias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lavanderias.
     */
    distinct?: LavanderiaScalarFieldEnum | LavanderiaScalarFieldEnum[]
  }

  /**
   * Lavanderia findFirstOrThrow
   */
  export type LavanderiaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lavanderia
     */
    select?: LavanderiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LavanderiaInclude<ExtArgs> | null
    /**
     * Filter, which Lavanderia to fetch.
     */
    where?: LavanderiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lavanderias to fetch.
     */
    orderBy?: LavanderiaOrderByWithRelationInput | LavanderiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lavanderias.
     */
    cursor?: LavanderiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lavanderias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lavanderias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lavanderias.
     */
    distinct?: LavanderiaScalarFieldEnum | LavanderiaScalarFieldEnum[]
  }

  /**
   * Lavanderia findMany
   */
  export type LavanderiaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lavanderia
     */
    select?: LavanderiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LavanderiaInclude<ExtArgs> | null
    /**
     * Filter, which Lavanderias to fetch.
     */
    where?: LavanderiaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lavanderias to fetch.
     */
    orderBy?: LavanderiaOrderByWithRelationInput | LavanderiaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lavanderias.
     */
    cursor?: LavanderiaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lavanderias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lavanderias.
     */
    skip?: number
    distinct?: LavanderiaScalarFieldEnum | LavanderiaScalarFieldEnum[]
  }

  /**
   * Lavanderia create
   */
  export type LavanderiaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lavanderia
     */
    select?: LavanderiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LavanderiaInclude<ExtArgs> | null
    /**
     * The data needed to create a Lavanderia.
     */
    data: XOR<LavanderiaCreateInput, LavanderiaUncheckedCreateInput>
  }

  /**
   * Lavanderia createMany
   */
  export type LavanderiaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lavanderias.
     */
    data: LavanderiaCreateManyInput | LavanderiaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lavanderia createManyAndReturn
   */
  export type LavanderiaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lavanderia
     */
    select?: LavanderiaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Lavanderias.
     */
    data: LavanderiaCreateManyInput | LavanderiaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LavanderiaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lavanderia update
   */
  export type LavanderiaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lavanderia
     */
    select?: LavanderiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LavanderiaInclude<ExtArgs> | null
    /**
     * The data needed to update a Lavanderia.
     */
    data: XOR<LavanderiaUpdateInput, LavanderiaUncheckedUpdateInput>
    /**
     * Choose, which Lavanderia to update.
     */
    where: LavanderiaWhereUniqueInput
  }

  /**
   * Lavanderia updateMany
   */
  export type LavanderiaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lavanderias.
     */
    data: XOR<LavanderiaUpdateManyMutationInput, LavanderiaUncheckedUpdateManyInput>
    /**
     * Filter which Lavanderias to update
     */
    where?: LavanderiaWhereInput
  }

  /**
   * Lavanderia upsert
   */
  export type LavanderiaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lavanderia
     */
    select?: LavanderiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LavanderiaInclude<ExtArgs> | null
    /**
     * The filter to search for the Lavanderia to update in case it exists.
     */
    where: LavanderiaWhereUniqueInput
    /**
     * In case the Lavanderia found by the `where` argument doesn't exist, create a new Lavanderia with this data.
     */
    create: XOR<LavanderiaCreateInput, LavanderiaUncheckedCreateInput>
    /**
     * In case the Lavanderia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LavanderiaUpdateInput, LavanderiaUncheckedUpdateInput>
  }

  /**
   * Lavanderia delete
   */
  export type LavanderiaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lavanderia
     */
    select?: LavanderiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LavanderiaInclude<ExtArgs> | null
    /**
     * Filter which Lavanderia to delete.
     */
    where: LavanderiaWhereUniqueInput
  }

  /**
   * Lavanderia deleteMany
   */
  export type LavanderiaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lavanderias to delete
     */
    where?: LavanderiaWhereInput
  }

  /**
   * Lavanderia.maquinas
   */
  export type Lavanderia$maquinasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maquina
     */
    select?: MaquinaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaquinaInclude<ExtArgs> | null
    where?: MaquinaWhereInput
    orderBy?: MaquinaOrderByWithRelationInput | MaquinaOrderByWithRelationInput[]
    cursor?: MaquinaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaquinaScalarFieldEnum | MaquinaScalarFieldEnum[]
  }

  /**
   * Lavanderia.avaliacoes
   */
  export type Lavanderia$avaliacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    where?: AvaliacaoWhereInput
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    cursor?: AvaliacaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[]
  }

  /**
   * Lavanderia without action
   */
  export type LavanderiaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lavanderia
     */
    select?: LavanderiaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LavanderiaInclude<ExtArgs> | null
  }


  /**
   * Model Maquina
   */

  export type AggregateMaquina = {
    _count: MaquinaCountAggregateOutputType | null
    _avg: MaquinaAvgAggregateOutputType | null
    _sum: MaquinaSumAggregateOutputType | null
    _min: MaquinaMinAggregateOutputType | null
    _max: MaquinaMaxAggregateOutputType | null
  }

  export type MaquinaAvgAggregateOutputType = {
    capacidade: number | null
    preco: Decimal | null
  }

  export type MaquinaSumAggregateOutputType = {
    capacidade: number | null
    preco: Decimal | null
  }

  export type MaquinaMinAggregateOutputType = {
    id: string | null
    tipo: $Enums.Tipo_maquina | null
    status_maquina: $Enums.Status_maquina | null
    capacidade: number | null
    preco: Decimal | null
    lavanderia_id: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type MaquinaMaxAggregateOutputType = {
    id: string | null
    tipo: $Enums.Tipo_maquina | null
    status_maquina: $Enums.Status_maquina | null
    capacidade: number | null
    preco: Decimal | null
    lavanderia_id: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type MaquinaCountAggregateOutputType = {
    id: number
    tipo: number
    status_maquina: number
    capacidade: number
    preco: number
    lavanderia_id: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type MaquinaAvgAggregateInputType = {
    capacidade?: true
    preco?: true
  }

  export type MaquinaSumAggregateInputType = {
    capacidade?: true
    preco?: true
  }

  export type MaquinaMinAggregateInputType = {
    id?: true
    tipo?: true
    status_maquina?: true
    capacidade?: true
    preco?: true
    lavanderia_id?: true
    createAt?: true
    updateAt?: true
  }

  export type MaquinaMaxAggregateInputType = {
    id?: true
    tipo?: true
    status_maquina?: true
    capacidade?: true
    preco?: true
    lavanderia_id?: true
    createAt?: true
    updateAt?: true
  }

  export type MaquinaCountAggregateInputType = {
    id?: true
    tipo?: true
    status_maquina?: true
    capacidade?: true
    preco?: true
    lavanderia_id?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type MaquinaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Maquina to aggregate.
     */
    where?: MaquinaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maquinas to fetch.
     */
    orderBy?: MaquinaOrderByWithRelationInput | MaquinaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaquinaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maquinas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maquinas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Maquinas
    **/
    _count?: true | MaquinaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaquinaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaquinaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaquinaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaquinaMaxAggregateInputType
  }

  export type GetMaquinaAggregateType<T extends MaquinaAggregateArgs> = {
        [P in keyof T & keyof AggregateMaquina]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaquina[P]>
      : GetScalarType<T[P], AggregateMaquina[P]>
  }




  export type MaquinaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaquinaWhereInput
    orderBy?: MaquinaOrderByWithAggregationInput | MaquinaOrderByWithAggregationInput[]
    by: MaquinaScalarFieldEnum[] | MaquinaScalarFieldEnum
    having?: MaquinaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaquinaCountAggregateInputType | true
    _avg?: MaquinaAvgAggregateInputType
    _sum?: MaquinaSumAggregateInputType
    _min?: MaquinaMinAggregateInputType
    _max?: MaquinaMaxAggregateInputType
  }

  export type MaquinaGroupByOutputType = {
    id: string
    tipo: $Enums.Tipo_maquina
    status_maquina: $Enums.Status_maquina
    capacidade: number
    preco: Decimal
    lavanderia_id: string
    createAt: Date
    updateAt: Date
    _count: MaquinaCountAggregateOutputType | null
    _avg: MaquinaAvgAggregateOutputType | null
    _sum: MaquinaSumAggregateOutputType | null
    _min: MaquinaMinAggregateOutputType | null
    _max: MaquinaMaxAggregateOutputType | null
  }

  type GetMaquinaGroupByPayload<T extends MaquinaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaquinaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaquinaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaquinaGroupByOutputType[P]>
            : GetScalarType<T[P], MaquinaGroupByOutputType[P]>
        }
      >
    >


  export type MaquinaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    status_maquina?: boolean
    capacidade?: boolean
    preco?: boolean
    lavanderia_id?: boolean
    createAt?: boolean
    updateAt?: boolean
    lavanderia?: boolean | LavanderiaDefaultArgs<ExtArgs>
    reservas?: boolean | Maquina$reservasArgs<ExtArgs>
    _count?: boolean | MaquinaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maquina"]>

  export type MaquinaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    status_maquina?: boolean
    capacidade?: boolean
    preco?: boolean
    lavanderia_id?: boolean
    createAt?: boolean
    updateAt?: boolean
    lavanderia?: boolean | LavanderiaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maquina"]>

  export type MaquinaSelectScalar = {
    id?: boolean
    tipo?: boolean
    status_maquina?: boolean
    capacidade?: boolean
    preco?: boolean
    lavanderia_id?: boolean
    createAt?: boolean
    updateAt?: boolean
  }

  export type MaquinaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lavanderia?: boolean | LavanderiaDefaultArgs<ExtArgs>
    reservas?: boolean | Maquina$reservasArgs<ExtArgs>
    _count?: boolean | MaquinaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaquinaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lavanderia?: boolean | LavanderiaDefaultArgs<ExtArgs>
  }

  export type $MaquinaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Maquina"
    objects: {
      lavanderia: Prisma.$LavanderiaPayload<ExtArgs>
      reservas: Prisma.$ReservaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tipo: $Enums.Tipo_maquina
      status_maquina: $Enums.Status_maquina
      capacidade: number
      preco: Prisma.Decimal
      lavanderia_id: string
      createAt: Date
      updateAt: Date
    }, ExtArgs["result"]["maquina"]>
    composites: {}
  }

  type MaquinaGetPayload<S extends boolean | null | undefined | MaquinaDefaultArgs> = $Result.GetResult<Prisma.$MaquinaPayload, S>

  type MaquinaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaquinaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaquinaCountAggregateInputType | true
    }

  export interface MaquinaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Maquina'], meta: { name: 'Maquina' } }
    /**
     * Find zero or one Maquina that matches the filter.
     * @param {MaquinaFindUniqueArgs} args - Arguments to find a Maquina
     * @example
     * // Get one Maquina
     * const maquina = await prisma.maquina.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaquinaFindUniqueArgs>(args: SelectSubset<T, MaquinaFindUniqueArgs<ExtArgs>>): Prisma__MaquinaClient<$Result.GetResult<Prisma.$MaquinaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Maquina that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaquinaFindUniqueOrThrowArgs} args - Arguments to find a Maquina
     * @example
     * // Get one Maquina
     * const maquina = await prisma.maquina.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaquinaFindUniqueOrThrowArgs>(args: SelectSubset<T, MaquinaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaquinaClient<$Result.GetResult<Prisma.$MaquinaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Maquina that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaquinaFindFirstArgs} args - Arguments to find a Maquina
     * @example
     * // Get one Maquina
     * const maquina = await prisma.maquina.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaquinaFindFirstArgs>(args?: SelectSubset<T, MaquinaFindFirstArgs<ExtArgs>>): Prisma__MaquinaClient<$Result.GetResult<Prisma.$MaquinaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Maquina that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaquinaFindFirstOrThrowArgs} args - Arguments to find a Maquina
     * @example
     * // Get one Maquina
     * const maquina = await prisma.maquina.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaquinaFindFirstOrThrowArgs>(args?: SelectSubset<T, MaquinaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaquinaClient<$Result.GetResult<Prisma.$MaquinaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Maquinas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaquinaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Maquinas
     * const maquinas = await prisma.maquina.findMany()
     * 
     * // Get first 10 Maquinas
     * const maquinas = await prisma.maquina.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maquinaWithIdOnly = await prisma.maquina.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaquinaFindManyArgs>(args?: SelectSubset<T, MaquinaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaquinaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Maquina.
     * @param {MaquinaCreateArgs} args - Arguments to create a Maquina.
     * @example
     * // Create one Maquina
     * const Maquina = await prisma.maquina.create({
     *   data: {
     *     // ... data to create a Maquina
     *   }
     * })
     * 
     */
    create<T extends MaquinaCreateArgs>(args: SelectSubset<T, MaquinaCreateArgs<ExtArgs>>): Prisma__MaquinaClient<$Result.GetResult<Prisma.$MaquinaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Maquinas.
     * @param {MaquinaCreateManyArgs} args - Arguments to create many Maquinas.
     * @example
     * // Create many Maquinas
     * const maquina = await prisma.maquina.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaquinaCreateManyArgs>(args?: SelectSubset<T, MaquinaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Maquinas and returns the data saved in the database.
     * @param {MaquinaCreateManyAndReturnArgs} args - Arguments to create many Maquinas.
     * @example
     * // Create many Maquinas
     * const maquina = await prisma.maquina.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Maquinas and only return the `id`
     * const maquinaWithIdOnly = await prisma.maquina.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaquinaCreateManyAndReturnArgs>(args?: SelectSubset<T, MaquinaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaquinaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Maquina.
     * @param {MaquinaDeleteArgs} args - Arguments to delete one Maquina.
     * @example
     * // Delete one Maquina
     * const Maquina = await prisma.maquina.delete({
     *   where: {
     *     // ... filter to delete one Maquina
     *   }
     * })
     * 
     */
    delete<T extends MaquinaDeleteArgs>(args: SelectSubset<T, MaquinaDeleteArgs<ExtArgs>>): Prisma__MaquinaClient<$Result.GetResult<Prisma.$MaquinaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Maquina.
     * @param {MaquinaUpdateArgs} args - Arguments to update one Maquina.
     * @example
     * // Update one Maquina
     * const maquina = await prisma.maquina.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaquinaUpdateArgs>(args: SelectSubset<T, MaquinaUpdateArgs<ExtArgs>>): Prisma__MaquinaClient<$Result.GetResult<Prisma.$MaquinaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Maquinas.
     * @param {MaquinaDeleteManyArgs} args - Arguments to filter Maquinas to delete.
     * @example
     * // Delete a few Maquinas
     * const { count } = await prisma.maquina.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaquinaDeleteManyArgs>(args?: SelectSubset<T, MaquinaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maquinas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaquinaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Maquinas
     * const maquina = await prisma.maquina.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaquinaUpdateManyArgs>(args: SelectSubset<T, MaquinaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Maquina.
     * @param {MaquinaUpsertArgs} args - Arguments to update or create a Maquina.
     * @example
     * // Update or create a Maquina
     * const maquina = await prisma.maquina.upsert({
     *   create: {
     *     // ... data to create a Maquina
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Maquina we want to update
     *   }
     * })
     */
    upsert<T extends MaquinaUpsertArgs>(args: SelectSubset<T, MaquinaUpsertArgs<ExtArgs>>): Prisma__MaquinaClient<$Result.GetResult<Prisma.$MaquinaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Maquinas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaquinaCountArgs} args - Arguments to filter Maquinas to count.
     * @example
     * // Count the number of Maquinas
     * const count = await prisma.maquina.count({
     *   where: {
     *     // ... the filter for the Maquinas we want to count
     *   }
     * })
    **/
    count<T extends MaquinaCountArgs>(
      args?: Subset<T, MaquinaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaquinaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Maquina.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaquinaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaquinaAggregateArgs>(args: Subset<T, MaquinaAggregateArgs>): Prisma.PrismaPromise<GetMaquinaAggregateType<T>>

    /**
     * Group by Maquina.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaquinaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaquinaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaquinaGroupByArgs['orderBy'] }
        : { orderBy?: MaquinaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaquinaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaquinaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Maquina model
   */
  readonly fields: MaquinaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Maquina.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaquinaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lavanderia<T extends LavanderiaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LavanderiaDefaultArgs<ExtArgs>>): Prisma__LavanderiaClient<$Result.GetResult<Prisma.$LavanderiaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reservas<T extends Maquina$reservasArgs<ExtArgs> = {}>(args?: Subset<T, Maquina$reservasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Maquina model
   */ 
  interface MaquinaFieldRefs {
    readonly id: FieldRef<"Maquina", 'String'>
    readonly tipo: FieldRef<"Maquina", 'Tipo_maquina'>
    readonly status_maquina: FieldRef<"Maquina", 'Status_maquina'>
    readonly capacidade: FieldRef<"Maquina", 'Int'>
    readonly preco: FieldRef<"Maquina", 'Decimal'>
    readonly lavanderia_id: FieldRef<"Maquina", 'String'>
    readonly createAt: FieldRef<"Maquina", 'DateTime'>
    readonly updateAt: FieldRef<"Maquina", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Maquina findUnique
   */
  export type MaquinaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maquina
     */
    select?: MaquinaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaquinaInclude<ExtArgs> | null
    /**
     * Filter, which Maquina to fetch.
     */
    where: MaquinaWhereUniqueInput
  }

  /**
   * Maquina findUniqueOrThrow
   */
  export type MaquinaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maquina
     */
    select?: MaquinaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaquinaInclude<ExtArgs> | null
    /**
     * Filter, which Maquina to fetch.
     */
    where: MaquinaWhereUniqueInput
  }

  /**
   * Maquina findFirst
   */
  export type MaquinaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maquina
     */
    select?: MaquinaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaquinaInclude<ExtArgs> | null
    /**
     * Filter, which Maquina to fetch.
     */
    where?: MaquinaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maquinas to fetch.
     */
    orderBy?: MaquinaOrderByWithRelationInput | MaquinaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maquinas.
     */
    cursor?: MaquinaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maquinas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maquinas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maquinas.
     */
    distinct?: MaquinaScalarFieldEnum | MaquinaScalarFieldEnum[]
  }

  /**
   * Maquina findFirstOrThrow
   */
  export type MaquinaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maquina
     */
    select?: MaquinaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaquinaInclude<ExtArgs> | null
    /**
     * Filter, which Maquina to fetch.
     */
    where?: MaquinaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maquinas to fetch.
     */
    orderBy?: MaquinaOrderByWithRelationInput | MaquinaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maquinas.
     */
    cursor?: MaquinaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maquinas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maquinas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maquinas.
     */
    distinct?: MaquinaScalarFieldEnum | MaquinaScalarFieldEnum[]
  }

  /**
   * Maquina findMany
   */
  export type MaquinaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maquina
     */
    select?: MaquinaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaquinaInclude<ExtArgs> | null
    /**
     * Filter, which Maquinas to fetch.
     */
    where?: MaquinaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maquinas to fetch.
     */
    orderBy?: MaquinaOrderByWithRelationInput | MaquinaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Maquinas.
     */
    cursor?: MaquinaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maquinas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maquinas.
     */
    skip?: number
    distinct?: MaquinaScalarFieldEnum | MaquinaScalarFieldEnum[]
  }

  /**
   * Maquina create
   */
  export type MaquinaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maquina
     */
    select?: MaquinaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaquinaInclude<ExtArgs> | null
    /**
     * The data needed to create a Maquina.
     */
    data: XOR<MaquinaCreateInput, MaquinaUncheckedCreateInput>
  }

  /**
   * Maquina createMany
   */
  export type MaquinaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Maquinas.
     */
    data: MaquinaCreateManyInput | MaquinaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Maquina createManyAndReturn
   */
  export type MaquinaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maquina
     */
    select?: MaquinaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Maquinas.
     */
    data: MaquinaCreateManyInput | MaquinaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaquinaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Maquina update
   */
  export type MaquinaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maquina
     */
    select?: MaquinaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaquinaInclude<ExtArgs> | null
    /**
     * The data needed to update a Maquina.
     */
    data: XOR<MaquinaUpdateInput, MaquinaUncheckedUpdateInput>
    /**
     * Choose, which Maquina to update.
     */
    where: MaquinaWhereUniqueInput
  }

  /**
   * Maquina updateMany
   */
  export type MaquinaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Maquinas.
     */
    data: XOR<MaquinaUpdateManyMutationInput, MaquinaUncheckedUpdateManyInput>
    /**
     * Filter which Maquinas to update
     */
    where?: MaquinaWhereInput
  }

  /**
   * Maquina upsert
   */
  export type MaquinaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maquina
     */
    select?: MaquinaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaquinaInclude<ExtArgs> | null
    /**
     * The filter to search for the Maquina to update in case it exists.
     */
    where: MaquinaWhereUniqueInput
    /**
     * In case the Maquina found by the `where` argument doesn't exist, create a new Maquina with this data.
     */
    create: XOR<MaquinaCreateInput, MaquinaUncheckedCreateInput>
    /**
     * In case the Maquina was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaquinaUpdateInput, MaquinaUncheckedUpdateInput>
  }

  /**
   * Maquina delete
   */
  export type MaquinaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maquina
     */
    select?: MaquinaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaquinaInclude<ExtArgs> | null
    /**
     * Filter which Maquina to delete.
     */
    where: MaquinaWhereUniqueInput
  }

  /**
   * Maquina deleteMany
   */
  export type MaquinaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Maquinas to delete
     */
    where?: MaquinaWhereInput
  }

  /**
   * Maquina.reservas
   */
  export type Maquina$reservasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    where?: ReservaWhereInput
    orderBy?: ReservaOrderByWithRelationInput | ReservaOrderByWithRelationInput[]
    cursor?: ReservaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservaScalarFieldEnum | ReservaScalarFieldEnum[]
  }

  /**
   * Maquina without action
   */
  export type MaquinaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maquina
     */
    select?: MaquinaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaquinaInclude<ExtArgs> | null
  }


  /**
   * Model Relatorio
   */

  export type AggregateRelatorio = {
    _count: RelatorioCountAggregateOutputType | null
    _min: RelatorioMinAggregateOutputType | null
    _max: RelatorioMaxAggregateOutputType | null
  }

  export type RelatorioMinAggregateOutputType = {
    id: string | null
    admin_id: string | null
    proprietario_id: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type RelatorioMaxAggregateOutputType = {
    id: string | null
    admin_id: string | null
    proprietario_id: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type RelatorioCountAggregateOutputType = {
    id: number
    admin_id: number
    proprietario_id: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type RelatorioMinAggregateInputType = {
    id?: true
    admin_id?: true
    proprietario_id?: true
    createAt?: true
    updateAt?: true
  }

  export type RelatorioMaxAggregateInputType = {
    id?: true
    admin_id?: true
    proprietario_id?: true
    createAt?: true
    updateAt?: true
  }

  export type RelatorioCountAggregateInputType = {
    id?: true
    admin_id?: true
    proprietario_id?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type RelatorioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Relatorio to aggregate.
     */
    where?: RelatorioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Relatorios to fetch.
     */
    orderBy?: RelatorioOrderByWithRelationInput | RelatorioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RelatorioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Relatorios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Relatorios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Relatorios
    **/
    _count?: true | RelatorioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RelatorioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RelatorioMaxAggregateInputType
  }

  export type GetRelatorioAggregateType<T extends RelatorioAggregateArgs> = {
        [P in keyof T & keyof AggregateRelatorio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelatorio[P]>
      : GetScalarType<T[P], AggregateRelatorio[P]>
  }




  export type RelatorioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RelatorioWhereInput
    orderBy?: RelatorioOrderByWithAggregationInput | RelatorioOrderByWithAggregationInput[]
    by: RelatorioScalarFieldEnum[] | RelatorioScalarFieldEnum
    having?: RelatorioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RelatorioCountAggregateInputType | true
    _min?: RelatorioMinAggregateInputType
    _max?: RelatorioMaxAggregateInputType
  }

  export type RelatorioGroupByOutputType = {
    id: string
    admin_id: string
    proprietario_id: string
    createAt: Date
    updateAt: Date
    _count: RelatorioCountAggregateOutputType | null
    _min: RelatorioMinAggregateOutputType | null
    _max: RelatorioMaxAggregateOutputType | null
  }

  type GetRelatorioGroupByPayload<T extends RelatorioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RelatorioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RelatorioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RelatorioGroupByOutputType[P]>
            : GetScalarType<T[P], RelatorioGroupByOutputType[P]>
        }
      >
    >


  export type RelatorioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    proprietario_id?: boolean
    createAt?: boolean
    updateAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    proprietario?: boolean | ProprietarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["relatorio"]>

  export type RelatorioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admin_id?: boolean
    proprietario_id?: boolean
    createAt?: boolean
    updateAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    proprietario?: boolean | ProprietarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["relatorio"]>

  export type RelatorioSelectScalar = {
    id?: boolean
    admin_id?: boolean
    proprietario_id?: boolean
    createAt?: boolean
    updateAt?: boolean
  }

  export type RelatorioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    proprietario?: boolean | ProprietarioDefaultArgs<ExtArgs>
  }
  export type RelatorioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    proprietario?: boolean | ProprietarioDefaultArgs<ExtArgs>
  }

  export type $RelatorioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Relatorio"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
      proprietario: Prisma.$ProprietarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      admin_id: string
      proprietario_id: string
      createAt: Date
      updateAt: Date
    }, ExtArgs["result"]["relatorio"]>
    composites: {}
  }

  type RelatorioGetPayload<S extends boolean | null | undefined | RelatorioDefaultArgs> = $Result.GetResult<Prisma.$RelatorioPayload, S>

  type RelatorioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RelatorioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RelatorioCountAggregateInputType | true
    }

  export interface RelatorioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Relatorio'], meta: { name: 'Relatorio' } }
    /**
     * Find zero or one Relatorio that matches the filter.
     * @param {RelatorioFindUniqueArgs} args - Arguments to find a Relatorio
     * @example
     * // Get one Relatorio
     * const relatorio = await prisma.relatorio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RelatorioFindUniqueArgs>(args: SelectSubset<T, RelatorioFindUniqueArgs<ExtArgs>>): Prisma__RelatorioClient<$Result.GetResult<Prisma.$RelatorioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Relatorio that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RelatorioFindUniqueOrThrowArgs} args - Arguments to find a Relatorio
     * @example
     * // Get one Relatorio
     * const relatorio = await prisma.relatorio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RelatorioFindUniqueOrThrowArgs>(args: SelectSubset<T, RelatorioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RelatorioClient<$Result.GetResult<Prisma.$RelatorioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Relatorio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatorioFindFirstArgs} args - Arguments to find a Relatorio
     * @example
     * // Get one Relatorio
     * const relatorio = await prisma.relatorio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RelatorioFindFirstArgs>(args?: SelectSubset<T, RelatorioFindFirstArgs<ExtArgs>>): Prisma__RelatorioClient<$Result.GetResult<Prisma.$RelatorioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Relatorio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatorioFindFirstOrThrowArgs} args - Arguments to find a Relatorio
     * @example
     * // Get one Relatorio
     * const relatorio = await prisma.relatorio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RelatorioFindFirstOrThrowArgs>(args?: SelectSubset<T, RelatorioFindFirstOrThrowArgs<ExtArgs>>): Prisma__RelatorioClient<$Result.GetResult<Prisma.$RelatorioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Relatorios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatorioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Relatorios
     * const relatorios = await prisma.relatorio.findMany()
     * 
     * // Get first 10 Relatorios
     * const relatorios = await prisma.relatorio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const relatorioWithIdOnly = await prisma.relatorio.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RelatorioFindManyArgs>(args?: SelectSubset<T, RelatorioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelatorioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Relatorio.
     * @param {RelatorioCreateArgs} args - Arguments to create a Relatorio.
     * @example
     * // Create one Relatorio
     * const Relatorio = await prisma.relatorio.create({
     *   data: {
     *     // ... data to create a Relatorio
     *   }
     * })
     * 
     */
    create<T extends RelatorioCreateArgs>(args: SelectSubset<T, RelatorioCreateArgs<ExtArgs>>): Prisma__RelatorioClient<$Result.GetResult<Prisma.$RelatorioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Relatorios.
     * @param {RelatorioCreateManyArgs} args - Arguments to create many Relatorios.
     * @example
     * // Create many Relatorios
     * const relatorio = await prisma.relatorio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RelatorioCreateManyArgs>(args?: SelectSubset<T, RelatorioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Relatorios and returns the data saved in the database.
     * @param {RelatorioCreateManyAndReturnArgs} args - Arguments to create many Relatorios.
     * @example
     * // Create many Relatorios
     * const relatorio = await prisma.relatorio.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Relatorios and only return the `id`
     * const relatorioWithIdOnly = await prisma.relatorio.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RelatorioCreateManyAndReturnArgs>(args?: SelectSubset<T, RelatorioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RelatorioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Relatorio.
     * @param {RelatorioDeleteArgs} args - Arguments to delete one Relatorio.
     * @example
     * // Delete one Relatorio
     * const Relatorio = await prisma.relatorio.delete({
     *   where: {
     *     // ... filter to delete one Relatorio
     *   }
     * })
     * 
     */
    delete<T extends RelatorioDeleteArgs>(args: SelectSubset<T, RelatorioDeleteArgs<ExtArgs>>): Prisma__RelatorioClient<$Result.GetResult<Prisma.$RelatorioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Relatorio.
     * @param {RelatorioUpdateArgs} args - Arguments to update one Relatorio.
     * @example
     * // Update one Relatorio
     * const relatorio = await prisma.relatorio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RelatorioUpdateArgs>(args: SelectSubset<T, RelatorioUpdateArgs<ExtArgs>>): Prisma__RelatorioClient<$Result.GetResult<Prisma.$RelatorioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Relatorios.
     * @param {RelatorioDeleteManyArgs} args - Arguments to filter Relatorios to delete.
     * @example
     * // Delete a few Relatorios
     * const { count } = await prisma.relatorio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RelatorioDeleteManyArgs>(args?: SelectSubset<T, RelatorioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Relatorios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatorioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Relatorios
     * const relatorio = await prisma.relatorio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RelatorioUpdateManyArgs>(args: SelectSubset<T, RelatorioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Relatorio.
     * @param {RelatorioUpsertArgs} args - Arguments to update or create a Relatorio.
     * @example
     * // Update or create a Relatorio
     * const relatorio = await prisma.relatorio.upsert({
     *   create: {
     *     // ... data to create a Relatorio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Relatorio we want to update
     *   }
     * })
     */
    upsert<T extends RelatorioUpsertArgs>(args: SelectSubset<T, RelatorioUpsertArgs<ExtArgs>>): Prisma__RelatorioClient<$Result.GetResult<Prisma.$RelatorioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Relatorios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatorioCountArgs} args - Arguments to filter Relatorios to count.
     * @example
     * // Count the number of Relatorios
     * const count = await prisma.relatorio.count({
     *   where: {
     *     // ... the filter for the Relatorios we want to count
     *   }
     * })
    **/
    count<T extends RelatorioCountArgs>(
      args?: Subset<T, RelatorioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RelatorioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Relatorio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatorioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RelatorioAggregateArgs>(args: Subset<T, RelatorioAggregateArgs>): Prisma.PrismaPromise<GetRelatorioAggregateType<T>>

    /**
     * Group by Relatorio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RelatorioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RelatorioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RelatorioGroupByArgs['orderBy'] }
        : { orderBy?: RelatorioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RelatorioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRelatorioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Relatorio model
   */
  readonly fields: RelatorioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Relatorio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RelatorioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    proprietario<T extends ProprietarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProprietarioDefaultArgs<ExtArgs>>): Prisma__ProprietarioClient<$Result.GetResult<Prisma.$ProprietarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Relatorio model
   */ 
  interface RelatorioFieldRefs {
    readonly id: FieldRef<"Relatorio", 'String'>
    readonly admin_id: FieldRef<"Relatorio", 'String'>
    readonly proprietario_id: FieldRef<"Relatorio", 'String'>
    readonly createAt: FieldRef<"Relatorio", 'DateTime'>
    readonly updateAt: FieldRef<"Relatorio", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Relatorio findUnique
   */
  export type RelatorioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relatorio
     */
    select?: RelatorioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatorioInclude<ExtArgs> | null
    /**
     * Filter, which Relatorio to fetch.
     */
    where: RelatorioWhereUniqueInput
  }

  /**
   * Relatorio findUniqueOrThrow
   */
  export type RelatorioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relatorio
     */
    select?: RelatorioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatorioInclude<ExtArgs> | null
    /**
     * Filter, which Relatorio to fetch.
     */
    where: RelatorioWhereUniqueInput
  }

  /**
   * Relatorio findFirst
   */
  export type RelatorioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relatorio
     */
    select?: RelatorioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatorioInclude<ExtArgs> | null
    /**
     * Filter, which Relatorio to fetch.
     */
    where?: RelatorioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Relatorios to fetch.
     */
    orderBy?: RelatorioOrderByWithRelationInput | RelatorioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Relatorios.
     */
    cursor?: RelatorioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Relatorios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Relatorios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Relatorios.
     */
    distinct?: RelatorioScalarFieldEnum | RelatorioScalarFieldEnum[]
  }

  /**
   * Relatorio findFirstOrThrow
   */
  export type RelatorioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relatorio
     */
    select?: RelatorioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatorioInclude<ExtArgs> | null
    /**
     * Filter, which Relatorio to fetch.
     */
    where?: RelatorioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Relatorios to fetch.
     */
    orderBy?: RelatorioOrderByWithRelationInput | RelatorioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Relatorios.
     */
    cursor?: RelatorioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Relatorios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Relatorios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Relatorios.
     */
    distinct?: RelatorioScalarFieldEnum | RelatorioScalarFieldEnum[]
  }

  /**
   * Relatorio findMany
   */
  export type RelatorioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relatorio
     */
    select?: RelatorioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatorioInclude<ExtArgs> | null
    /**
     * Filter, which Relatorios to fetch.
     */
    where?: RelatorioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Relatorios to fetch.
     */
    orderBy?: RelatorioOrderByWithRelationInput | RelatorioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Relatorios.
     */
    cursor?: RelatorioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Relatorios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Relatorios.
     */
    skip?: number
    distinct?: RelatorioScalarFieldEnum | RelatorioScalarFieldEnum[]
  }

  /**
   * Relatorio create
   */
  export type RelatorioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relatorio
     */
    select?: RelatorioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatorioInclude<ExtArgs> | null
    /**
     * The data needed to create a Relatorio.
     */
    data: XOR<RelatorioCreateInput, RelatorioUncheckedCreateInput>
  }

  /**
   * Relatorio createMany
   */
  export type RelatorioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Relatorios.
     */
    data: RelatorioCreateManyInput | RelatorioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Relatorio createManyAndReturn
   */
  export type RelatorioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relatorio
     */
    select?: RelatorioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Relatorios.
     */
    data: RelatorioCreateManyInput | RelatorioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatorioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Relatorio update
   */
  export type RelatorioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relatorio
     */
    select?: RelatorioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatorioInclude<ExtArgs> | null
    /**
     * The data needed to update a Relatorio.
     */
    data: XOR<RelatorioUpdateInput, RelatorioUncheckedUpdateInput>
    /**
     * Choose, which Relatorio to update.
     */
    where: RelatorioWhereUniqueInput
  }

  /**
   * Relatorio updateMany
   */
  export type RelatorioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Relatorios.
     */
    data: XOR<RelatorioUpdateManyMutationInput, RelatorioUncheckedUpdateManyInput>
    /**
     * Filter which Relatorios to update
     */
    where?: RelatorioWhereInput
  }

  /**
   * Relatorio upsert
   */
  export type RelatorioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relatorio
     */
    select?: RelatorioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatorioInclude<ExtArgs> | null
    /**
     * The filter to search for the Relatorio to update in case it exists.
     */
    where: RelatorioWhereUniqueInput
    /**
     * In case the Relatorio found by the `where` argument doesn't exist, create a new Relatorio with this data.
     */
    create: XOR<RelatorioCreateInput, RelatorioUncheckedCreateInput>
    /**
     * In case the Relatorio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RelatorioUpdateInput, RelatorioUncheckedUpdateInput>
  }

  /**
   * Relatorio delete
   */
  export type RelatorioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relatorio
     */
    select?: RelatorioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatorioInclude<ExtArgs> | null
    /**
     * Filter which Relatorio to delete.
     */
    where: RelatorioWhereUniqueInput
  }

  /**
   * Relatorio deleteMany
   */
  export type RelatorioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Relatorios to delete
     */
    where?: RelatorioWhereInput
  }

  /**
   * Relatorio without action
   */
  export type RelatorioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Relatorio
     */
    select?: RelatorioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RelatorioInclude<ExtArgs> | null
  }


  /**
   * Model Reserva
   */

  export type AggregateReserva = {
    _count: ReservaCountAggregateOutputType | null
    _min: ReservaMinAggregateOutputType | null
    _max: ReservaMaxAggregateOutputType | null
  }

  export type ReservaMinAggregateOutputType = {
    id: string | null
    status: $Enums.Status_reserva | null
    cliente_id: string | null
    maquina_id: string | null
    inicio: Date | null
    fim: Date | null
    createAt: Date | null
    updateAt: Date | null
    pagamento_id: string | null
  }

  export type ReservaMaxAggregateOutputType = {
    id: string | null
    status: $Enums.Status_reserva | null
    cliente_id: string | null
    maquina_id: string | null
    inicio: Date | null
    fim: Date | null
    createAt: Date | null
    updateAt: Date | null
    pagamento_id: string | null
  }

  export type ReservaCountAggregateOutputType = {
    id: number
    status: number
    cliente_id: number
    maquina_id: number
    inicio: number
    fim: number
    createAt: number
    updateAt: number
    pagamento_id: number
    _all: number
  }


  export type ReservaMinAggregateInputType = {
    id?: true
    status?: true
    cliente_id?: true
    maquina_id?: true
    inicio?: true
    fim?: true
    createAt?: true
    updateAt?: true
    pagamento_id?: true
  }

  export type ReservaMaxAggregateInputType = {
    id?: true
    status?: true
    cliente_id?: true
    maquina_id?: true
    inicio?: true
    fim?: true
    createAt?: true
    updateAt?: true
    pagamento_id?: true
  }

  export type ReservaCountAggregateInputType = {
    id?: true
    status?: true
    cliente_id?: true
    maquina_id?: true
    inicio?: true
    fim?: true
    createAt?: true
    updateAt?: true
    pagamento_id?: true
    _all?: true
  }

  export type ReservaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reserva to aggregate.
     */
    where?: ReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservas to fetch.
     */
    orderBy?: ReservaOrderByWithRelationInput | ReservaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reservas
    **/
    _count?: true | ReservaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservaMaxAggregateInputType
  }

  export type GetReservaAggregateType<T extends ReservaAggregateArgs> = {
        [P in keyof T & keyof AggregateReserva]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReserva[P]>
      : GetScalarType<T[P], AggregateReserva[P]>
  }




  export type ReservaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservaWhereInput
    orderBy?: ReservaOrderByWithAggregationInput | ReservaOrderByWithAggregationInput[]
    by: ReservaScalarFieldEnum[] | ReservaScalarFieldEnum
    having?: ReservaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservaCountAggregateInputType | true
    _min?: ReservaMinAggregateInputType
    _max?: ReservaMaxAggregateInputType
  }

  export type ReservaGroupByOutputType = {
    id: string
    status: $Enums.Status_reserva
    cliente_id: string
    maquina_id: string
    inicio: Date
    fim: Date
    createAt: Date
    updateAt: Date
    pagamento_id: string | null
    _count: ReservaCountAggregateOutputType | null
    _min: ReservaMinAggregateOutputType | null
    _max: ReservaMaxAggregateOutputType | null
  }

  type GetReservaGroupByPayload<T extends ReservaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReservaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservaGroupByOutputType[P]>
            : GetScalarType<T[P], ReservaGroupByOutputType[P]>
        }
      >
    >


  export type ReservaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    cliente_id?: boolean
    maquina_id?: boolean
    inicio?: boolean
    fim?: boolean
    createAt?: boolean
    updateAt?: boolean
    pagamento_id?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    maquina?: boolean | MaquinaDefaultArgs<ExtArgs>
    pagamento?: boolean | Reserva$pagamentoArgs<ExtArgs>
  }, ExtArgs["result"]["reserva"]>

  export type ReservaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    cliente_id?: boolean
    maquina_id?: boolean
    inicio?: boolean
    fim?: boolean
    createAt?: boolean
    updateAt?: boolean
    pagamento_id?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    maquina?: boolean | MaquinaDefaultArgs<ExtArgs>
    pagamento?: boolean | Reserva$pagamentoArgs<ExtArgs>
  }, ExtArgs["result"]["reserva"]>

  export type ReservaSelectScalar = {
    id?: boolean
    status?: boolean
    cliente_id?: boolean
    maquina_id?: boolean
    inicio?: boolean
    fim?: boolean
    createAt?: boolean
    updateAt?: boolean
    pagamento_id?: boolean
  }

  export type ReservaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    maquina?: boolean | MaquinaDefaultArgs<ExtArgs>
    pagamento?: boolean | Reserva$pagamentoArgs<ExtArgs>
  }
  export type ReservaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    maquina?: boolean | MaquinaDefaultArgs<ExtArgs>
    pagamento?: boolean | Reserva$pagamentoArgs<ExtArgs>
  }

  export type $ReservaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reserva"
    objects: {
      cliente: Prisma.$ClientePayload<ExtArgs>
      maquina: Prisma.$MaquinaPayload<ExtArgs>
      pagamento: Prisma.$PagamentoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.Status_reserva
      cliente_id: string
      maquina_id: string
      inicio: Date
      fim: Date
      createAt: Date
      updateAt: Date
      pagamento_id: string | null
    }, ExtArgs["result"]["reserva"]>
    composites: {}
  }

  type ReservaGetPayload<S extends boolean | null | undefined | ReservaDefaultArgs> = $Result.GetResult<Prisma.$ReservaPayload, S>

  type ReservaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReservaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReservaCountAggregateInputType | true
    }

  export interface ReservaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reserva'], meta: { name: 'Reserva' } }
    /**
     * Find zero or one Reserva that matches the filter.
     * @param {ReservaFindUniqueArgs} args - Arguments to find a Reserva
     * @example
     * // Get one Reserva
     * const reserva = await prisma.reserva.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReservaFindUniqueArgs>(args: SelectSubset<T, ReservaFindUniqueArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Reserva that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReservaFindUniqueOrThrowArgs} args - Arguments to find a Reserva
     * @example
     * // Get one Reserva
     * const reserva = await prisma.reserva.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReservaFindUniqueOrThrowArgs>(args: SelectSubset<T, ReservaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Reserva that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaFindFirstArgs} args - Arguments to find a Reserva
     * @example
     * // Get one Reserva
     * const reserva = await prisma.reserva.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReservaFindFirstArgs>(args?: SelectSubset<T, ReservaFindFirstArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Reserva that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaFindFirstOrThrowArgs} args - Arguments to find a Reserva
     * @example
     * // Get one Reserva
     * const reserva = await prisma.reserva.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReservaFindFirstOrThrowArgs>(args?: SelectSubset<T, ReservaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reservas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservas
     * const reservas = await prisma.reserva.findMany()
     * 
     * // Get first 10 Reservas
     * const reservas = await prisma.reserva.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reservaWithIdOnly = await prisma.reserva.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReservaFindManyArgs>(args?: SelectSubset<T, ReservaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Reserva.
     * @param {ReservaCreateArgs} args - Arguments to create a Reserva.
     * @example
     * // Create one Reserva
     * const Reserva = await prisma.reserva.create({
     *   data: {
     *     // ... data to create a Reserva
     *   }
     * })
     * 
     */
    create<T extends ReservaCreateArgs>(args: SelectSubset<T, ReservaCreateArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reservas.
     * @param {ReservaCreateManyArgs} args - Arguments to create many Reservas.
     * @example
     * // Create many Reservas
     * const reserva = await prisma.reserva.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReservaCreateManyArgs>(args?: SelectSubset<T, ReservaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reservas and returns the data saved in the database.
     * @param {ReservaCreateManyAndReturnArgs} args - Arguments to create many Reservas.
     * @example
     * // Create many Reservas
     * const reserva = await prisma.reserva.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reservas and only return the `id`
     * const reservaWithIdOnly = await prisma.reserva.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReservaCreateManyAndReturnArgs>(args?: SelectSubset<T, ReservaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Reserva.
     * @param {ReservaDeleteArgs} args - Arguments to delete one Reserva.
     * @example
     * // Delete one Reserva
     * const Reserva = await prisma.reserva.delete({
     *   where: {
     *     // ... filter to delete one Reserva
     *   }
     * })
     * 
     */
    delete<T extends ReservaDeleteArgs>(args: SelectSubset<T, ReservaDeleteArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Reserva.
     * @param {ReservaUpdateArgs} args - Arguments to update one Reserva.
     * @example
     * // Update one Reserva
     * const reserva = await prisma.reserva.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReservaUpdateArgs>(args: SelectSubset<T, ReservaUpdateArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reservas.
     * @param {ReservaDeleteManyArgs} args - Arguments to filter Reservas to delete.
     * @example
     * // Delete a few Reservas
     * const { count } = await prisma.reserva.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReservaDeleteManyArgs>(args?: SelectSubset<T, ReservaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservas
     * const reserva = await prisma.reserva.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReservaUpdateManyArgs>(args: SelectSubset<T, ReservaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reserva.
     * @param {ReservaUpsertArgs} args - Arguments to update or create a Reserva.
     * @example
     * // Update or create a Reserva
     * const reserva = await prisma.reserva.upsert({
     *   create: {
     *     // ... data to create a Reserva
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reserva we want to update
     *   }
     * })
     */
    upsert<T extends ReservaUpsertArgs>(args: SelectSubset<T, ReservaUpsertArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reservas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaCountArgs} args - Arguments to filter Reservas to count.
     * @example
     * // Count the number of Reservas
     * const count = await prisma.reserva.count({
     *   where: {
     *     // ... the filter for the Reservas we want to count
     *   }
     * })
    **/
    count<T extends ReservaCountArgs>(
      args?: Subset<T, ReservaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reserva.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservaAggregateArgs>(args: Subset<T, ReservaAggregateArgs>): Prisma.PrismaPromise<GetReservaAggregateType<T>>

    /**
     * Group by Reserva.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReservaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservaGroupByArgs['orderBy'] }
        : { orderBy?: ReservaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReservaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reserva model
   */
  readonly fields: ReservaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reserva.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReservaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cliente<T extends ClienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClienteDefaultArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    maquina<T extends MaquinaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaquinaDefaultArgs<ExtArgs>>): Prisma__MaquinaClient<$Result.GetResult<Prisma.$MaquinaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pagamento<T extends Reserva$pagamentoArgs<ExtArgs> = {}>(args?: Subset<T, Reserva$pagamentoArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reserva model
   */ 
  interface ReservaFieldRefs {
    readonly id: FieldRef<"Reserva", 'String'>
    readonly status: FieldRef<"Reserva", 'Status_reserva'>
    readonly cliente_id: FieldRef<"Reserva", 'String'>
    readonly maquina_id: FieldRef<"Reserva", 'String'>
    readonly inicio: FieldRef<"Reserva", 'DateTime'>
    readonly fim: FieldRef<"Reserva", 'DateTime'>
    readonly createAt: FieldRef<"Reserva", 'DateTime'>
    readonly updateAt: FieldRef<"Reserva", 'DateTime'>
    readonly pagamento_id: FieldRef<"Reserva", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Reserva findUnique
   */
  export type ReservaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * Filter, which Reserva to fetch.
     */
    where: ReservaWhereUniqueInput
  }

  /**
   * Reserva findUniqueOrThrow
   */
  export type ReservaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * Filter, which Reserva to fetch.
     */
    where: ReservaWhereUniqueInput
  }

  /**
   * Reserva findFirst
   */
  export type ReservaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * Filter, which Reserva to fetch.
     */
    where?: ReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservas to fetch.
     */
    orderBy?: ReservaOrderByWithRelationInput | ReservaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservas.
     */
    cursor?: ReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservas.
     */
    distinct?: ReservaScalarFieldEnum | ReservaScalarFieldEnum[]
  }

  /**
   * Reserva findFirstOrThrow
   */
  export type ReservaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * Filter, which Reserva to fetch.
     */
    where?: ReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservas to fetch.
     */
    orderBy?: ReservaOrderByWithRelationInput | ReservaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservas.
     */
    cursor?: ReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservas.
     */
    distinct?: ReservaScalarFieldEnum | ReservaScalarFieldEnum[]
  }

  /**
   * Reserva findMany
   */
  export type ReservaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * Filter, which Reservas to fetch.
     */
    where?: ReservaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservas to fetch.
     */
    orderBy?: ReservaOrderByWithRelationInput | ReservaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reservas.
     */
    cursor?: ReservaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservas.
     */
    skip?: number
    distinct?: ReservaScalarFieldEnum | ReservaScalarFieldEnum[]
  }

  /**
   * Reserva create
   */
  export type ReservaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * The data needed to create a Reserva.
     */
    data: XOR<ReservaCreateInput, ReservaUncheckedCreateInput>
  }

  /**
   * Reserva createMany
   */
  export type ReservaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reservas.
     */
    data: ReservaCreateManyInput | ReservaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reserva createManyAndReturn
   */
  export type ReservaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reservas.
     */
    data: ReservaCreateManyInput | ReservaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reserva update
   */
  export type ReservaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * The data needed to update a Reserva.
     */
    data: XOR<ReservaUpdateInput, ReservaUncheckedUpdateInput>
    /**
     * Choose, which Reserva to update.
     */
    where: ReservaWhereUniqueInput
  }

  /**
   * Reserva updateMany
   */
  export type ReservaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reservas.
     */
    data: XOR<ReservaUpdateManyMutationInput, ReservaUncheckedUpdateManyInput>
    /**
     * Filter which Reservas to update
     */
    where?: ReservaWhereInput
  }

  /**
   * Reserva upsert
   */
  export type ReservaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * The filter to search for the Reserva to update in case it exists.
     */
    where: ReservaWhereUniqueInput
    /**
     * In case the Reserva found by the `where` argument doesn't exist, create a new Reserva with this data.
     */
    create: XOR<ReservaCreateInput, ReservaUncheckedCreateInput>
    /**
     * In case the Reserva was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReservaUpdateInput, ReservaUncheckedUpdateInput>
  }

  /**
   * Reserva delete
   */
  export type ReservaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    /**
     * Filter which Reserva to delete.
     */
    where: ReservaWhereUniqueInput
  }

  /**
   * Reserva deleteMany
   */
  export type ReservaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservas to delete
     */
    where?: ReservaWhereInput
  }

  /**
   * Reserva.pagamento
   */
  export type Reserva$pagamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    where?: PagamentoWhereInput
  }

  /**
   * Reserva without action
   */
  export type ReservaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
  }


  /**
   * Model Avaliacao
   */

  export type AggregateAvaliacao = {
    _count: AvaliacaoCountAggregateOutputType | null
    _avg: AvaliacaoAvgAggregateOutputType | null
    _sum: AvaliacaoSumAggregateOutputType | null
    _min: AvaliacaoMinAggregateOutputType | null
    _max: AvaliacaoMaxAggregateOutputType | null
  }

  export type AvaliacaoAvgAggregateOutputType = {
    nota: number | null
  }

  export type AvaliacaoSumAggregateOutputType = {
    nota: number | null
  }

  export type AvaliacaoMinAggregateOutputType = {
    id: string | null
    nota: number | null
    comentario: string | null
    cliente_id: string | null
    lavanderia_id: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type AvaliacaoMaxAggregateOutputType = {
    id: string | null
    nota: number | null
    comentario: string | null
    cliente_id: string | null
    lavanderia_id: string | null
    createAt: Date | null
    updateAt: Date | null
  }

  export type AvaliacaoCountAggregateOutputType = {
    id: number
    nota: number
    comentario: number
    cliente_id: number
    lavanderia_id: number
    createAt: number
    updateAt: number
    _all: number
  }


  export type AvaliacaoAvgAggregateInputType = {
    nota?: true
  }

  export type AvaliacaoSumAggregateInputType = {
    nota?: true
  }

  export type AvaliacaoMinAggregateInputType = {
    id?: true
    nota?: true
    comentario?: true
    cliente_id?: true
    lavanderia_id?: true
    createAt?: true
    updateAt?: true
  }

  export type AvaliacaoMaxAggregateInputType = {
    id?: true
    nota?: true
    comentario?: true
    cliente_id?: true
    lavanderia_id?: true
    createAt?: true
    updateAt?: true
  }

  export type AvaliacaoCountAggregateInputType = {
    id?: true
    nota?: true
    comentario?: true
    cliente_id?: true
    lavanderia_id?: true
    createAt?: true
    updateAt?: true
    _all?: true
  }

  export type AvaliacaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Avaliacao to aggregate.
     */
    where?: AvaliacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avaliacaos to fetch.
     */
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AvaliacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avaliacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avaliacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Avaliacaos
    **/
    _count?: true | AvaliacaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AvaliacaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AvaliacaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvaliacaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvaliacaoMaxAggregateInputType
  }

  export type GetAvaliacaoAggregateType<T extends AvaliacaoAggregateArgs> = {
        [P in keyof T & keyof AggregateAvaliacao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvaliacao[P]>
      : GetScalarType<T[P], AggregateAvaliacao[P]>
  }




  export type AvaliacaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvaliacaoWhereInput
    orderBy?: AvaliacaoOrderByWithAggregationInput | AvaliacaoOrderByWithAggregationInput[]
    by: AvaliacaoScalarFieldEnum[] | AvaliacaoScalarFieldEnum
    having?: AvaliacaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvaliacaoCountAggregateInputType | true
    _avg?: AvaliacaoAvgAggregateInputType
    _sum?: AvaliacaoSumAggregateInputType
    _min?: AvaliacaoMinAggregateInputType
    _max?: AvaliacaoMaxAggregateInputType
  }

  export type AvaliacaoGroupByOutputType = {
    id: string
    nota: number
    comentario: string
    cliente_id: string
    lavanderia_id: string
    createAt: Date
    updateAt: Date
    _count: AvaliacaoCountAggregateOutputType | null
    _avg: AvaliacaoAvgAggregateOutputType | null
    _sum: AvaliacaoSumAggregateOutputType | null
    _min: AvaliacaoMinAggregateOutputType | null
    _max: AvaliacaoMaxAggregateOutputType | null
  }

  type GetAvaliacaoGroupByPayload<T extends AvaliacaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvaliacaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvaliacaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvaliacaoGroupByOutputType[P]>
            : GetScalarType<T[P], AvaliacaoGroupByOutputType[P]>
        }
      >
    >


  export type AvaliacaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nota?: boolean
    comentario?: boolean
    cliente_id?: boolean
    lavanderia_id?: boolean
    createAt?: boolean
    updateAt?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    lavanderia?: boolean | LavanderiaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["avaliacao"]>

  export type AvaliacaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nota?: boolean
    comentario?: boolean
    cliente_id?: boolean
    lavanderia_id?: boolean
    createAt?: boolean
    updateAt?: boolean
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    lavanderia?: boolean | LavanderiaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["avaliacao"]>

  export type AvaliacaoSelectScalar = {
    id?: boolean
    nota?: boolean
    comentario?: boolean
    cliente_id?: boolean
    lavanderia_id?: boolean
    createAt?: boolean
    updateAt?: boolean
  }

  export type AvaliacaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    lavanderia?: boolean | LavanderiaDefaultArgs<ExtArgs>
  }
  export type AvaliacaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClienteDefaultArgs<ExtArgs>
    lavanderia?: boolean | LavanderiaDefaultArgs<ExtArgs>
  }

  export type $AvaliacaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Avaliacao"
    objects: {
      cliente: Prisma.$ClientePayload<ExtArgs>
      lavanderia: Prisma.$LavanderiaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nota: number
      comentario: string
      cliente_id: string
      lavanderia_id: string
      createAt: Date
      updateAt: Date
    }, ExtArgs["result"]["avaliacao"]>
    composites: {}
  }

  type AvaliacaoGetPayload<S extends boolean | null | undefined | AvaliacaoDefaultArgs> = $Result.GetResult<Prisma.$AvaliacaoPayload, S>

  type AvaliacaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AvaliacaoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AvaliacaoCountAggregateInputType | true
    }

  export interface AvaliacaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Avaliacao'], meta: { name: 'Avaliacao' } }
    /**
     * Find zero or one Avaliacao that matches the filter.
     * @param {AvaliacaoFindUniqueArgs} args - Arguments to find a Avaliacao
     * @example
     * // Get one Avaliacao
     * const avaliacao = await prisma.avaliacao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AvaliacaoFindUniqueArgs>(args: SelectSubset<T, AvaliacaoFindUniqueArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Avaliacao that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AvaliacaoFindUniqueOrThrowArgs} args - Arguments to find a Avaliacao
     * @example
     * // Get one Avaliacao
     * const avaliacao = await prisma.avaliacao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AvaliacaoFindUniqueOrThrowArgs>(args: SelectSubset<T, AvaliacaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Avaliacao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoFindFirstArgs} args - Arguments to find a Avaliacao
     * @example
     * // Get one Avaliacao
     * const avaliacao = await prisma.avaliacao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AvaliacaoFindFirstArgs>(args?: SelectSubset<T, AvaliacaoFindFirstArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Avaliacao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoFindFirstOrThrowArgs} args - Arguments to find a Avaliacao
     * @example
     * // Get one Avaliacao
     * const avaliacao = await prisma.avaliacao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AvaliacaoFindFirstOrThrowArgs>(args?: SelectSubset<T, AvaliacaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Avaliacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Avaliacaos
     * const avaliacaos = await prisma.avaliacao.findMany()
     * 
     * // Get first 10 Avaliacaos
     * const avaliacaos = await prisma.avaliacao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const avaliacaoWithIdOnly = await prisma.avaliacao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AvaliacaoFindManyArgs>(args?: SelectSubset<T, AvaliacaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Avaliacao.
     * @param {AvaliacaoCreateArgs} args - Arguments to create a Avaliacao.
     * @example
     * // Create one Avaliacao
     * const Avaliacao = await prisma.avaliacao.create({
     *   data: {
     *     // ... data to create a Avaliacao
     *   }
     * })
     * 
     */
    create<T extends AvaliacaoCreateArgs>(args: SelectSubset<T, AvaliacaoCreateArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Avaliacaos.
     * @param {AvaliacaoCreateManyArgs} args - Arguments to create many Avaliacaos.
     * @example
     * // Create many Avaliacaos
     * const avaliacao = await prisma.avaliacao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AvaliacaoCreateManyArgs>(args?: SelectSubset<T, AvaliacaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Avaliacaos and returns the data saved in the database.
     * @param {AvaliacaoCreateManyAndReturnArgs} args - Arguments to create many Avaliacaos.
     * @example
     * // Create many Avaliacaos
     * const avaliacao = await prisma.avaliacao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Avaliacaos and only return the `id`
     * const avaliacaoWithIdOnly = await prisma.avaliacao.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AvaliacaoCreateManyAndReturnArgs>(args?: SelectSubset<T, AvaliacaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Avaliacao.
     * @param {AvaliacaoDeleteArgs} args - Arguments to delete one Avaliacao.
     * @example
     * // Delete one Avaliacao
     * const Avaliacao = await prisma.avaliacao.delete({
     *   where: {
     *     // ... filter to delete one Avaliacao
     *   }
     * })
     * 
     */
    delete<T extends AvaliacaoDeleteArgs>(args: SelectSubset<T, AvaliacaoDeleteArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Avaliacao.
     * @param {AvaliacaoUpdateArgs} args - Arguments to update one Avaliacao.
     * @example
     * // Update one Avaliacao
     * const avaliacao = await prisma.avaliacao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AvaliacaoUpdateArgs>(args: SelectSubset<T, AvaliacaoUpdateArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Avaliacaos.
     * @param {AvaliacaoDeleteManyArgs} args - Arguments to filter Avaliacaos to delete.
     * @example
     * // Delete a few Avaliacaos
     * const { count } = await prisma.avaliacao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AvaliacaoDeleteManyArgs>(args?: SelectSubset<T, AvaliacaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Avaliacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Avaliacaos
     * const avaliacao = await prisma.avaliacao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AvaliacaoUpdateManyArgs>(args: SelectSubset<T, AvaliacaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Avaliacao.
     * @param {AvaliacaoUpsertArgs} args - Arguments to update or create a Avaliacao.
     * @example
     * // Update or create a Avaliacao
     * const avaliacao = await prisma.avaliacao.upsert({
     *   create: {
     *     // ... data to create a Avaliacao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Avaliacao we want to update
     *   }
     * })
     */
    upsert<T extends AvaliacaoUpsertArgs>(args: SelectSubset<T, AvaliacaoUpsertArgs<ExtArgs>>): Prisma__AvaliacaoClient<$Result.GetResult<Prisma.$AvaliacaoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Avaliacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoCountArgs} args - Arguments to filter Avaliacaos to count.
     * @example
     * // Count the number of Avaliacaos
     * const count = await prisma.avaliacao.count({
     *   where: {
     *     // ... the filter for the Avaliacaos we want to count
     *   }
     * })
    **/
    count<T extends AvaliacaoCountArgs>(
      args?: Subset<T, AvaliacaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvaliacaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Avaliacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvaliacaoAggregateArgs>(args: Subset<T, AvaliacaoAggregateArgs>): Prisma.PrismaPromise<GetAvaliacaoAggregateType<T>>

    /**
     * Group by Avaliacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvaliacaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AvaliacaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AvaliacaoGroupByArgs['orderBy'] }
        : { orderBy?: AvaliacaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AvaliacaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvaliacaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Avaliacao model
   */
  readonly fields: AvaliacaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Avaliacao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AvaliacaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cliente<T extends ClienteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClienteDefaultArgs<ExtArgs>>): Prisma__ClienteClient<$Result.GetResult<Prisma.$ClientePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lavanderia<T extends LavanderiaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LavanderiaDefaultArgs<ExtArgs>>): Prisma__LavanderiaClient<$Result.GetResult<Prisma.$LavanderiaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Avaliacao model
   */ 
  interface AvaliacaoFieldRefs {
    readonly id: FieldRef<"Avaliacao", 'String'>
    readonly nota: FieldRef<"Avaliacao", 'Int'>
    readonly comentario: FieldRef<"Avaliacao", 'String'>
    readonly cliente_id: FieldRef<"Avaliacao", 'String'>
    readonly lavanderia_id: FieldRef<"Avaliacao", 'String'>
    readonly createAt: FieldRef<"Avaliacao", 'DateTime'>
    readonly updateAt: FieldRef<"Avaliacao", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Avaliacao findUnique
   */
  export type AvaliacaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * Filter, which Avaliacao to fetch.
     */
    where: AvaliacaoWhereUniqueInput
  }

  /**
   * Avaliacao findUniqueOrThrow
   */
  export type AvaliacaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * Filter, which Avaliacao to fetch.
     */
    where: AvaliacaoWhereUniqueInput
  }

  /**
   * Avaliacao findFirst
   */
  export type AvaliacaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * Filter, which Avaliacao to fetch.
     */
    where?: AvaliacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avaliacaos to fetch.
     */
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Avaliacaos.
     */
    cursor?: AvaliacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avaliacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avaliacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Avaliacaos.
     */
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[]
  }

  /**
   * Avaliacao findFirstOrThrow
   */
  export type AvaliacaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * Filter, which Avaliacao to fetch.
     */
    where?: AvaliacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avaliacaos to fetch.
     */
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Avaliacaos.
     */
    cursor?: AvaliacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avaliacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avaliacaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Avaliacaos.
     */
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[]
  }

  /**
   * Avaliacao findMany
   */
  export type AvaliacaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * Filter, which Avaliacaos to fetch.
     */
    where?: AvaliacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Avaliacaos to fetch.
     */
    orderBy?: AvaliacaoOrderByWithRelationInput | AvaliacaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Avaliacaos.
     */
    cursor?: AvaliacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Avaliacaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Avaliacaos.
     */
    skip?: number
    distinct?: AvaliacaoScalarFieldEnum | AvaliacaoScalarFieldEnum[]
  }

  /**
   * Avaliacao create
   */
  export type AvaliacaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * The data needed to create a Avaliacao.
     */
    data: XOR<AvaliacaoCreateInput, AvaliacaoUncheckedCreateInput>
  }

  /**
   * Avaliacao createMany
   */
  export type AvaliacaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Avaliacaos.
     */
    data: AvaliacaoCreateManyInput | AvaliacaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Avaliacao createManyAndReturn
   */
  export type AvaliacaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Avaliacaos.
     */
    data: AvaliacaoCreateManyInput | AvaliacaoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Avaliacao update
   */
  export type AvaliacaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * The data needed to update a Avaliacao.
     */
    data: XOR<AvaliacaoUpdateInput, AvaliacaoUncheckedUpdateInput>
    /**
     * Choose, which Avaliacao to update.
     */
    where: AvaliacaoWhereUniqueInput
  }

  /**
   * Avaliacao updateMany
   */
  export type AvaliacaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Avaliacaos.
     */
    data: XOR<AvaliacaoUpdateManyMutationInput, AvaliacaoUncheckedUpdateManyInput>
    /**
     * Filter which Avaliacaos to update
     */
    where?: AvaliacaoWhereInput
  }

  /**
   * Avaliacao upsert
   */
  export type AvaliacaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * The filter to search for the Avaliacao to update in case it exists.
     */
    where: AvaliacaoWhereUniqueInput
    /**
     * In case the Avaliacao found by the `where` argument doesn't exist, create a new Avaliacao with this data.
     */
    create: XOR<AvaliacaoCreateInput, AvaliacaoUncheckedCreateInput>
    /**
     * In case the Avaliacao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AvaliacaoUpdateInput, AvaliacaoUncheckedUpdateInput>
  }

  /**
   * Avaliacao delete
   */
  export type AvaliacaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
    /**
     * Filter which Avaliacao to delete.
     */
    where: AvaliacaoWhereUniqueInput
  }

  /**
   * Avaliacao deleteMany
   */
  export type AvaliacaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Avaliacaos to delete
     */
    where?: AvaliacaoWhereInput
  }

  /**
   * Avaliacao without action
   */
  export type AvaliacaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Avaliacao
     */
    select?: AvaliacaoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvaliacaoInclude<ExtArgs> | null
  }


  /**
   * Model Pagamento
   */

  export type AggregatePagamento = {
    _count: PagamentoCountAggregateOutputType | null
    _avg: PagamentoAvgAggregateOutputType | null
    _sum: PagamentoSumAggregateOutputType | null
    _min: PagamentoMinAggregateOutputType | null
    _max: PagamentoMaxAggregateOutputType | null
  }

  export type PagamentoAvgAggregateOutputType = {
    valor: Decimal | null
  }

  export type PagamentoSumAggregateOutputType = {
    valor: Decimal | null
  }

  export type PagamentoMinAggregateOutputType = {
    id: string | null
    valor: Decimal | null
    metodo: $Enums.Metodo_Pagamento | null
    status: $Enums.Status_Pagamento | null
    createAt: Date | null
  }

  export type PagamentoMaxAggregateOutputType = {
    id: string | null
    valor: Decimal | null
    metodo: $Enums.Metodo_Pagamento | null
    status: $Enums.Status_Pagamento | null
    createAt: Date | null
  }

  export type PagamentoCountAggregateOutputType = {
    id: number
    valor: number
    metodo: number
    status: number
    createAt: number
    _all: number
  }


  export type PagamentoAvgAggregateInputType = {
    valor?: true
  }

  export type PagamentoSumAggregateInputType = {
    valor?: true
  }

  export type PagamentoMinAggregateInputType = {
    id?: true
    valor?: true
    metodo?: true
    status?: true
    createAt?: true
  }

  export type PagamentoMaxAggregateInputType = {
    id?: true
    valor?: true
    metodo?: true
    status?: true
    createAt?: true
  }

  export type PagamentoCountAggregateInputType = {
    id?: true
    valor?: true
    metodo?: true
    status?: true
    createAt?: true
    _all?: true
  }

  export type PagamentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pagamento to aggregate.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pagamentos
    **/
    _count?: true | PagamentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PagamentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PagamentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PagamentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PagamentoMaxAggregateInputType
  }

  export type GetPagamentoAggregateType<T extends PagamentoAggregateArgs> = {
        [P in keyof T & keyof AggregatePagamento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePagamento[P]>
      : GetScalarType<T[P], AggregatePagamento[P]>
  }




  export type PagamentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagamentoWhereInput
    orderBy?: PagamentoOrderByWithAggregationInput | PagamentoOrderByWithAggregationInput[]
    by: PagamentoScalarFieldEnum[] | PagamentoScalarFieldEnum
    having?: PagamentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PagamentoCountAggregateInputType | true
    _avg?: PagamentoAvgAggregateInputType
    _sum?: PagamentoSumAggregateInputType
    _min?: PagamentoMinAggregateInputType
    _max?: PagamentoMaxAggregateInputType
  }

  export type PagamentoGroupByOutputType = {
    id: string
    valor: Decimal
    metodo: $Enums.Metodo_Pagamento
    status: $Enums.Status_Pagamento
    createAt: Date
    _count: PagamentoCountAggregateOutputType | null
    _avg: PagamentoAvgAggregateOutputType | null
    _sum: PagamentoSumAggregateOutputType | null
    _min: PagamentoMinAggregateOutputType | null
    _max: PagamentoMaxAggregateOutputType | null
  }

  type GetPagamentoGroupByPayload<T extends PagamentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PagamentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PagamentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PagamentoGroupByOutputType[P]>
            : GetScalarType<T[P], PagamentoGroupByOutputType[P]>
        }
      >
    >


  export type PagamentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valor?: boolean
    metodo?: boolean
    status?: boolean
    createAt?: boolean
    reserva?: boolean | Pagamento$reservaArgs<ExtArgs>
  }, ExtArgs["result"]["pagamento"]>

  export type PagamentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    valor?: boolean
    metodo?: boolean
    status?: boolean
    createAt?: boolean
  }, ExtArgs["result"]["pagamento"]>

  export type PagamentoSelectScalar = {
    id?: boolean
    valor?: boolean
    metodo?: boolean
    status?: boolean
    createAt?: boolean
  }

  export type PagamentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reserva?: boolean | Pagamento$reservaArgs<ExtArgs>
  }
  export type PagamentoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PagamentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pagamento"
    objects: {
      reserva: Prisma.$ReservaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      valor: Prisma.Decimal
      metodo: $Enums.Metodo_Pagamento
      status: $Enums.Status_Pagamento
      createAt: Date
    }, ExtArgs["result"]["pagamento"]>
    composites: {}
  }

  type PagamentoGetPayload<S extends boolean | null | undefined | PagamentoDefaultArgs> = $Result.GetResult<Prisma.$PagamentoPayload, S>

  type PagamentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PagamentoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PagamentoCountAggregateInputType | true
    }

  export interface PagamentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pagamento'], meta: { name: 'Pagamento' } }
    /**
     * Find zero or one Pagamento that matches the filter.
     * @param {PagamentoFindUniqueArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PagamentoFindUniqueArgs>(args: SelectSubset<T, PagamentoFindUniqueArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pagamento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PagamentoFindUniqueOrThrowArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PagamentoFindUniqueOrThrowArgs>(args: SelectSubset<T, PagamentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pagamento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoFindFirstArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PagamentoFindFirstArgs>(args?: SelectSubset<T, PagamentoFindFirstArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pagamento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoFindFirstOrThrowArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PagamentoFindFirstOrThrowArgs>(args?: SelectSubset<T, PagamentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pagamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pagamentos
     * const pagamentos = await prisma.pagamento.findMany()
     * 
     * // Get first 10 Pagamentos
     * const pagamentos = await prisma.pagamento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pagamentoWithIdOnly = await prisma.pagamento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PagamentoFindManyArgs>(args?: SelectSubset<T, PagamentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pagamento.
     * @param {PagamentoCreateArgs} args - Arguments to create a Pagamento.
     * @example
     * // Create one Pagamento
     * const Pagamento = await prisma.pagamento.create({
     *   data: {
     *     // ... data to create a Pagamento
     *   }
     * })
     * 
     */
    create<T extends PagamentoCreateArgs>(args: SelectSubset<T, PagamentoCreateArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pagamentos.
     * @param {PagamentoCreateManyArgs} args - Arguments to create many Pagamentos.
     * @example
     * // Create many Pagamentos
     * const pagamento = await prisma.pagamento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PagamentoCreateManyArgs>(args?: SelectSubset<T, PagamentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pagamentos and returns the data saved in the database.
     * @param {PagamentoCreateManyAndReturnArgs} args - Arguments to create many Pagamentos.
     * @example
     * // Create many Pagamentos
     * const pagamento = await prisma.pagamento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pagamentos and only return the `id`
     * const pagamentoWithIdOnly = await prisma.pagamento.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PagamentoCreateManyAndReturnArgs>(args?: SelectSubset<T, PagamentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pagamento.
     * @param {PagamentoDeleteArgs} args - Arguments to delete one Pagamento.
     * @example
     * // Delete one Pagamento
     * const Pagamento = await prisma.pagamento.delete({
     *   where: {
     *     // ... filter to delete one Pagamento
     *   }
     * })
     * 
     */
    delete<T extends PagamentoDeleteArgs>(args: SelectSubset<T, PagamentoDeleteArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pagamento.
     * @param {PagamentoUpdateArgs} args - Arguments to update one Pagamento.
     * @example
     * // Update one Pagamento
     * const pagamento = await prisma.pagamento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PagamentoUpdateArgs>(args: SelectSubset<T, PagamentoUpdateArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pagamentos.
     * @param {PagamentoDeleteManyArgs} args - Arguments to filter Pagamentos to delete.
     * @example
     * // Delete a few Pagamentos
     * const { count } = await prisma.pagamento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PagamentoDeleteManyArgs>(args?: SelectSubset<T, PagamentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pagamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pagamentos
     * const pagamento = await prisma.pagamento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PagamentoUpdateManyArgs>(args: SelectSubset<T, PagamentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pagamento.
     * @param {PagamentoUpsertArgs} args - Arguments to update or create a Pagamento.
     * @example
     * // Update or create a Pagamento
     * const pagamento = await prisma.pagamento.upsert({
     *   create: {
     *     // ... data to create a Pagamento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pagamento we want to update
     *   }
     * })
     */
    upsert<T extends PagamentoUpsertArgs>(args: SelectSubset<T, PagamentoUpsertArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pagamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoCountArgs} args - Arguments to filter Pagamentos to count.
     * @example
     * // Count the number of Pagamentos
     * const count = await prisma.pagamento.count({
     *   where: {
     *     // ... the filter for the Pagamentos we want to count
     *   }
     * })
    **/
    count<T extends PagamentoCountArgs>(
      args?: Subset<T, PagamentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PagamentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pagamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PagamentoAggregateArgs>(args: Subset<T, PagamentoAggregateArgs>): Prisma.PrismaPromise<GetPagamentoAggregateType<T>>

    /**
     * Group by Pagamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PagamentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PagamentoGroupByArgs['orderBy'] }
        : { orderBy?: PagamentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PagamentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPagamentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pagamento model
   */
  readonly fields: PagamentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pagamento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PagamentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reserva<T extends Pagamento$reservaArgs<ExtArgs> = {}>(args?: Subset<T, Pagamento$reservaArgs<ExtArgs>>): Prisma__ReservaClient<$Result.GetResult<Prisma.$ReservaPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pagamento model
   */ 
  interface PagamentoFieldRefs {
    readonly id: FieldRef<"Pagamento", 'String'>
    readonly valor: FieldRef<"Pagamento", 'Decimal'>
    readonly metodo: FieldRef<"Pagamento", 'Metodo_Pagamento'>
    readonly status: FieldRef<"Pagamento", 'Status_Pagamento'>
    readonly createAt: FieldRef<"Pagamento", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pagamento findUnique
   */
  export type PagamentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where: PagamentoWhereUniqueInput
  }

  /**
   * Pagamento findUniqueOrThrow
   */
  export type PagamentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where: PagamentoWhereUniqueInput
  }

  /**
   * Pagamento findFirst
   */
  export type PagamentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pagamentos.
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pagamentos.
     */
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }

  /**
   * Pagamento findFirstOrThrow
   */
  export type PagamentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pagamentos.
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pagamentos.
     */
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }

  /**
   * Pagamento findMany
   */
  export type PagamentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamentos to fetch.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pagamentos.
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }

  /**
   * Pagamento create
   */
  export type PagamentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * The data needed to create a Pagamento.
     */
    data: XOR<PagamentoCreateInput, PagamentoUncheckedCreateInput>
  }

  /**
   * Pagamento createMany
   */
  export type PagamentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pagamentos.
     */
    data: PagamentoCreateManyInput | PagamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pagamento createManyAndReturn
   */
  export type PagamentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Pagamentos.
     */
    data: PagamentoCreateManyInput | PagamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pagamento update
   */
  export type PagamentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * The data needed to update a Pagamento.
     */
    data: XOR<PagamentoUpdateInput, PagamentoUncheckedUpdateInput>
    /**
     * Choose, which Pagamento to update.
     */
    where: PagamentoWhereUniqueInput
  }

  /**
   * Pagamento updateMany
   */
  export type PagamentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pagamentos.
     */
    data: XOR<PagamentoUpdateManyMutationInput, PagamentoUncheckedUpdateManyInput>
    /**
     * Filter which Pagamentos to update
     */
    where?: PagamentoWhereInput
  }

  /**
   * Pagamento upsert
   */
  export type PagamentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * The filter to search for the Pagamento to update in case it exists.
     */
    where: PagamentoWhereUniqueInput
    /**
     * In case the Pagamento found by the `where` argument doesn't exist, create a new Pagamento with this data.
     */
    create: XOR<PagamentoCreateInput, PagamentoUncheckedCreateInput>
    /**
     * In case the Pagamento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PagamentoUpdateInput, PagamentoUncheckedUpdateInput>
  }

  /**
   * Pagamento delete
   */
  export type PagamentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter which Pagamento to delete.
     */
    where: PagamentoWhereUniqueInput
  }

  /**
   * Pagamento deleteMany
   */
  export type PagamentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pagamentos to delete
     */
    where?: PagamentoWhereInput
  }

  /**
   * Pagamento.reserva
   */
  export type Pagamento$reservaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reserva
     */
    select?: ReservaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservaInclude<ExtArgs> | null
    where?: ReservaWhereInput
  }

  /**
   * Pagamento without action
   */
  export type PagamentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    email: 'email',
    senha: 'senha',
    tipo: 'tipo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const ClienteScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId'
  };

  export type ClienteScalarFieldEnum = (typeof ClienteScalarFieldEnum)[keyof typeof ClienteScalarFieldEnum]


  export const ProprietarioScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    nivel_privilegio: 'nivel_privilegio'
  };

  export type ProprietarioScalarFieldEnum = (typeof ProprietarioScalarFieldEnum)[keyof typeof ProprietarioScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const LavanderiaScalarFieldEnum: {
    id: 'id',
    nomeFantasia: 'nomeFantasia',
    razaoSocial: 'razaoSocial',
    endereco: 'endereco',
    telefone: 'telefone',
    horarioAbertura: 'horarioAbertura',
    horarioFechamento: 'horarioFechamento',
    descricao: 'descricao',
    fotoUrl: 'fotoUrl',
    latitude: 'latitude',
    longitude: 'longitude',
    proprietario_id: 'proprietario_id',
    destaque: 'destaque',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LavanderiaScalarFieldEnum = (typeof LavanderiaScalarFieldEnum)[keyof typeof LavanderiaScalarFieldEnum]


  export const MaquinaScalarFieldEnum: {
    id: 'id',
    tipo: 'tipo',
    status_maquina: 'status_maquina',
    capacidade: 'capacidade',
    preco: 'preco',
    lavanderia_id: 'lavanderia_id',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type MaquinaScalarFieldEnum = (typeof MaquinaScalarFieldEnum)[keyof typeof MaquinaScalarFieldEnum]


  export const RelatorioScalarFieldEnum: {
    id: 'id',
    admin_id: 'admin_id',
    proprietario_id: 'proprietario_id',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type RelatorioScalarFieldEnum = (typeof RelatorioScalarFieldEnum)[keyof typeof RelatorioScalarFieldEnum]


  export const ReservaScalarFieldEnum: {
    id: 'id',
    status: 'status',
    cliente_id: 'cliente_id',
    maquina_id: 'maquina_id',
    inicio: 'inicio',
    fim: 'fim',
    createAt: 'createAt',
    updateAt: 'updateAt',
    pagamento_id: 'pagamento_id'
  };

  export type ReservaScalarFieldEnum = (typeof ReservaScalarFieldEnum)[keyof typeof ReservaScalarFieldEnum]


  export const AvaliacaoScalarFieldEnum: {
    id: 'id',
    nota: 'nota',
    comentario: 'comentario',
    cliente_id: 'cliente_id',
    lavanderia_id: 'lavanderia_id',
    createAt: 'createAt',
    updateAt: 'updateAt'
  };

  export type AvaliacaoScalarFieldEnum = (typeof AvaliacaoScalarFieldEnum)[keyof typeof AvaliacaoScalarFieldEnum]


  export const PagamentoScalarFieldEnum: {
    id: 'id',
    valor: 'valor',
    metodo: 'metodo',
    status: 'status',
    createAt: 'createAt'
  };

  export type PagamentoScalarFieldEnum = (typeof PagamentoScalarFieldEnum)[keyof typeof PagamentoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'TipoUsuario'
   */
  export type EnumTipoUsuarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoUsuario'>
    


  /**
   * Reference to a field of type 'TipoUsuario[]'
   */
  export type ListEnumTipoUsuarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoUsuario[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Niveis_privilegio'
   */
  export type EnumNiveis_privilegioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Niveis_privilegio'>
    


  /**
   * Reference to a field of type 'Niveis_privilegio[]'
   */
  export type ListEnumNiveis_privilegioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Niveis_privilegio[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Tipo_maquina'
   */
  export type EnumTipo_maquinaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Tipo_maquina'>
    


  /**
   * Reference to a field of type 'Tipo_maquina[]'
   */
  export type ListEnumTipo_maquinaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Tipo_maquina[]'>
    


  /**
   * Reference to a field of type 'Status_maquina'
   */
  export type EnumStatus_maquinaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status_maquina'>
    


  /**
   * Reference to a field of type 'Status_maquina[]'
   */
  export type ListEnumStatus_maquinaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status_maquina[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Status_reserva'
   */
  export type EnumStatus_reservaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status_reserva'>
    


  /**
   * Reference to a field of type 'Status_reserva[]'
   */
  export type ListEnumStatus_reservaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status_reserva[]'>
    


  /**
   * Reference to a field of type 'Metodo_Pagamento'
   */
  export type EnumMetodo_PagamentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Metodo_Pagamento'>
    


  /**
   * Reference to a field of type 'Metodo_Pagamento[]'
   */
  export type ListEnumMetodo_PagamentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Metodo_Pagamento[]'>
    


  /**
   * Reference to a field of type 'Status_Pagamento'
   */
  export type EnumStatus_PagamentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status_Pagamento'>
    


  /**
   * Reference to a field of type 'Status_Pagamento[]'
   */
  export type ListEnumStatus_PagamentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status_Pagamento[]'>
    
  /**
   * Deep Input Types
   */


  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: StringFilter<"Usuario"> | string
    nome?: StringFilter<"Usuario"> | string
    email?: StringFilter<"Usuario"> | string
    senha?: StringFilter<"Usuario"> | string
    tipo?: EnumTipoUsuarioFilter<"Usuario"> | $Enums.TipoUsuario
    createdAt?: DateTimeFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeFilter<"Usuario"> | Date | string
    cliente?: XOR<ClienteNullableRelationFilter, ClienteWhereInput> | null
    proprietario?: XOR<ProprietarioNullableRelationFilter, ProprietarioWhereInput> | null
    admin?: XOR<AdminNullableRelationFilter, AdminWhereInput> | null
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    tipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cliente?: ClienteOrderByWithRelationInput
    proprietario?: ProprietarioOrderByWithRelationInput
    admin?: AdminOrderByWithRelationInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    nome?: StringFilter<"Usuario"> | string
    senha?: StringFilter<"Usuario"> | string
    tipo?: EnumTipoUsuarioFilter<"Usuario"> | $Enums.TipoUsuario
    createdAt?: DateTimeFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeFilter<"Usuario"> | Date | string
    cliente?: XOR<ClienteNullableRelationFilter, ClienteWhereInput> | null
    proprietario?: XOR<ProprietarioNullableRelationFilter, ProprietarioWhereInput> | null
    admin?: XOR<AdminNullableRelationFilter, AdminWhereInput> | null
  }, "id" | "email">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    tipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Usuario"> | string
    nome?: StringWithAggregatesFilter<"Usuario"> | string
    email?: StringWithAggregatesFilter<"Usuario"> | string
    senha?: StringWithAggregatesFilter<"Usuario"> | string
    tipo?: EnumTipoUsuarioWithAggregatesFilter<"Usuario"> | $Enums.TipoUsuario
    createdAt?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
  }

  export type ClienteWhereInput = {
    AND?: ClienteWhereInput | ClienteWhereInput[]
    OR?: ClienteWhereInput[]
    NOT?: ClienteWhereInput | ClienteWhereInput[]
    id?: StringFilter<"Cliente"> | string
    usuarioId?: StringFilter<"Cliente"> | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    reservas?: ReservaListRelationFilter
    avaliacoes?: AvaliacaoListRelationFilter
  }

  export type ClienteOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
    reservas?: ReservaOrderByRelationAggregateInput
    avaliacoes?: AvaliacaoOrderByRelationAggregateInput
  }

  export type ClienteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    usuarioId?: string
    AND?: ClienteWhereInput | ClienteWhereInput[]
    OR?: ClienteWhereInput[]
    NOT?: ClienteWhereInput | ClienteWhereInput[]
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    reservas?: ReservaListRelationFilter
    avaliacoes?: AvaliacaoListRelationFilter
  }, "id" | "usuarioId">

  export type ClienteOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    _count?: ClienteCountOrderByAggregateInput
    _max?: ClienteMaxOrderByAggregateInput
    _min?: ClienteMinOrderByAggregateInput
  }

  export type ClienteScalarWhereWithAggregatesInput = {
    AND?: ClienteScalarWhereWithAggregatesInput | ClienteScalarWhereWithAggregatesInput[]
    OR?: ClienteScalarWhereWithAggregatesInput[]
    NOT?: ClienteScalarWhereWithAggregatesInput | ClienteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cliente"> | string
    usuarioId?: StringWithAggregatesFilter<"Cliente"> | string
  }

  export type ProprietarioWhereInput = {
    AND?: ProprietarioWhereInput | ProprietarioWhereInput[]
    OR?: ProprietarioWhereInput[]
    NOT?: ProprietarioWhereInput | ProprietarioWhereInput[]
    id?: StringFilter<"Proprietario"> | string
    usuarioId?: StringFilter<"Proprietario"> | string
    nivel_privilegio?: EnumNiveis_privilegioFilter<"Proprietario"> | $Enums.Niveis_privilegio
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    lavanderias?: LavanderiaListRelationFilter
    Relatorios?: RelatorioListRelationFilter
  }

  export type ProprietarioOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nivel_privilegio?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
    lavanderias?: LavanderiaOrderByRelationAggregateInput
    Relatorios?: RelatorioOrderByRelationAggregateInput
  }

  export type ProprietarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    usuarioId?: string
    AND?: ProprietarioWhereInput | ProprietarioWhereInput[]
    OR?: ProprietarioWhereInput[]
    NOT?: ProprietarioWhereInput | ProprietarioWhereInput[]
    nivel_privilegio?: EnumNiveis_privilegioFilter<"Proprietario"> | $Enums.Niveis_privilegio
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    lavanderias?: LavanderiaListRelationFilter
    Relatorios?: RelatorioListRelationFilter
  }, "id" | "usuarioId">

  export type ProprietarioOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nivel_privilegio?: SortOrder
    _count?: ProprietarioCountOrderByAggregateInput
    _max?: ProprietarioMaxOrderByAggregateInput
    _min?: ProprietarioMinOrderByAggregateInput
  }

  export type ProprietarioScalarWhereWithAggregatesInput = {
    AND?: ProprietarioScalarWhereWithAggregatesInput | ProprietarioScalarWhereWithAggregatesInput[]
    OR?: ProprietarioScalarWhereWithAggregatesInput[]
    NOT?: ProprietarioScalarWhereWithAggregatesInput | ProprietarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Proprietario"> | string
    usuarioId?: StringWithAggregatesFilter<"Proprietario"> | string
    nivel_privilegio?: EnumNiveis_privilegioWithAggregatesFilter<"Proprietario"> | $Enums.Niveis_privilegio
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter<"Admin"> | string
    usuarioId?: StringFilter<"Admin"> | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    relatorios?: RelatorioListRelationFilter
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
    relatorios?: RelatorioOrderByRelationAggregateInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    usuarioId?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    relatorios?: RelatorioListRelationFilter
  }, "id" | "usuarioId">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admin"> | string
    usuarioId?: StringWithAggregatesFilter<"Admin"> | string
  }

  export type LavanderiaWhereInput = {
    AND?: LavanderiaWhereInput | LavanderiaWhereInput[]
    OR?: LavanderiaWhereInput[]
    NOT?: LavanderiaWhereInput | LavanderiaWhereInput[]
    id?: StringFilter<"Lavanderia"> | string
    nomeFantasia?: StringFilter<"Lavanderia"> | string
    razaoSocial?: StringFilter<"Lavanderia"> | string
    endereco?: StringFilter<"Lavanderia"> | string
    telefone?: StringNullableFilter<"Lavanderia"> | string | null
    horarioAbertura?: StringNullableFilter<"Lavanderia"> | string | null
    horarioFechamento?: StringNullableFilter<"Lavanderia"> | string | null
    descricao?: StringNullableFilter<"Lavanderia"> | string | null
    fotoUrl?: StringNullableFilter<"Lavanderia"> | string | null
    latitude?: FloatNullableFilter<"Lavanderia"> | number | null
    longitude?: FloatNullableFilter<"Lavanderia"> | number | null
    proprietario_id?: StringFilter<"Lavanderia"> | string
    destaque?: BoolFilter<"Lavanderia"> | boolean
    createdAt?: DateTimeFilter<"Lavanderia"> | Date | string
    updatedAt?: DateTimeFilter<"Lavanderia"> | Date | string
    proprietario?: XOR<ProprietarioRelationFilter, ProprietarioWhereInput>
    maquinas?: MaquinaListRelationFilter
    avaliacoes?: AvaliacaoListRelationFilter
  }

  export type LavanderiaOrderByWithRelationInput = {
    id?: SortOrder
    nomeFantasia?: SortOrder
    razaoSocial?: SortOrder
    endereco?: SortOrder
    telefone?: SortOrderInput | SortOrder
    horarioAbertura?: SortOrderInput | SortOrder
    horarioFechamento?: SortOrderInput | SortOrder
    descricao?: SortOrderInput | SortOrder
    fotoUrl?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    proprietario_id?: SortOrder
    destaque?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    proprietario?: ProprietarioOrderByWithRelationInput
    maquinas?: MaquinaOrderByRelationAggregateInput
    avaliacoes?: AvaliacaoOrderByRelationAggregateInput
  }

  export type LavanderiaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LavanderiaWhereInput | LavanderiaWhereInput[]
    OR?: LavanderiaWhereInput[]
    NOT?: LavanderiaWhereInput | LavanderiaWhereInput[]
    nomeFantasia?: StringFilter<"Lavanderia"> | string
    razaoSocial?: StringFilter<"Lavanderia"> | string
    endereco?: StringFilter<"Lavanderia"> | string
    telefone?: StringNullableFilter<"Lavanderia"> | string | null
    horarioAbertura?: StringNullableFilter<"Lavanderia"> | string | null
    horarioFechamento?: StringNullableFilter<"Lavanderia"> | string | null
    descricao?: StringNullableFilter<"Lavanderia"> | string | null
    fotoUrl?: StringNullableFilter<"Lavanderia"> | string | null
    latitude?: FloatNullableFilter<"Lavanderia"> | number | null
    longitude?: FloatNullableFilter<"Lavanderia"> | number | null
    proprietario_id?: StringFilter<"Lavanderia"> | string
    destaque?: BoolFilter<"Lavanderia"> | boolean
    createdAt?: DateTimeFilter<"Lavanderia"> | Date | string
    updatedAt?: DateTimeFilter<"Lavanderia"> | Date | string
    proprietario?: XOR<ProprietarioRelationFilter, ProprietarioWhereInput>
    maquinas?: MaquinaListRelationFilter
    avaliacoes?: AvaliacaoListRelationFilter
  }, "id">

  export type LavanderiaOrderByWithAggregationInput = {
    id?: SortOrder
    nomeFantasia?: SortOrder
    razaoSocial?: SortOrder
    endereco?: SortOrder
    telefone?: SortOrderInput | SortOrder
    horarioAbertura?: SortOrderInput | SortOrder
    horarioFechamento?: SortOrderInput | SortOrder
    descricao?: SortOrderInput | SortOrder
    fotoUrl?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    proprietario_id?: SortOrder
    destaque?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LavanderiaCountOrderByAggregateInput
    _avg?: LavanderiaAvgOrderByAggregateInput
    _max?: LavanderiaMaxOrderByAggregateInput
    _min?: LavanderiaMinOrderByAggregateInput
    _sum?: LavanderiaSumOrderByAggregateInput
  }

  export type LavanderiaScalarWhereWithAggregatesInput = {
    AND?: LavanderiaScalarWhereWithAggregatesInput | LavanderiaScalarWhereWithAggregatesInput[]
    OR?: LavanderiaScalarWhereWithAggregatesInput[]
    NOT?: LavanderiaScalarWhereWithAggregatesInput | LavanderiaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lavanderia"> | string
    nomeFantasia?: StringWithAggregatesFilter<"Lavanderia"> | string
    razaoSocial?: StringWithAggregatesFilter<"Lavanderia"> | string
    endereco?: StringWithAggregatesFilter<"Lavanderia"> | string
    telefone?: StringNullableWithAggregatesFilter<"Lavanderia"> | string | null
    horarioAbertura?: StringNullableWithAggregatesFilter<"Lavanderia"> | string | null
    horarioFechamento?: StringNullableWithAggregatesFilter<"Lavanderia"> | string | null
    descricao?: StringNullableWithAggregatesFilter<"Lavanderia"> | string | null
    fotoUrl?: StringNullableWithAggregatesFilter<"Lavanderia"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"Lavanderia"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Lavanderia"> | number | null
    proprietario_id?: StringWithAggregatesFilter<"Lavanderia"> | string
    destaque?: BoolWithAggregatesFilter<"Lavanderia"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Lavanderia"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lavanderia"> | Date | string
  }

  export type MaquinaWhereInput = {
    AND?: MaquinaWhereInput | MaquinaWhereInput[]
    OR?: MaquinaWhereInput[]
    NOT?: MaquinaWhereInput | MaquinaWhereInput[]
    id?: StringFilter<"Maquina"> | string
    tipo?: EnumTipo_maquinaFilter<"Maquina"> | $Enums.Tipo_maquina
    status_maquina?: EnumStatus_maquinaFilter<"Maquina"> | $Enums.Status_maquina
    capacidade?: IntFilter<"Maquina"> | number
    preco?: DecimalFilter<"Maquina"> | Decimal | DecimalJsLike | number | string
    lavanderia_id?: StringFilter<"Maquina"> | string
    createAt?: DateTimeFilter<"Maquina"> | Date | string
    updateAt?: DateTimeFilter<"Maquina"> | Date | string
    lavanderia?: XOR<LavanderiaRelationFilter, LavanderiaWhereInput>
    reservas?: ReservaListRelationFilter
  }

  export type MaquinaOrderByWithRelationInput = {
    id?: SortOrder
    tipo?: SortOrder
    status_maquina?: SortOrder
    capacidade?: SortOrder
    preco?: SortOrder
    lavanderia_id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    lavanderia?: LavanderiaOrderByWithRelationInput
    reservas?: ReservaOrderByRelationAggregateInput
  }

  export type MaquinaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaquinaWhereInput | MaquinaWhereInput[]
    OR?: MaquinaWhereInput[]
    NOT?: MaquinaWhereInput | MaquinaWhereInput[]
    tipo?: EnumTipo_maquinaFilter<"Maquina"> | $Enums.Tipo_maquina
    status_maquina?: EnumStatus_maquinaFilter<"Maquina"> | $Enums.Status_maquina
    capacidade?: IntFilter<"Maquina"> | number
    preco?: DecimalFilter<"Maquina"> | Decimal | DecimalJsLike | number | string
    lavanderia_id?: StringFilter<"Maquina"> | string
    createAt?: DateTimeFilter<"Maquina"> | Date | string
    updateAt?: DateTimeFilter<"Maquina"> | Date | string
    lavanderia?: XOR<LavanderiaRelationFilter, LavanderiaWhereInput>
    reservas?: ReservaListRelationFilter
  }, "id">

  export type MaquinaOrderByWithAggregationInput = {
    id?: SortOrder
    tipo?: SortOrder
    status_maquina?: SortOrder
    capacidade?: SortOrder
    preco?: SortOrder
    lavanderia_id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: MaquinaCountOrderByAggregateInput
    _avg?: MaquinaAvgOrderByAggregateInput
    _max?: MaquinaMaxOrderByAggregateInput
    _min?: MaquinaMinOrderByAggregateInput
    _sum?: MaquinaSumOrderByAggregateInput
  }

  export type MaquinaScalarWhereWithAggregatesInput = {
    AND?: MaquinaScalarWhereWithAggregatesInput | MaquinaScalarWhereWithAggregatesInput[]
    OR?: MaquinaScalarWhereWithAggregatesInput[]
    NOT?: MaquinaScalarWhereWithAggregatesInput | MaquinaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Maquina"> | string
    tipo?: EnumTipo_maquinaWithAggregatesFilter<"Maquina"> | $Enums.Tipo_maquina
    status_maquina?: EnumStatus_maquinaWithAggregatesFilter<"Maquina"> | $Enums.Status_maquina
    capacidade?: IntWithAggregatesFilter<"Maquina"> | number
    preco?: DecimalWithAggregatesFilter<"Maquina"> | Decimal | DecimalJsLike | number | string
    lavanderia_id?: StringWithAggregatesFilter<"Maquina"> | string
    createAt?: DateTimeWithAggregatesFilter<"Maquina"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"Maquina"> | Date | string
  }

  export type RelatorioWhereInput = {
    AND?: RelatorioWhereInput | RelatorioWhereInput[]
    OR?: RelatorioWhereInput[]
    NOT?: RelatorioWhereInput | RelatorioWhereInput[]
    id?: StringFilter<"Relatorio"> | string
    admin_id?: StringFilter<"Relatorio"> | string
    proprietario_id?: StringFilter<"Relatorio"> | string
    createAt?: DateTimeFilter<"Relatorio"> | Date | string
    updateAt?: DateTimeFilter<"Relatorio"> | Date | string
    admin?: XOR<AdminRelationFilter, AdminWhereInput>
    proprietario?: XOR<ProprietarioRelationFilter, ProprietarioWhereInput>
  }

  export type RelatorioOrderByWithRelationInput = {
    id?: SortOrder
    admin_id?: SortOrder
    proprietario_id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    admin?: AdminOrderByWithRelationInput
    proprietario?: ProprietarioOrderByWithRelationInput
  }

  export type RelatorioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RelatorioWhereInput | RelatorioWhereInput[]
    OR?: RelatorioWhereInput[]
    NOT?: RelatorioWhereInput | RelatorioWhereInput[]
    admin_id?: StringFilter<"Relatorio"> | string
    proprietario_id?: StringFilter<"Relatorio"> | string
    createAt?: DateTimeFilter<"Relatorio"> | Date | string
    updateAt?: DateTimeFilter<"Relatorio"> | Date | string
    admin?: XOR<AdminRelationFilter, AdminWhereInput>
    proprietario?: XOR<ProprietarioRelationFilter, ProprietarioWhereInput>
  }, "id">

  export type RelatorioOrderByWithAggregationInput = {
    id?: SortOrder
    admin_id?: SortOrder
    proprietario_id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: RelatorioCountOrderByAggregateInput
    _max?: RelatorioMaxOrderByAggregateInput
    _min?: RelatorioMinOrderByAggregateInput
  }

  export type RelatorioScalarWhereWithAggregatesInput = {
    AND?: RelatorioScalarWhereWithAggregatesInput | RelatorioScalarWhereWithAggregatesInput[]
    OR?: RelatorioScalarWhereWithAggregatesInput[]
    NOT?: RelatorioScalarWhereWithAggregatesInput | RelatorioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Relatorio"> | string
    admin_id?: StringWithAggregatesFilter<"Relatorio"> | string
    proprietario_id?: StringWithAggregatesFilter<"Relatorio"> | string
    createAt?: DateTimeWithAggregatesFilter<"Relatorio"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"Relatorio"> | Date | string
  }

  export type ReservaWhereInput = {
    AND?: ReservaWhereInput | ReservaWhereInput[]
    OR?: ReservaWhereInput[]
    NOT?: ReservaWhereInput | ReservaWhereInput[]
    id?: StringFilter<"Reserva"> | string
    status?: EnumStatus_reservaFilter<"Reserva"> | $Enums.Status_reserva
    cliente_id?: StringFilter<"Reserva"> | string
    maquina_id?: StringFilter<"Reserva"> | string
    inicio?: DateTimeFilter<"Reserva"> | Date | string
    fim?: DateTimeFilter<"Reserva"> | Date | string
    createAt?: DateTimeFilter<"Reserva"> | Date | string
    updateAt?: DateTimeFilter<"Reserva"> | Date | string
    pagamento_id?: StringNullableFilter<"Reserva"> | string | null
    cliente?: XOR<ClienteRelationFilter, ClienteWhereInput>
    maquina?: XOR<MaquinaRelationFilter, MaquinaWhereInput>
    pagamento?: XOR<PagamentoNullableRelationFilter, PagamentoWhereInput> | null
  }

  export type ReservaOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    cliente_id?: SortOrder
    maquina_id?: SortOrder
    inicio?: SortOrder
    fim?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    pagamento_id?: SortOrderInput | SortOrder
    cliente?: ClienteOrderByWithRelationInput
    maquina?: MaquinaOrderByWithRelationInput
    pagamento?: PagamentoOrderByWithRelationInput
  }

  export type ReservaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    pagamento_id?: string
    AND?: ReservaWhereInput | ReservaWhereInput[]
    OR?: ReservaWhereInput[]
    NOT?: ReservaWhereInput | ReservaWhereInput[]
    status?: EnumStatus_reservaFilter<"Reserva"> | $Enums.Status_reserva
    cliente_id?: StringFilter<"Reserva"> | string
    maquina_id?: StringFilter<"Reserva"> | string
    inicio?: DateTimeFilter<"Reserva"> | Date | string
    fim?: DateTimeFilter<"Reserva"> | Date | string
    createAt?: DateTimeFilter<"Reserva"> | Date | string
    updateAt?: DateTimeFilter<"Reserva"> | Date | string
    cliente?: XOR<ClienteRelationFilter, ClienteWhereInput>
    maquina?: XOR<MaquinaRelationFilter, MaquinaWhereInput>
    pagamento?: XOR<PagamentoNullableRelationFilter, PagamentoWhereInput> | null
  }, "id" | "pagamento_id">

  export type ReservaOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    cliente_id?: SortOrder
    maquina_id?: SortOrder
    inicio?: SortOrder
    fim?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    pagamento_id?: SortOrderInput | SortOrder
    _count?: ReservaCountOrderByAggregateInput
    _max?: ReservaMaxOrderByAggregateInput
    _min?: ReservaMinOrderByAggregateInput
  }

  export type ReservaScalarWhereWithAggregatesInput = {
    AND?: ReservaScalarWhereWithAggregatesInput | ReservaScalarWhereWithAggregatesInput[]
    OR?: ReservaScalarWhereWithAggregatesInput[]
    NOT?: ReservaScalarWhereWithAggregatesInput | ReservaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reserva"> | string
    status?: EnumStatus_reservaWithAggregatesFilter<"Reserva"> | $Enums.Status_reserva
    cliente_id?: StringWithAggregatesFilter<"Reserva"> | string
    maquina_id?: StringWithAggregatesFilter<"Reserva"> | string
    inicio?: DateTimeWithAggregatesFilter<"Reserva"> | Date | string
    fim?: DateTimeWithAggregatesFilter<"Reserva"> | Date | string
    createAt?: DateTimeWithAggregatesFilter<"Reserva"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"Reserva"> | Date | string
    pagamento_id?: StringNullableWithAggregatesFilter<"Reserva"> | string | null
  }

  export type AvaliacaoWhereInput = {
    AND?: AvaliacaoWhereInput | AvaliacaoWhereInput[]
    OR?: AvaliacaoWhereInput[]
    NOT?: AvaliacaoWhereInput | AvaliacaoWhereInput[]
    id?: StringFilter<"Avaliacao"> | string
    nota?: IntFilter<"Avaliacao"> | number
    comentario?: StringFilter<"Avaliacao"> | string
    cliente_id?: StringFilter<"Avaliacao"> | string
    lavanderia_id?: StringFilter<"Avaliacao"> | string
    createAt?: DateTimeFilter<"Avaliacao"> | Date | string
    updateAt?: DateTimeFilter<"Avaliacao"> | Date | string
    cliente?: XOR<ClienteRelationFilter, ClienteWhereInput>
    lavanderia?: XOR<LavanderiaRelationFilter, LavanderiaWhereInput>
  }

  export type AvaliacaoOrderByWithRelationInput = {
    id?: SortOrder
    nota?: SortOrder
    comentario?: SortOrder
    cliente_id?: SortOrder
    lavanderia_id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    cliente?: ClienteOrderByWithRelationInput
    lavanderia?: LavanderiaOrderByWithRelationInput
  }

  export type AvaliacaoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AvaliacaoWhereInput | AvaliacaoWhereInput[]
    OR?: AvaliacaoWhereInput[]
    NOT?: AvaliacaoWhereInput | AvaliacaoWhereInput[]
    nota?: IntFilter<"Avaliacao"> | number
    comentario?: StringFilter<"Avaliacao"> | string
    cliente_id?: StringFilter<"Avaliacao"> | string
    lavanderia_id?: StringFilter<"Avaliacao"> | string
    createAt?: DateTimeFilter<"Avaliacao"> | Date | string
    updateAt?: DateTimeFilter<"Avaliacao"> | Date | string
    cliente?: XOR<ClienteRelationFilter, ClienteWhereInput>
    lavanderia?: XOR<LavanderiaRelationFilter, LavanderiaWhereInput>
  }, "id">

  export type AvaliacaoOrderByWithAggregationInput = {
    id?: SortOrder
    nota?: SortOrder
    comentario?: SortOrder
    cliente_id?: SortOrder
    lavanderia_id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    _count?: AvaliacaoCountOrderByAggregateInput
    _avg?: AvaliacaoAvgOrderByAggregateInput
    _max?: AvaliacaoMaxOrderByAggregateInput
    _min?: AvaliacaoMinOrderByAggregateInput
    _sum?: AvaliacaoSumOrderByAggregateInput
  }

  export type AvaliacaoScalarWhereWithAggregatesInput = {
    AND?: AvaliacaoScalarWhereWithAggregatesInput | AvaliacaoScalarWhereWithAggregatesInput[]
    OR?: AvaliacaoScalarWhereWithAggregatesInput[]
    NOT?: AvaliacaoScalarWhereWithAggregatesInput | AvaliacaoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Avaliacao"> | string
    nota?: IntWithAggregatesFilter<"Avaliacao"> | number
    comentario?: StringWithAggregatesFilter<"Avaliacao"> | string
    cliente_id?: StringWithAggregatesFilter<"Avaliacao"> | string
    lavanderia_id?: StringWithAggregatesFilter<"Avaliacao"> | string
    createAt?: DateTimeWithAggregatesFilter<"Avaliacao"> | Date | string
    updateAt?: DateTimeWithAggregatesFilter<"Avaliacao"> | Date | string
  }

  export type PagamentoWhereInput = {
    AND?: PagamentoWhereInput | PagamentoWhereInput[]
    OR?: PagamentoWhereInput[]
    NOT?: PagamentoWhereInput | PagamentoWhereInput[]
    id?: StringFilter<"Pagamento"> | string
    valor?: DecimalFilter<"Pagamento"> | Decimal | DecimalJsLike | number | string
    metodo?: EnumMetodo_PagamentoFilter<"Pagamento"> | $Enums.Metodo_Pagamento
    status?: EnumStatus_PagamentoFilter<"Pagamento"> | $Enums.Status_Pagamento
    createAt?: DateTimeFilter<"Pagamento"> | Date | string
    reserva?: XOR<ReservaNullableRelationFilter, ReservaWhereInput> | null
  }

  export type PagamentoOrderByWithRelationInput = {
    id?: SortOrder
    valor?: SortOrder
    metodo?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    reserva?: ReservaOrderByWithRelationInput
  }

  export type PagamentoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PagamentoWhereInput | PagamentoWhereInput[]
    OR?: PagamentoWhereInput[]
    NOT?: PagamentoWhereInput | PagamentoWhereInput[]
    valor?: DecimalFilter<"Pagamento"> | Decimal | DecimalJsLike | number | string
    metodo?: EnumMetodo_PagamentoFilter<"Pagamento"> | $Enums.Metodo_Pagamento
    status?: EnumStatus_PagamentoFilter<"Pagamento"> | $Enums.Status_Pagamento
    createAt?: DateTimeFilter<"Pagamento"> | Date | string
    reserva?: XOR<ReservaNullableRelationFilter, ReservaWhereInput> | null
  }, "id">

  export type PagamentoOrderByWithAggregationInput = {
    id?: SortOrder
    valor?: SortOrder
    metodo?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
    _count?: PagamentoCountOrderByAggregateInput
    _avg?: PagamentoAvgOrderByAggregateInput
    _max?: PagamentoMaxOrderByAggregateInput
    _min?: PagamentoMinOrderByAggregateInput
    _sum?: PagamentoSumOrderByAggregateInput
  }

  export type PagamentoScalarWhereWithAggregatesInput = {
    AND?: PagamentoScalarWhereWithAggregatesInput | PagamentoScalarWhereWithAggregatesInput[]
    OR?: PagamentoScalarWhereWithAggregatesInput[]
    NOT?: PagamentoScalarWhereWithAggregatesInput | PagamentoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pagamento"> | string
    valor?: DecimalWithAggregatesFilter<"Pagamento"> | Decimal | DecimalJsLike | number | string
    metodo?: EnumMetodo_PagamentoWithAggregatesFilter<"Pagamento"> | $Enums.Metodo_Pagamento
    status?: EnumStatus_PagamentoWithAggregatesFilter<"Pagamento"> | $Enums.Status_Pagamento
    createAt?: DateTimeWithAggregatesFilter<"Pagamento"> | Date | string
  }

  export type UsuarioCreateInput = {
    id?: string
    nome: string
    email: string
    senha: string
    tipo: $Enums.TipoUsuario
    createdAt?: Date | string
    updatedAt?: Date | string
    cliente?: ClienteCreateNestedOneWithoutUsuarioInput
    proprietario?: ProprietarioCreateNestedOneWithoutUsuarioInput
    admin?: AdminCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: string
    nome: string
    email: string
    senha: string
    tipo: $Enums.TipoUsuario
    createdAt?: Date | string
    updatedAt?: Date | string
    cliente?: ClienteUncheckedCreateNestedOneWithoutUsuarioInput
    proprietario?: ProprietarioUncheckedCreateNestedOneWithoutUsuarioInput
    admin?: AdminUncheckedCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUpdateOneWithoutUsuarioNestedInput
    proprietario?: ProprietarioUpdateOneWithoutUsuarioNestedInput
    admin?: AdminUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUncheckedUpdateOneWithoutUsuarioNestedInput
    proprietario?: ProprietarioUncheckedUpdateOneWithoutUsuarioNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: string
    nome: string
    email: string
    senha: string
    tipo: $Enums.TipoUsuario
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsuarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClienteCreateInput = {
    id?: string
    usuario: UsuarioCreateNestedOneWithoutClienteInput
    reservas?: ReservaCreateNestedManyWithoutClienteInput
    avaliacoes?: AvaliacaoCreateNestedManyWithoutClienteInput
  }

  export type ClienteUncheckedCreateInput = {
    id?: string
    usuarioId: string
    reservas?: ReservaUncheckedCreateNestedManyWithoutClienteInput
    avaliacoes?: AvaliacaoUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuario?: UsuarioUpdateOneRequiredWithoutClienteNestedInput
    reservas?: ReservaUpdateManyWithoutClienteNestedInput
    avaliacoes?: AvaliacaoUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    reservas?: ReservaUncheckedUpdateManyWithoutClienteNestedInput
    avaliacoes?: AvaliacaoUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type ClienteCreateManyInput = {
    id?: string
    usuarioId: string
  }

  export type ClienteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ClienteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
  }

  export type ProprietarioCreateInput = {
    id?: string
    nivel_privilegio?: $Enums.Niveis_privilegio
    usuario: UsuarioCreateNestedOneWithoutProprietarioInput
    lavanderias?: LavanderiaCreateNestedManyWithoutProprietarioInput
    Relatorios?: RelatorioCreateNestedManyWithoutProprietarioInput
  }

  export type ProprietarioUncheckedCreateInput = {
    id?: string
    usuarioId: string
    nivel_privilegio?: $Enums.Niveis_privilegio
    lavanderias?: LavanderiaUncheckedCreateNestedManyWithoutProprietarioInput
    Relatorios?: RelatorioUncheckedCreateNestedManyWithoutProprietarioInput
  }

  export type ProprietarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nivel_privilegio?: EnumNiveis_privilegioFieldUpdateOperationsInput | $Enums.Niveis_privilegio
    usuario?: UsuarioUpdateOneRequiredWithoutProprietarioNestedInput
    lavanderias?: LavanderiaUpdateManyWithoutProprietarioNestedInput
    Relatorios?: RelatorioUpdateManyWithoutProprietarioNestedInput
  }

  export type ProprietarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    nivel_privilegio?: EnumNiveis_privilegioFieldUpdateOperationsInput | $Enums.Niveis_privilegio
    lavanderias?: LavanderiaUncheckedUpdateManyWithoutProprietarioNestedInput
    Relatorios?: RelatorioUncheckedUpdateManyWithoutProprietarioNestedInput
  }

  export type ProprietarioCreateManyInput = {
    id?: string
    usuarioId: string
    nivel_privilegio?: $Enums.Niveis_privilegio
  }

  export type ProprietarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nivel_privilegio?: EnumNiveis_privilegioFieldUpdateOperationsInput | $Enums.Niveis_privilegio
  }

  export type ProprietarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    nivel_privilegio?: EnumNiveis_privilegioFieldUpdateOperationsInput | $Enums.Niveis_privilegio
  }

  export type AdminCreateInput = {
    id?: string
    usuario: UsuarioCreateNestedOneWithoutAdminInput
    relatorios?: RelatorioCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    usuarioId: string
    relatorios?: RelatorioUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuario?: UsuarioUpdateOneRequiredWithoutAdminNestedInput
    relatorios?: RelatorioUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    relatorios?: RelatorioUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminCreateManyInput = {
    id?: string
    usuarioId: string
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
  }

  export type LavanderiaCreateInput = {
    id?: string
    nomeFantasia: string
    razaoSocial: string
    endereco: string
    telefone?: string | null
    horarioAbertura?: string | null
    horarioFechamento?: string | null
    descricao?: string | null
    fotoUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    destaque?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    proprietario: ProprietarioCreateNestedOneWithoutLavanderiasInput
    maquinas?: MaquinaCreateNestedManyWithoutLavanderiaInput
    avaliacoes?: AvaliacaoCreateNestedManyWithoutLavanderiaInput
  }

  export type LavanderiaUncheckedCreateInput = {
    id?: string
    nomeFantasia: string
    razaoSocial: string
    endereco: string
    telefone?: string | null
    horarioAbertura?: string | null
    horarioFechamento?: string | null
    descricao?: string | null
    fotoUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    proprietario_id: string
    destaque?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    maquinas?: MaquinaUncheckedCreateNestedManyWithoutLavanderiaInput
    avaliacoes?: AvaliacaoUncheckedCreateNestedManyWithoutLavanderiaInput
  }

  export type LavanderiaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    horarioAbertura?: NullableStringFieldUpdateOperationsInput | string | null
    horarioFechamento?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destaque?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proprietario?: ProprietarioUpdateOneRequiredWithoutLavanderiasNestedInput
    maquinas?: MaquinaUpdateManyWithoutLavanderiaNestedInput
    avaliacoes?: AvaliacaoUpdateManyWithoutLavanderiaNestedInput
  }

  export type LavanderiaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    horarioAbertura?: NullableStringFieldUpdateOperationsInput | string | null
    horarioFechamento?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    proprietario_id?: StringFieldUpdateOperationsInput | string
    destaque?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maquinas?: MaquinaUncheckedUpdateManyWithoutLavanderiaNestedInput
    avaliacoes?: AvaliacaoUncheckedUpdateManyWithoutLavanderiaNestedInput
  }

  export type LavanderiaCreateManyInput = {
    id?: string
    nomeFantasia: string
    razaoSocial: string
    endereco: string
    telefone?: string | null
    horarioAbertura?: string | null
    horarioFechamento?: string | null
    descricao?: string | null
    fotoUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    proprietario_id: string
    destaque?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LavanderiaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    horarioAbertura?: NullableStringFieldUpdateOperationsInput | string | null
    horarioFechamento?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destaque?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LavanderiaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    horarioAbertura?: NullableStringFieldUpdateOperationsInput | string | null
    horarioFechamento?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    proprietario_id?: StringFieldUpdateOperationsInput | string
    destaque?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaquinaCreateInput = {
    id?: string
    tipo?: $Enums.Tipo_maquina
    status_maquina?: $Enums.Status_maquina
    capacidade?: number
    preco: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    lavanderia: LavanderiaCreateNestedOneWithoutMaquinasInput
    reservas?: ReservaCreateNestedManyWithoutMaquinaInput
  }

  export type MaquinaUncheckedCreateInput = {
    id?: string
    tipo?: $Enums.Tipo_maquina
    status_maquina?: $Enums.Status_maquina
    capacidade?: number
    preco: Decimal | DecimalJsLike | number | string
    lavanderia_id: string
    createAt?: Date | string
    updateAt?: Date | string
    reservas?: ReservaUncheckedCreateNestedManyWithoutMaquinaInput
  }

  export type MaquinaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_maquinaFieldUpdateOperationsInput | $Enums.Tipo_maquina
    status_maquina?: EnumStatus_maquinaFieldUpdateOperationsInput | $Enums.Status_maquina
    capacidade?: IntFieldUpdateOperationsInput | number
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lavanderia?: LavanderiaUpdateOneRequiredWithoutMaquinasNestedInput
    reservas?: ReservaUpdateManyWithoutMaquinaNestedInput
  }

  export type MaquinaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_maquinaFieldUpdateOperationsInput | $Enums.Tipo_maquina
    status_maquina?: EnumStatus_maquinaFieldUpdateOperationsInput | $Enums.Status_maquina
    capacidade?: IntFieldUpdateOperationsInput | number
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lavanderia_id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservas?: ReservaUncheckedUpdateManyWithoutMaquinaNestedInput
  }

  export type MaquinaCreateManyInput = {
    id?: string
    tipo?: $Enums.Tipo_maquina
    status_maquina?: $Enums.Status_maquina
    capacidade?: number
    preco: Decimal | DecimalJsLike | number | string
    lavanderia_id: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MaquinaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_maquinaFieldUpdateOperationsInput | $Enums.Tipo_maquina
    status_maquina?: EnumStatus_maquinaFieldUpdateOperationsInput | $Enums.Status_maquina
    capacidade?: IntFieldUpdateOperationsInput | number
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaquinaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_maquinaFieldUpdateOperationsInput | $Enums.Tipo_maquina
    status_maquina?: EnumStatus_maquinaFieldUpdateOperationsInput | $Enums.Status_maquina
    capacidade?: IntFieldUpdateOperationsInput | number
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lavanderia_id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelatorioCreateInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    admin: AdminCreateNestedOneWithoutRelatoriosInput
    proprietario: ProprietarioCreateNestedOneWithoutRelatoriosInput
  }

  export type RelatorioUncheckedCreateInput = {
    id?: string
    admin_id: string
    proprietario_id: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type RelatorioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutRelatoriosNestedInput
    proprietario?: ProprietarioUpdateOneRequiredWithoutRelatoriosNestedInput
  }

  export type RelatorioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    admin_id?: StringFieldUpdateOperationsInput | string
    proprietario_id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelatorioCreateManyInput = {
    id?: string
    admin_id: string
    proprietario_id: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type RelatorioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelatorioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    admin_id?: StringFieldUpdateOperationsInput | string
    proprietario_id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservaCreateInput = {
    id?: string
    status?: $Enums.Status_reserva
    inicio: Date | string
    fim: Date | string
    createAt?: Date | string
    updateAt?: Date | string
    cliente: ClienteCreateNestedOneWithoutReservasInput
    maquina: MaquinaCreateNestedOneWithoutReservasInput
    pagamento?: PagamentoCreateNestedOneWithoutReservaInput
  }

  export type ReservaUncheckedCreateInput = {
    id?: string
    status?: $Enums.Status_reserva
    cliente_id: string
    maquina_id: string
    inicio: Date | string
    fim: Date | string
    createAt?: Date | string
    updateAt?: Date | string
    pagamento_id?: string | null
  }

  export type ReservaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatus_reservaFieldUpdateOperationsInput | $Enums.Status_reserva
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUpdateOneRequiredWithoutReservasNestedInput
    maquina?: MaquinaUpdateOneRequiredWithoutReservasNestedInput
    pagamento?: PagamentoUpdateOneWithoutReservaNestedInput
  }

  export type ReservaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatus_reservaFieldUpdateOperationsInput | $Enums.Status_reserva
    cliente_id?: StringFieldUpdateOperationsInput | string
    maquina_id?: StringFieldUpdateOperationsInput | string
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagamento_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReservaCreateManyInput = {
    id?: string
    status?: $Enums.Status_reserva
    cliente_id: string
    maquina_id: string
    inicio: Date | string
    fim: Date | string
    createAt?: Date | string
    updateAt?: Date | string
    pagamento_id?: string | null
  }

  export type ReservaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatus_reservaFieldUpdateOperationsInput | $Enums.Status_reserva
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatus_reservaFieldUpdateOperationsInput | $Enums.Status_reserva
    cliente_id?: StringFieldUpdateOperationsInput | string
    maquina_id?: StringFieldUpdateOperationsInput | string
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagamento_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AvaliacaoCreateInput = {
    id?: string
    nota: number
    comentario: string
    createAt?: Date | string
    updateAt?: Date | string
    cliente: ClienteCreateNestedOneWithoutAvaliacoesInput
    lavanderia: LavanderiaCreateNestedOneWithoutAvaliacoesInput
  }

  export type AvaliacaoUncheckedCreateInput = {
    id?: string
    nota: number
    comentario: string
    cliente_id: string
    lavanderia_id: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type AvaliacaoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nota?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUpdateOneRequiredWithoutAvaliacoesNestedInput
    lavanderia?: LavanderiaUpdateOneRequiredWithoutAvaliacoesNestedInput
  }

  export type AvaliacaoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nota?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    cliente_id?: StringFieldUpdateOperationsInput | string
    lavanderia_id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvaliacaoCreateManyInput = {
    id?: string
    nota: number
    comentario: string
    cliente_id: string
    lavanderia_id: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type AvaliacaoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nota?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvaliacaoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nota?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    cliente_id?: StringFieldUpdateOperationsInput | string
    lavanderia_id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoCreateInput = {
    id?: string
    valor: Decimal | DecimalJsLike | number | string
    metodo?: $Enums.Metodo_Pagamento
    status?: $Enums.Status_Pagamento
    createAt?: Date | string
    reserva?: ReservaCreateNestedOneWithoutPagamentoInput
  }

  export type PagamentoUncheckedCreateInput = {
    id?: string
    valor: Decimal | DecimalJsLike | number | string
    metodo?: $Enums.Metodo_Pagamento
    status?: $Enums.Status_Pagamento
    createAt?: Date | string
    reserva?: ReservaUncheckedCreateNestedOneWithoutPagamentoInput
  }

  export type PagamentoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metodo?: EnumMetodo_PagamentoFieldUpdateOperationsInput | $Enums.Metodo_Pagamento
    status?: EnumStatus_PagamentoFieldUpdateOperationsInput | $Enums.Status_Pagamento
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reserva?: ReservaUpdateOneWithoutPagamentoNestedInput
  }

  export type PagamentoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metodo?: EnumMetodo_PagamentoFieldUpdateOperationsInput | $Enums.Metodo_Pagamento
    status?: EnumStatus_PagamentoFieldUpdateOperationsInput | $Enums.Status_Pagamento
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reserva?: ReservaUncheckedUpdateOneWithoutPagamentoNestedInput
  }

  export type PagamentoCreateManyInput = {
    id?: string
    valor: Decimal | DecimalJsLike | number | string
    metodo?: $Enums.Metodo_Pagamento
    status?: $Enums.Status_Pagamento
    createAt?: Date | string
  }

  export type PagamentoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metodo?: EnumMetodo_PagamentoFieldUpdateOperationsInput | $Enums.Metodo_Pagamento
    status?: EnumStatus_PagamentoFieldUpdateOperationsInput | $Enums.Status_Pagamento
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metodo?: EnumMetodo_PagamentoFieldUpdateOperationsInput | $Enums.Metodo_Pagamento
    status?: EnumStatus_PagamentoFieldUpdateOperationsInput | $Enums.Status_Pagamento
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumTipoUsuarioFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoUsuario | EnumTipoUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.TipoUsuario[] | ListEnumTipoUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoUsuario[] | ListEnumTipoUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoUsuarioFilter<$PrismaModel> | $Enums.TipoUsuario
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ClienteNullableRelationFilter = {
    is?: ClienteWhereInput | null
    isNot?: ClienteWhereInput | null
  }

  export type ProprietarioNullableRelationFilter = {
    is?: ProprietarioWhereInput | null
    isNot?: ProprietarioWhereInput | null
  }

  export type AdminNullableRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    tipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    tipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    email?: SortOrder
    senha?: SortOrder
    tipo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumTipoUsuarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoUsuario | EnumTipoUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.TipoUsuario[] | ListEnumTipoUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoUsuario[] | ListEnumTipoUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoUsuarioWithAggregatesFilter<$PrismaModel> | $Enums.TipoUsuario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoUsuarioFilter<$PrismaModel>
    _max?: NestedEnumTipoUsuarioFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UsuarioRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type ReservaListRelationFilter = {
    every?: ReservaWhereInput
    some?: ReservaWhereInput
    none?: ReservaWhereInput
  }

  export type AvaliacaoListRelationFilter = {
    every?: AvaliacaoWhereInput
    some?: AvaliacaoWhereInput
    none?: AvaliacaoWhereInput
  }

  export type ReservaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AvaliacaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClienteCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type ClienteMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type ClienteMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type EnumNiveis_privilegioFilter<$PrismaModel = never> = {
    equals?: $Enums.Niveis_privilegio | EnumNiveis_privilegioFieldRefInput<$PrismaModel>
    in?: $Enums.Niveis_privilegio[] | ListEnumNiveis_privilegioFieldRefInput<$PrismaModel>
    notIn?: $Enums.Niveis_privilegio[] | ListEnumNiveis_privilegioFieldRefInput<$PrismaModel>
    not?: NestedEnumNiveis_privilegioFilter<$PrismaModel> | $Enums.Niveis_privilegio
  }

  export type LavanderiaListRelationFilter = {
    every?: LavanderiaWhereInput
    some?: LavanderiaWhereInput
    none?: LavanderiaWhereInput
  }

  export type RelatorioListRelationFilter = {
    every?: RelatorioWhereInput
    some?: RelatorioWhereInput
    none?: RelatorioWhereInput
  }

  export type LavanderiaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RelatorioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProprietarioCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nivel_privilegio?: SortOrder
  }

  export type ProprietarioMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nivel_privilegio?: SortOrder
  }

  export type ProprietarioMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    nivel_privilegio?: SortOrder
  }

  export type EnumNiveis_privilegioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Niveis_privilegio | EnumNiveis_privilegioFieldRefInput<$PrismaModel>
    in?: $Enums.Niveis_privilegio[] | ListEnumNiveis_privilegioFieldRefInput<$PrismaModel>
    notIn?: $Enums.Niveis_privilegio[] | ListEnumNiveis_privilegioFieldRefInput<$PrismaModel>
    not?: NestedEnumNiveis_privilegioWithAggregatesFilter<$PrismaModel> | $Enums.Niveis_privilegio
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNiveis_privilegioFilter<$PrismaModel>
    _max?: NestedEnumNiveis_privilegioFilter<$PrismaModel>
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ProprietarioRelationFilter = {
    is?: ProprietarioWhereInput
    isNot?: ProprietarioWhereInput
  }

  export type MaquinaListRelationFilter = {
    every?: MaquinaWhereInput
    some?: MaquinaWhereInput
    none?: MaquinaWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MaquinaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LavanderiaCountOrderByAggregateInput = {
    id?: SortOrder
    nomeFantasia?: SortOrder
    razaoSocial?: SortOrder
    endereco?: SortOrder
    telefone?: SortOrder
    horarioAbertura?: SortOrder
    horarioFechamento?: SortOrder
    descricao?: SortOrder
    fotoUrl?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    proprietario_id?: SortOrder
    destaque?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LavanderiaAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type LavanderiaMaxOrderByAggregateInput = {
    id?: SortOrder
    nomeFantasia?: SortOrder
    razaoSocial?: SortOrder
    endereco?: SortOrder
    telefone?: SortOrder
    horarioAbertura?: SortOrder
    horarioFechamento?: SortOrder
    descricao?: SortOrder
    fotoUrl?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    proprietario_id?: SortOrder
    destaque?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LavanderiaMinOrderByAggregateInput = {
    id?: SortOrder
    nomeFantasia?: SortOrder
    razaoSocial?: SortOrder
    endereco?: SortOrder
    telefone?: SortOrder
    horarioAbertura?: SortOrder
    horarioFechamento?: SortOrder
    descricao?: SortOrder
    fotoUrl?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    proprietario_id?: SortOrder
    destaque?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LavanderiaSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumTipo_maquinaFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_maquina | EnumTipo_maquinaFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_maquina[] | ListEnumTipo_maquinaFieldRefInput<$PrismaModel>
    notIn?: $Enums.Tipo_maquina[] | ListEnumTipo_maquinaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipo_maquinaFilter<$PrismaModel> | $Enums.Tipo_maquina
  }

  export type EnumStatus_maquinaFilter<$PrismaModel = never> = {
    equals?: $Enums.Status_maquina | EnumStatus_maquinaFieldRefInput<$PrismaModel>
    in?: $Enums.Status_maquina[] | ListEnumStatus_maquinaFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status_maquina[] | ListEnumStatus_maquinaFieldRefInput<$PrismaModel>
    not?: NestedEnumStatus_maquinaFilter<$PrismaModel> | $Enums.Status_maquina
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type LavanderiaRelationFilter = {
    is?: LavanderiaWhereInput
    isNot?: LavanderiaWhereInput
  }

  export type MaquinaCountOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    status_maquina?: SortOrder
    capacidade?: SortOrder
    preco?: SortOrder
    lavanderia_id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type MaquinaAvgOrderByAggregateInput = {
    capacidade?: SortOrder
    preco?: SortOrder
  }

  export type MaquinaMaxOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    status_maquina?: SortOrder
    capacidade?: SortOrder
    preco?: SortOrder
    lavanderia_id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type MaquinaMinOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    status_maquina?: SortOrder
    capacidade?: SortOrder
    preco?: SortOrder
    lavanderia_id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type MaquinaSumOrderByAggregateInput = {
    capacidade?: SortOrder
    preco?: SortOrder
  }

  export type EnumTipo_maquinaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_maquina | EnumTipo_maquinaFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_maquina[] | ListEnumTipo_maquinaFieldRefInput<$PrismaModel>
    notIn?: $Enums.Tipo_maquina[] | ListEnumTipo_maquinaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipo_maquinaWithAggregatesFilter<$PrismaModel> | $Enums.Tipo_maquina
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipo_maquinaFilter<$PrismaModel>
    _max?: NestedEnumTipo_maquinaFilter<$PrismaModel>
  }

  export type EnumStatus_maquinaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status_maquina | EnumStatus_maquinaFieldRefInput<$PrismaModel>
    in?: $Enums.Status_maquina[] | ListEnumStatus_maquinaFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status_maquina[] | ListEnumStatus_maquinaFieldRefInput<$PrismaModel>
    not?: NestedEnumStatus_maquinaWithAggregatesFilter<$PrismaModel> | $Enums.Status_maquina
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatus_maquinaFilter<$PrismaModel>
    _max?: NestedEnumStatus_maquinaFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type AdminRelationFilter = {
    is?: AdminWhereInput
    isNot?: AdminWhereInput
  }

  export type RelatorioCountOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    proprietario_id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type RelatorioMaxOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    proprietario_id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type RelatorioMinOrderByAggregateInput = {
    id?: SortOrder
    admin_id?: SortOrder
    proprietario_id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type EnumStatus_reservaFilter<$PrismaModel = never> = {
    equals?: $Enums.Status_reserva | EnumStatus_reservaFieldRefInput<$PrismaModel>
    in?: $Enums.Status_reserva[] | ListEnumStatus_reservaFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status_reserva[] | ListEnumStatus_reservaFieldRefInput<$PrismaModel>
    not?: NestedEnumStatus_reservaFilter<$PrismaModel> | $Enums.Status_reserva
  }

  export type ClienteRelationFilter = {
    is?: ClienteWhereInput
    isNot?: ClienteWhereInput
  }

  export type MaquinaRelationFilter = {
    is?: MaquinaWhereInput
    isNot?: MaquinaWhereInput
  }

  export type PagamentoNullableRelationFilter = {
    is?: PagamentoWhereInput | null
    isNot?: PagamentoWhereInput | null
  }

  export type ReservaCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    cliente_id?: SortOrder
    maquina_id?: SortOrder
    inicio?: SortOrder
    fim?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    pagamento_id?: SortOrder
  }

  export type ReservaMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    cliente_id?: SortOrder
    maquina_id?: SortOrder
    inicio?: SortOrder
    fim?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    pagamento_id?: SortOrder
  }

  export type ReservaMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    cliente_id?: SortOrder
    maquina_id?: SortOrder
    inicio?: SortOrder
    fim?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
    pagamento_id?: SortOrder
  }

  export type EnumStatus_reservaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status_reserva | EnumStatus_reservaFieldRefInput<$PrismaModel>
    in?: $Enums.Status_reserva[] | ListEnumStatus_reservaFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status_reserva[] | ListEnumStatus_reservaFieldRefInput<$PrismaModel>
    not?: NestedEnumStatus_reservaWithAggregatesFilter<$PrismaModel> | $Enums.Status_reserva
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatus_reservaFilter<$PrismaModel>
    _max?: NestedEnumStatus_reservaFilter<$PrismaModel>
  }

  export type AvaliacaoCountOrderByAggregateInput = {
    id?: SortOrder
    nota?: SortOrder
    comentario?: SortOrder
    cliente_id?: SortOrder
    lavanderia_id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type AvaliacaoAvgOrderByAggregateInput = {
    nota?: SortOrder
  }

  export type AvaliacaoMaxOrderByAggregateInput = {
    id?: SortOrder
    nota?: SortOrder
    comentario?: SortOrder
    cliente_id?: SortOrder
    lavanderia_id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type AvaliacaoMinOrderByAggregateInput = {
    id?: SortOrder
    nota?: SortOrder
    comentario?: SortOrder
    cliente_id?: SortOrder
    lavanderia_id?: SortOrder
    createAt?: SortOrder
    updateAt?: SortOrder
  }

  export type AvaliacaoSumOrderByAggregateInput = {
    nota?: SortOrder
  }

  export type EnumMetodo_PagamentoFilter<$PrismaModel = never> = {
    equals?: $Enums.Metodo_Pagamento | EnumMetodo_PagamentoFieldRefInput<$PrismaModel>
    in?: $Enums.Metodo_Pagamento[] | ListEnumMetodo_PagamentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Metodo_Pagamento[] | ListEnumMetodo_PagamentoFieldRefInput<$PrismaModel>
    not?: NestedEnumMetodo_PagamentoFilter<$PrismaModel> | $Enums.Metodo_Pagamento
  }

  export type EnumStatus_PagamentoFilter<$PrismaModel = never> = {
    equals?: $Enums.Status_Pagamento | EnumStatus_PagamentoFieldRefInput<$PrismaModel>
    in?: $Enums.Status_Pagamento[] | ListEnumStatus_PagamentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status_Pagamento[] | ListEnumStatus_PagamentoFieldRefInput<$PrismaModel>
    not?: NestedEnumStatus_PagamentoFilter<$PrismaModel> | $Enums.Status_Pagamento
  }

  export type ReservaNullableRelationFilter = {
    is?: ReservaWhereInput | null
    isNot?: ReservaWhereInput | null
  }

  export type PagamentoCountOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    metodo?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
  }

  export type PagamentoAvgOrderByAggregateInput = {
    valor?: SortOrder
  }

  export type PagamentoMaxOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    metodo?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
  }

  export type PagamentoMinOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    metodo?: SortOrder
    status?: SortOrder
    createAt?: SortOrder
  }

  export type PagamentoSumOrderByAggregateInput = {
    valor?: SortOrder
  }

  export type EnumMetodo_PagamentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Metodo_Pagamento | EnumMetodo_PagamentoFieldRefInput<$PrismaModel>
    in?: $Enums.Metodo_Pagamento[] | ListEnumMetodo_PagamentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Metodo_Pagamento[] | ListEnumMetodo_PagamentoFieldRefInput<$PrismaModel>
    not?: NestedEnumMetodo_PagamentoWithAggregatesFilter<$PrismaModel> | $Enums.Metodo_Pagamento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMetodo_PagamentoFilter<$PrismaModel>
    _max?: NestedEnumMetodo_PagamentoFilter<$PrismaModel>
  }

  export type EnumStatus_PagamentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status_Pagamento | EnumStatus_PagamentoFieldRefInput<$PrismaModel>
    in?: $Enums.Status_Pagamento[] | ListEnumStatus_PagamentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status_Pagamento[] | ListEnumStatus_PagamentoFieldRefInput<$PrismaModel>
    not?: NestedEnumStatus_PagamentoWithAggregatesFilter<$PrismaModel> | $Enums.Status_Pagamento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatus_PagamentoFilter<$PrismaModel>
    _max?: NestedEnumStatus_PagamentoFilter<$PrismaModel>
  }

  export type ClienteCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<ClienteCreateWithoutUsuarioInput, ClienteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutUsuarioInput
    connect?: ClienteWhereUniqueInput
  }

  export type ProprietarioCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<ProprietarioCreateWithoutUsuarioInput, ProprietarioUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: ProprietarioCreateOrConnectWithoutUsuarioInput
    connect?: ProprietarioWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<AdminCreateWithoutUsuarioInput, AdminUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUsuarioInput
    connect?: AdminWhereUniqueInput
  }

  export type ClienteUncheckedCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<ClienteCreateWithoutUsuarioInput, ClienteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutUsuarioInput
    connect?: ClienteWhereUniqueInput
  }

  export type ProprietarioUncheckedCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<ProprietarioCreateWithoutUsuarioInput, ProprietarioUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: ProprietarioCreateOrConnectWithoutUsuarioInput
    connect?: ProprietarioWhereUniqueInput
  }

  export type AdminUncheckedCreateNestedOneWithoutUsuarioInput = {
    create?: XOR<AdminCreateWithoutUsuarioInput, AdminUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUsuarioInput
    connect?: AdminWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumTipoUsuarioFieldUpdateOperationsInput = {
    set?: $Enums.TipoUsuario
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ClienteUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<ClienteCreateWithoutUsuarioInput, ClienteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutUsuarioInput
    upsert?: ClienteUpsertWithoutUsuarioInput
    disconnect?: ClienteWhereInput | boolean
    delete?: ClienteWhereInput | boolean
    connect?: ClienteWhereUniqueInput
    update?: XOR<XOR<ClienteUpdateToOneWithWhereWithoutUsuarioInput, ClienteUpdateWithoutUsuarioInput>, ClienteUncheckedUpdateWithoutUsuarioInput>
  }

  export type ProprietarioUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<ProprietarioCreateWithoutUsuarioInput, ProprietarioUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: ProprietarioCreateOrConnectWithoutUsuarioInput
    upsert?: ProprietarioUpsertWithoutUsuarioInput
    disconnect?: ProprietarioWhereInput | boolean
    delete?: ProprietarioWhereInput | boolean
    connect?: ProprietarioWhereUniqueInput
    update?: XOR<XOR<ProprietarioUpdateToOneWithWhereWithoutUsuarioInput, ProprietarioUpdateWithoutUsuarioInput>, ProprietarioUncheckedUpdateWithoutUsuarioInput>
  }

  export type AdminUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<AdminCreateWithoutUsuarioInput, AdminUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUsuarioInput
    upsert?: AdminUpsertWithoutUsuarioInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUsuarioInput, AdminUpdateWithoutUsuarioInput>, AdminUncheckedUpdateWithoutUsuarioInput>
  }

  export type ClienteUncheckedUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<ClienteCreateWithoutUsuarioInput, ClienteUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutUsuarioInput
    upsert?: ClienteUpsertWithoutUsuarioInput
    disconnect?: ClienteWhereInput | boolean
    delete?: ClienteWhereInput | boolean
    connect?: ClienteWhereUniqueInput
    update?: XOR<XOR<ClienteUpdateToOneWithWhereWithoutUsuarioInput, ClienteUpdateWithoutUsuarioInput>, ClienteUncheckedUpdateWithoutUsuarioInput>
  }

  export type ProprietarioUncheckedUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<ProprietarioCreateWithoutUsuarioInput, ProprietarioUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: ProprietarioCreateOrConnectWithoutUsuarioInput
    upsert?: ProprietarioUpsertWithoutUsuarioInput
    disconnect?: ProprietarioWhereInput | boolean
    delete?: ProprietarioWhereInput | boolean
    connect?: ProprietarioWhereUniqueInput
    update?: XOR<XOR<ProprietarioUpdateToOneWithWhereWithoutUsuarioInput, ProprietarioUpdateWithoutUsuarioInput>, ProprietarioUncheckedUpdateWithoutUsuarioInput>
  }

  export type AdminUncheckedUpdateOneWithoutUsuarioNestedInput = {
    create?: XOR<AdminCreateWithoutUsuarioInput, AdminUncheckedCreateWithoutUsuarioInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUsuarioInput
    upsert?: AdminUpsertWithoutUsuarioInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUsuarioInput, AdminUpdateWithoutUsuarioInput>, AdminUncheckedUpdateWithoutUsuarioInput>
  }

  export type UsuarioCreateNestedOneWithoutClienteInput = {
    create?: XOR<UsuarioCreateWithoutClienteInput, UsuarioUncheckedCreateWithoutClienteInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutClienteInput
    connect?: UsuarioWhereUniqueInput
  }

  export type ReservaCreateNestedManyWithoutClienteInput = {
    create?: XOR<ReservaCreateWithoutClienteInput, ReservaUncheckedCreateWithoutClienteInput> | ReservaCreateWithoutClienteInput[] | ReservaUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ReservaCreateOrConnectWithoutClienteInput | ReservaCreateOrConnectWithoutClienteInput[]
    createMany?: ReservaCreateManyClienteInputEnvelope
    connect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
  }

  export type AvaliacaoCreateNestedManyWithoutClienteInput = {
    create?: XOR<AvaliacaoCreateWithoutClienteInput, AvaliacaoUncheckedCreateWithoutClienteInput> | AvaliacaoCreateWithoutClienteInput[] | AvaliacaoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutClienteInput | AvaliacaoCreateOrConnectWithoutClienteInput[]
    createMany?: AvaliacaoCreateManyClienteInputEnvelope
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
  }

  export type ReservaUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<ReservaCreateWithoutClienteInput, ReservaUncheckedCreateWithoutClienteInput> | ReservaCreateWithoutClienteInput[] | ReservaUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ReservaCreateOrConnectWithoutClienteInput | ReservaCreateOrConnectWithoutClienteInput[]
    createMany?: ReservaCreateManyClienteInputEnvelope
    connect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
  }

  export type AvaliacaoUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<AvaliacaoCreateWithoutClienteInput, AvaliacaoUncheckedCreateWithoutClienteInput> | AvaliacaoCreateWithoutClienteInput[] | AvaliacaoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutClienteInput | AvaliacaoCreateOrConnectWithoutClienteInput[]
    createMany?: AvaliacaoCreateManyClienteInputEnvelope
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
  }

  export type UsuarioUpdateOneRequiredWithoutClienteNestedInput = {
    create?: XOR<UsuarioCreateWithoutClienteInput, UsuarioUncheckedCreateWithoutClienteInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutClienteInput
    upsert?: UsuarioUpsertWithoutClienteInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutClienteInput, UsuarioUpdateWithoutClienteInput>, UsuarioUncheckedUpdateWithoutClienteInput>
  }

  export type ReservaUpdateManyWithoutClienteNestedInput = {
    create?: XOR<ReservaCreateWithoutClienteInput, ReservaUncheckedCreateWithoutClienteInput> | ReservaCreateWithoutClienteInput[] | ReservaUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ReservaCreateOrConnectWithoutClienteInput | ReservaCreateOrConnectWithoutClienteInput[]
    upsert?: ReservaUpsertWithWhereUniqueWithoutClienteInput | ReservaUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: ReservaCreateManyClienteInputEnvelope
    set?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    disconnect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    delete?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    connect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    update?: ReservaUpdateWithWhereUniqueWithoutClienteInput | ReservaUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: ReservaUpdateManyWithWhereWithoutClienteInput | ReservaUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: ReservaScalarWhereInput | ReservaScalarWhereInput[]
  }

  export type AvaliacaoUpdateManyWithoutClienteNestedInput = {
    create?: XOR<AvaliacaoCreateWithoutClienteInput, AvaliacaoUncheckedCreateWithoutClienteInput> | AvaliacaoCreateWithoutClienteInput[] | AvaliacaoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutClienteInput | AvaliacaoCreateOrConnectWithoutClienteInput[]
    upsert?: AvaliacaoUpsertWithWhereUniqueWithoutClienteInput | AvaliacaoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: AvaliacaoCreateManyClienteInputEnvelope
    set?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    disconnect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    delete?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    update?: AvaliacaoUpdateWithWhereUniqueWithoutClienteInput | AvaliacaoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: AvaliacaoUpdateManyWithWhereWithoutClienteInput | AvaliacaoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
  }

  export type ReservaUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<ReservaCreateWithoutClienteInput, ReservaUncheckedCreateWithoutClienteInput> | ReservaCreateWithoutClienteInput[] | ReservaUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: ReservaCreateOrConnectWithoutClienteInput | ReservaCreateOrConnectWithoutClienteInput[]
    upsert?: ReservaUpsertWithWhereUniqueWithoutClienteInput | ReservaUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: ReservaCreateManyClienteInputEnvelope
    set?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    disconnect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    delete?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    connect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    update?: ReservaUpdateWithWhereUniqueWithoutClienteInput | ReservaUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: ReservaUpdateManyWithWhereWithoutClienteInput | ReservaUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: ReservaScalarWhereInput | ReservaScalarWhereInput[]
  }

  export type AvaliacaoUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<AvaliacaoCreateWithoutClienteInput, AvaliacaoUncheckedCreateWithoutClienteInput> | AvaliacaoCreateWithoutClienteInput[] | AvaliacaoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutClienteInput | AvaliacaoCreateOrConnectWithoutClienteInput[]
    upsert?: AvaliacaoUpsertWithWhereUniqueWithoutClienteInput | AvaliacaoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: AvaliacaoCreateManyClienteInputEnvelope
    set?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    disconnect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    delete?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    update?: AvaliacaoUpdateWithWhereUniqueWithoutClienteInput | AvaliacaoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: AvaliacaoUpdateManyWithWhereWithoutClienteInput | AvaliacaoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
  }

  export type UsuarioCreateNestedOneWithoutProprietarioInput = {
    create?: XOR<UsuarioCreateWithoutProprietarioInput, UsuarioUncheckedCreateWithoutProprietarioInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutProprietarioInput
    connect?: UsuarioWhereUniqueInput
  }

  export type LavanderiaCreateNestedManyWithoutProprietarioInput = {
    create?: XOR<LavanderiaCreateWithoutProprietarioInput, LavanderiaUncheckedCreateWithoutProprietarioInput> | LavanderiaCreateWithoutProprietarioInput[] | LavanderiaUncheckedCreateWithoutProprietarioInput[]
    connectOrCreate?: LavanderiaCreateOrConnectWithoutProprietarioInput | LavanderiaCreateOrConnectWithoutProprietarioInput[]
    createMany?: LavanderiaCreateManyProprietarioInputEnvelope
    connect?: LavanderiaWhereUniqueInput | LavanderiaWhereUniqueInput[]
  }

  export type RelatorioCreateNestedManyWithoutProprietarioInput = {
    create?: XOR<RelatorioCreateWithoutProprietarioInput, RelatorioUncheckedCreateWithoutProprietarioInput> | RelatorioCreateWithoutProprietarioInput[] | RelatorioUncheckedCreateWithoutProprietarioInput[]
    connectOrCreate?: RelatorioCreateOrConnectWithoutProprietarioInput | RelatorioCreateOrConnectWithoutProprietarioInput[]
    createMany?: RelatorioCreateManyProprietarioInputEnvelope
    connect?: RelatorioWhereUniqueInput | RelatorioWhereUniqueInput[]
  }

  export type LavanderiaUncheckedCreateNestedManyWithoutProprietarioInput = {
    create?: XOR<LavanderiaCreateWithoutProprietarioInput, LavanderiaUncheckedCreateWithoutProprietarioInput> | LavanderiaCreateWithoutProprietarioInput[] | LavanderiaUncheckedCreateWithoutProprietarioInput[]
    connectOrCreate?: LavanderiaCreateOrConnectWithoutProprietarioInput | LavanderiaCreateOrConnectWithoutProprietarioInput[]
    createMany?: LavanderiaCreateManyProprietarioInputEnvelope
    connect?: LavanderiaWhereUniqueInput | LavanderiaWhereUniqueInput[]
  }

  export type RelatorioUncheckedCreateNestedManyWithoutProprietarioInput = {
    create?: XOR<RelatorioCreateWithoutProprietarioInput, RelatorioUncheckedCreateWithoutProprietarioInput> | RelatorioCreateWithoutProprietarioInput[] | RelatorioUncheckedCreateWithoutProprietarioInput[]
    connectOrCreate?: RelatorioCreateOrConnectWithoutProprietarioInput | RelatorioCreateOrConnectWithoutProprietarioInput[]
    createMany?: RelatorioCreateManyProprietarioInputEnvelope
    connect?: RelatorioWhereUniqueInput | RelatorioWhereUniqueInput[]
  }

  export type EnumNiveis_privilegioFieldUpdateOperationsInput = {
    set?: $Enums.Niveis_privilegio
  }

  export type UsuarioUpdateOneRequiredWithoutProprietarioNestedInput = {
    create?: XOR<UsuarioCreateWithoutProprietarioInput, UsuarioUncheckedCreateWithoutProprietarioInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutProprietarioInput
    upsert?: UsuarioUpsertWithoutProprietarioInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutProprietarioInput, UsuarioUpdateWithoutProprietarioInput>, UsuarioUncheckedUpdateWithoutProprietarioInput>
  }

  export type LavanderiaUpdateManyWithoutProprietarioNestedInput = {
    create?: XOR<LavanderiaCreateWithoutProprietarioInput, LavanderiaUncheckedCreateWithoutProprietarioInput> | LavanderiaCreateWithoutProprietarioInput[] | LavanderiaUncheckedCreateWithoutProprietarioInput[]
    connectOrCreate?: LavanderiaCreateOrConnectWithoutProprietarioInput | LavanderiaCreateOrConnectWithoutProprietarioInput[]
    upsert?: LavanderiaUpsertWithWhereUniqueWithoutProprietarioInput | LavanderiaUpsertWithWhereUniqueWithoutProprietarioInput[]
    createMany?: LavanderiaCreateManyProprietarioInputEnvelope
    set?: LavanderiaWhereUniqueInput | LavanderiaWhereUniqueInput[]
    disconnect?: LavanderiaWhereUniqueInput | LavanderiaWhereUniqueInput[]
    delete?: LavanderiaWhereUniqueInput | LavanderiaWhereUniqueInput[]
    connect?: LavanderiaWhereUniqueInput | LavanderiaWhereUniqueInput[]
    update?: LavanderiaUpdateWithWhereUniqueWithoutProprietarioInput | LavanderiaUpdateWithWhereUniqueWithoutProprietarioInput[]
    updateMany?: LavanderiaUpdateManyWithWhereWithoutProprietarioInput | LavanderiaUpdateManyWithWhereWithoutProprietarioInput[]
    deleteMany?: LavanderiaScalarWhereInput | LavanderiaScalarWhereInput[]
  }

  export type RelatorioUpdateManyWithoutProprietarioNestedInput = {
    create?: XOR<RelatorioCreateWithoutProprietarioInput, RelatorioUncheckedCreateWithoutProprietarioInput> | RelatorioCreateWithoutProprietarioInput[] | RelatorioUncheckedCreateWithoutProprietarioInput[]
    connectOrCreate?: RelatorioCreateOrConnectWithoutProprietarioInput | RelatorioCreateOrConnectWithoutProprietarioInput[]
    upsert?: RelatorioUpsertWithWhereUniqueWithoutProprietarioInput | RelatorioUpsertWithWhereUniqueWithoutProprietarioInput[]
    createMany?: RelatorioCreateManyProprietarioInputEnvelope
    set?: RelatorioWhereUniqueInput | RelatorioWhereUniqueInput[]
    disconnect?: RelatorioWhereUniqueInput | RelatorioWhereUniqueInput[]
    delete?: RelatorioWhereUniqueInput | RelatorioWhereUniqueInput[]
    connect?: RelatorioWhereUniqueInput | RelatorioWhereUniqueInput[]
    update?: RelatorioUpdateWithWhereUniqueWithoutProprietarioInput | RelatorioUpdateWithWhereUniqueWithoutProprietarioInput[]
    updateMany?: RelatorioUpdateManyWithWhereWithoutProprietarioInput | RelatorioUpdateManyWithWhereWithoutProprietarioInput[]
    deleteMany?: RelatorioScalarWhereInput | RelatorioScalarWhereInput[]
  }

  export type LavanderiaUncheckedUpdateManyWithoutProprietarioNestedInput = {
    create?: XOR<LavanderiaCreateWithoutProprietarioInput, LavanderiaUncheckedCreateWithoutProprietarioInput> | LavanderiaCreateWithoutProprietarioInput[] | LavanderiaUncheckedCreateWithoutProprietarioInput[]
    connectOrCreate?: LavanderiaCreateOrConnectWithoutProprietarioInput | LavanderiaCreateOrConnectWithoutProprietarioInput[]
    upsert?: LavanderiaUpsertWithWhereUniqueWithoutProprietarioInput | LavanderiaUpsertWithWhereUniqueWithoutProprietarioInput[]
    createMany?: LavanderiaCreateManyProprietarioInputEnvelope
    set?: LavanderiaWhereUniqueInput | LavanderiaWhereUniqueInput[]
    disconnect?: LavanderiaWhereUniqueInput | LavanderiaWhereUniqueInput[]
    delete?: LavanderiaWhereUniqueInput | LavanderiaWhereUniqueInput[]
    connect?: LavanderiaWhereUniqueInput | LavanderiaWhereUniqueInput[]
    update?: LavanderiaUpdateWithWhereUniqueWithoutProprietarioInput | LavanderiaUpdateWithWhereUniqueWithoutProprietarioInput[]
    updateMany?: LavanderiaUpdateManyWithWhereWithoutProprietarioInput | LavanderiaUpdateManyWithWhereWithoutProprietarioInput[]
    deleteMany?: LavanderiaScalarWhereInput | LavanderiaScalarWhereInput[]
  }

  export type RelatorioUncheckedUpdateManyWithoutProprietarioNestedInput = {
    create?: XOR<RelatorioCreateWithoutProprietarioInput, RelatorioUncheckedCreateWithoutProprietarioInput> | RelatorioCreateWithoutProprietarioInput[] | RelatorioUncheckedCreateWithoutProprietarioInput[]
    connectOrCreate?: RelatorioCreateOrConnectWithoutProprietarioInput | RelatorioCreateOrConnectWithoutProprietarioInput[]
    upsert?: RelatorioUpsertWithWhereUniqueWithoutProprietarioInput | RelatorioUpsertWithWhereUniqueWithoutProprietarioInput[]
    createMany?: RelatorioCreateManyProprietarioInputEnvelope
    set?: RelatorioWhereUniqueInput | RelatorioWhereUniqueInput[]
    disconnect?: RelatorioWhereUniqueInput | RelatorioWhereUniqueInput[]
    delete?: RelatorioWhereUniqueInput | RelatorioWhereUniqueInput[]
    connect?: RelatorioWhereUniqueInput | RelatorioWhereUniqueInput[]
    update?: RelatorioUpdateWithWhereUniqueWithoutProprietarioInput | RelatorioUpdateWithWhereUniqueWithoutProprietarioInput[]
    updateMany?: RelatorioUpdateManyWithWhereWithoutProprietarioInput | RelatorioUpdateManyWithWhereWithoutProprietarioInput[]
    deleteMany?: RelatorioScalarWhereInput | RelatorioScalarWhereInput[]
  }

  export type UsuarioCreateNestedOneWithoutAdminInput = {
    create?: XOR<UsuarioCreateWithoutAdminInput, UsuarioUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutAdminInput
    connect?: UsuarioWhereUniqueInput
  }

  export type RelatorioCreateNestedManyWithoutAdminInput = {
    create?: XOR<RelatorioCreateWithoutAdminInput, RelatorioUncheckedCreateWithoutAdminInput> | RelatorioCreateWithoutAdminInput[] | RelatorioUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: RelatorioCreateOrConnectWithoutAdminInput | RelatorioCreateOrConnectWithoutAdminInput[]
    createMany?: RelatorioCreateManyAdminInputEnvelope
    connect?: RelatorioWhereUniqueInput | RelatorioWhereUniqueInput[]
  }

  export type RelatorioUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<RelatorioCreateWithoutAdminInput, RelatorioUncheckedCreateWithoutAdminInput> | RelatorioCreateWithoutAdminInput[] | RelatorioUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: RelatorioCreateOrConnectWithoutAdminInput | RelatorioCreateOrConnectWithoutAdminInput[]
    createMany?: RelatorioCreateManyAdminInputEnvelope
    connect?: RelatorioWhereUniqueInput | RelatorioWhereUniqueInput[]
  }

  export type UsuarioUpdateOneRequiredWithoutAdminNestedInput = {
    create?: XOR<UsuarioCreateWithoutAdminInput, UsuarioUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutAdminInput
    upsert?: UsuarioUpsertWithoutAdminInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutAdminInput, UsuarioUpdateWithoutAdminInput>, UsuarioUncheckedUpdateWithoutAdminInput>
  }

  export type RelatorioUpdateManyWithoutAdminNestedInput = {
    create?: XOR<RelatorioCreateWithoutAdminInput, RelatorioUncheckedCreateWithoutAdminInput> | RelatorioCreateWithoutAdminInput[] | RelatorioUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: RelatorioCreateOrConnectWithoutAdminInput | RelatorioCreateOrConnectWithoutAdminInput[]
    upsert?: RelatorioUpsertWithWhereUniqueWithoutAdminInput | RelatorioUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: RelatorioCreateManyAdminInputEnvelope
    set?: RelatorioWhereUniqueInput | RelatorioWhereUniqueInput[]
    disconnect?: RelatorioWhereUniqueInput | RelatorioWhereUniqueInput[]
    delete?: RelatorioWhereUniqueInput | RelatorioWhereUniqueInput[]
    connect?: RelatorioWhereUniqueInput | RelatorioWhereUniqueInput[]
    update?: RelatorioUpdateWithWhereUniqueWithoutAdminInput | RelatorioUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: RelatorioUpdateManyWithWhereWithoutAdminInput | RelatorioUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: RelatorioScalarWhereInput | RelatorioScalarWhereInput[]
  }

  export type RelatorioUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<RelatorioCreateWithoutAdminInput, RelatorioUncheckedCreateWithoutAdminInput> | RelatorioCreateWithoutAdminInput[] | RelatorioUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: RelatorioCreateOrConnectWithoutAdminInput | RelatorioCreateOrConnectWithoutAdminInput[]
    upsert?: RelatorioUpsertWithWhereUniqueWithoutAdminInput | RelatorioUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: RelatorioCreateManyAdminInputEnvelope
    set?: RelatorioWhereUniqueInput | RelatorioWhereUniqueInput[]
    disconnect?: RelatorioWhereUniqueInput | RelatorioWhereUniqueInput[]
    delete?: RelatorioWhereUniqueInput | RelatorioWhereUniqueInput[]
    connect?: RelatorioWhereUniqueInput | RelatorioWhereUniqueInput[]
    update?: RelatorioUpdateWithWhereUniqueWithoutAdminInput | RelatorioUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: RelatorioUpdateManyWithWhereWithoutAdminInput | RelatorioUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: RelatorioScalarWhereInput | RelatorioScalarWhereInput[]
  }

  export type ProprietarioCreateNestedOneWithoutLavanderiasInput = {
    create?: XOR<ProprietarioCreateWithoutLavanderiasInput, ProprietarioUncheckedCreateWithoutLavanderiasInput>
    connectOrCreate?: ProprietarioCreateOrConnectWithoutLavanderiasInput
    connect?: ProprietarioWhereUniqueInput
  }

  export type MaquinaCreateNestedManyWithoutLavanderiaInput = {
    create?: XOR<MaquinaCreateWithoutLavanderiaInput, MaquinaUncheckedCreateWithoutLavanderiaInput> | MaquinaCreateWithoutLavanderiaInput[] | MaquinaUncheckedCreateWithoutLavanderiaInput[]
    connectOrCreate?: MaquinaCreateOrConnectWithoutLavanderiaInput | MaquinaCreateOrConnectWithoutLavanderiaInput[]
    createMany?: MaquinaCreateManyLavanderiaInputEnvelope
    connect?: MaquinaWhereUniqueInput | MaquinaWhereUniqueInput[]
  }

  export type AvaliacaoCreateNestedManyWithoutLavanderiaInput = {
    create?: XOR<AvaliacaoCreateWithoutLavanderiaInput, AvaliacaoUncheckedCreateWithoutLavanderiaInput> | AvaliacaoCreateWithoutLavanderiaInput[] | AvaliacaoUncheckedCreateWithoutLavanderiaInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutLavanderiaInput | AvaliacaoCreateOrConnectWithoutLavanderiaInput[]
    createMany?: AvaliacaoCreateManyLavanderiaInputEnvelope
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
  }

  export type MaquinaUncheckedCreateNestedManyWithoutLavanderiaInput = {
    create?: XOR<MaquinaCreateWithoutLavanderiaInput, MaquinaUncheckedCreateWithoutLavanderiaInput> | MaquinaCreateWithoutLavanderiaInput[] | MaquinaUncheckedCreateWithoutLavanderiaInput[]
    connectOrCreate?: MaquinaCreateOrConnectWithoutLavanderiaInput | MaquinaCreateOrConnectWithoutLavanderiaInput[]
    createMany?: MaquinaCreateManyLavanderiaInputEnvelope
    connect?: MaquinaWhereUniqueInput | MaquinaWhereUniqueInput[]
  }

  export type AvaliacaoUncheckedCreateNestedManyWithoutLavanderiaInput = {
    create?: XOR<AvaliacaoCreateWithoutLavanderiaInput, AvaliacaoUncheckedCreateWithoutLavanderiaInput> | AvaliacaoCreateWithoutLavanderiaInput[] | AvaliacaoUncheckedCreateWithoutLavanderiaInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutLavanderiaInput | AvaliacaoCreateOrConnectWithoutLavanderiaInput[]
    createMany?: AvaliacaoCreateManyLavanderiaInputEnvelope
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ProprietarioUpdateOneRequiredWithoutLavanderiasNestedInput = {
    create?: XOR<ProprietarioCreateWithoutLavanderiasInput, ProprietarioUncheckedCreateWithoutLavanderiasInput>
    connectOrCreate?: ProprietarioCreateOrConnectWithoutLavanderiasInput
    upsert?: ProprietarioUpsertWithoutLavanderiasInput
    connect?: ProprietarioWhereUniqueInput
    update?: XOR<XOR<ProprietarioUpdateToOneWithWhereWithoutLavanderiasInput, ProprietarioUpdateWithoutLavanderiasInput>, ProprietarioUncheckedUpdateWithoutLavanderiasInput>
  }

  export type MaquinaUpdateManyWithoutLavanderiaNestedInput = {
    create?: XOR<MaquinaCreateWithoutLavanderiaInput, MaquinaUncheckedCreateWithoutLavanderiaInput> | MaquinaCreateWithoutLavanderiaInput[] | MaquinaUncheckedCreateWithoutLavanderiaInput[]
    connectOrCreate?: MaquinaCreateOrConnectWithoutLavanderiaInput | MaquinaCreateOrConnectWithoutLavanderiaInput[]
    upsert?: MaquinaUpsertWithWhereUniqueWithoutLavanderiaInput | MaquinaUpsertWithWhereUniqueWithoutLavanderiaInput[]
    createMany?: MaquinaCreateManyLavanderiaInputEnvelope
    set?: MaquinaWhereUniqueInput | MaquinaWhereUniqueInput[]
    disconnect?: MaquinaWhereUniqueInput | MaquinaWhereUniqueInput[]
    delete?: MaquinaWhereUniqueInput | MaquinaWhereUniqueInput[]
    connect?: MaquinaWhereUniqueInput | MaquinaWhereUniqueInput[]
    update?: MaquinaUpdateWithWhereUniqueWithoutLavanderiaInput | MaquinaUpdateWithWhereUniqueWithoutLavanderiaInput[]
    updateMany?: MaquinaUpdateManyWithWhereWithoutLavanderiaInput | MaquinaUpdateManyWithWhereWithoutLavanderiaInput[]
    deleteMany?: MaquinaScalarWhereInput | MaquinaScalarWhereInput[]
  }

  export type AvaliacaoUpdateManyWithoutLavanderiaNestedInput = {
    create?: XOR<AvaliacaoCreateWithoutLavanderiaInput, AvaliacaoUncheckedCreateWithoutLavanderiaInput> | AvaliacaoCreateWithoutLavanderiaInput[] | AvaliacaoUncheckedCreateWithoutLavanderiaInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutLavanderiaInput | AvaliacaoCreateOrConnectWithoutLavanderiaInput[]
    upsert?: AvaliacaoUpsertWithWhereUniqueWithoutLavanderiaInput | AvaliacaoUpsertWithWhereUniqueWithoutLavanderiaInput[]
    createMany?: AvaliacaoCreateManyLavanderiaInputEnvelope
    set?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    disconnect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    delete?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    update?: AvaliacaoUpdateWithWhereUniqueWithoutLavanderiaInput | AvaliacaoUpdateWithWhereUniqueWithoutLavanderiaInput[]
    updateMany?: AvaliacaoUpdateManyWithWhereWithoutLavanderiaInput | AvaliacaoUpdateManyWithWhereWithoutLavanderiaInput[]
    deleteMany?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
  }

  export type MaquinaUncheckedUpdateManyWithoutLavanderiaNestedInput = {
    create?: XOR<MaquinaCreateWithoutLavanderiaInput, MaquinaUncheckedCreateWithoutLavanderiaInput> | MaquinaCreateWithoutLavanderiaInput[] | MaquinaUncheckedCreateWithoutLavanderiaInput[]
    connectOrCreate?: MaquinaCreateOrConnectWithoutLavanderiaInput | MaquinaCreateOrConnectWithoutLavanderiaInput[]
    upsert?: MaquinaUpsertWithWhereUniqueWithoutLavanderiaInput | MaquinaUpsertWithWhereUniqueWithoutLavanderiaInput[]
    createMany?: MaquinaCreateManyLavanderiaInputEnvelope
    set?: MaquinaWhereUniqueInput | MaquinaWhereUniqueInput[]
    disconnect?: MaquinaWhereUniqueInput | MaquinaWhereUniqueInput[]
    delete?: MaquinaWhereUniqueInput | MaquinaWhereUniqueInput[]
    connect?: MaquinaWhereUniqueInput | MaquinaWhereUniqueInput[]
    update?: MaquinaUpdateWithWhereUniqueWithoutLavanderiaInput | MaquinaUpdateWithWhereUniqueWithoutLavanderiaInput[]
    updateMany?: MaquinaUpdateManyWithWhereWithoutLavanderiaInput | MaquinaUpdateManyWithWhereWithoutLavanderiaInput[]
    deleteMany?: MaquinaScalarWhereInput | MaquinaScalarWhereInput[]
  }

  export type AvaliacaoUncheckedUpdateManyWithoutLavanderiaNestedInput = {
    create?: XOR<AvaliacaoCreateWithoutLavanderiaInput, AvaliacaoUncheckedCreateWithoutLavanderiaInput> | AvaliacaoCreateWithoutLavanderiaInput[] | AvaliacaoUncheckedCreateWithoutLavanderiaInput[]
    connectOrCreate?: AvaliacaoCreateOrConnectWithoutLavanderiaInput | AvaliacaoCreateOrConnectWithoutLavanderiaInput[]
    upsert?: AvaliacaoUpsertWithWhereUniqueWithoutLavanderiaInput | AvaliacaoUpsertWithWhereUniqueWithoutLavanderiaInput[]
    createMany?: AvaliacaoCreateManyLavanderiaInputEnvelope
    set?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    disconnect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    delete?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    connect?: AvaliacaoWhereUniqueInput | AvaliacaoWhereUniqueInput[]
    update?: AvaliacaoUpdateWithWhereUniqueWithoutLavanderiaInput | AvaliacaoUpdateWithWhereUniqueWithoutLavanderiaInput[]
    updateMany?: AvaliacaoUpdateManyWithWhereWithoutLavanderiaInput | AvaliacaoUpdateManyWithWhereWithoutLavanderiaInput[]
    deleteMany?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
  }

  export type LavanderiaCreateNestedOneWithoutMaquinasInput = {
    create?: XOR<LavanderiaCreateWithoutMaquinasInput, LavanderiaUncheckedCreateWithoutMaquinasInput>
    connectOrCreate?: LavanderiaCreateOrConnectWithoutMaquinasInput
    connect?: LavanderiaWhereUniqueInput
  }

  export type ReservaCreateNestedManyWithoutMaquinaInput = {
    create?: XOR<ReservaCreateWithoutMaquinaInput, ReservaUncheckedCreateWithoutMaquinaInput> | ReservaCreateWithoutMaquinaInput[] | ReservaUncheckedCreateWithoutMaquinaInput[]
    connectOrCreate?: ReservaCreateOrConnectWithoutMaquinaInput | ReservaCreateOrConnectWithoutMaquinaInput[]
    createMany?: ReservaCreateManyMaquinaInputEnvelope
    connect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
  }

  export type ReservaUncheckedCreateNestedManyWithoutMaquinaInput = {
    create?: XOR<ReservaCreateWithoutMaquinaInput, ReservaUncheckedCreateWithoutMaquinaInput> | ReservaCreateWithoutMaquinaInput[] | ReservaUncheckedCreateWithoutMaquinaInput[]
    connectOrCreate?: ReservaCreateOrConnectWithoutMaquinaInput | ReservaCreateOrConnectWithoutMaquinaInput[]
    createMany?: ReservaCreateManyMaquinaInputEnvelope
    connect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
  }

  export type EnumTipo_maquinaFieldUpdateOperationsInput = {
    set?: $Enums.Tipo_maquina
  }

  export type EnumStatus_maquinaFieldUpdateOperationsInput = {
    set?: $Enums.Status_maquina
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type LavanderiaUpdateOneRequiredWithoutMaquinasNestedInput = {
    create?: XOR<LavanderiaCreateWithoutMaquinasInput, LavanderiaUncheckedCreateWithoutMaquinasInput>
    connectOrCreate?: LavanderiaCreateOrConnectWithoutMaquinasInput
    upsert?: LavanderiaUpsertWithoutMaquinasInput
    connect?: LavanderiaWhereUniqueInput
    update?: XOR<XOR<LavanderiaUpdateToOneWithWhereWithoutMaquinasInput, LavanderiaUpdateWithoutMaquinasInput>, LavanderiaUncheckedUpdateWithoutMaquinasInput>
  }

  export type ReservaUpdateManyWithoutMaquinaNestedInput = {
    create?: XOR<ReservaCreateWithoutMaquinaInput, ReservaUncheckedCreateWithoutMaquinaInput> | ReservaCreateWithoutMaquinaInput[] | ReservaUncheckedCreateWithoutMaquinaInput[]
    connectOrCreate?: ReservaCreateOrConnectWithoutMaquinaInput | ReservaCreateOrConnectWithoutMaquinaInput[]
    upsert?: ReservaUpsertWithWhereUniqueWithoutMaquinaInput | ReservaUpsertWithWhereUniqueWithoutMaquinaInput[]
    createMany?: ReservaCreateManyMaquinaInputEnvelope
    set?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    disconnect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    delete?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    connect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    update?: ReservaUpdateWithWhereUniqueWithoutMaquinaInput | ReservaUpdateWithWhereUniqueWithoutMaquinaInput[]
    updateMany?: ReservaUpdateManyWithWhereWithoutMaquinaInput | ReservaUpdateManyWithWhereWithoutMaquinaInput[]
    deleteMany?: ReservaScalarWhereInput | ReservaScalarWhereInput[]
  }

  export type ReservaUncheckedUpdateManyWithoutMaquinaNestedInput = {
    create?: XOR<ReservaCreateWithoutMaquinaInput, ReservaUncheckedCreateWithoutMaquinaInput> | ReservaCreateWithoutMaquinaInput[] | ReservaUncheckedCreateWithoutMaquinaInput[]
    connectOrCreate?: ReservaCreateOrConnectWithoutMaquinaInput | ReservaCreateOrConnectWithoutMaquinaInput[]
    upsert?: ReservaUpsertWithWhereUniqueWithoutMaquinaInput | ReservaUpsertWithWhereUniqueWithoutMaquinaInput[]
    createMany?: ReservaCreateManyMaquinaInputEnvelope
    set?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    disconnect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    delete?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    connect?: ReservaWhereUniqueInput | ReservaWhereUniqueInput[]
    update?: ReservaUpdateWithWhereUniqueWithoutMaquinaInput | ReservaUpdateWithWhereUniqueWithoutMaquinaInput[]
    updateMany?: ReservaUpdateManyWithWhereWithoutMaquinaInput | ReservaUpdateManyWithWhereWithoutMaquinaInput[]
    deleteMany?: ReservaScalarWhereInput | ReservaScalarWhereInput[]
  }

  export type AdminCreateNestedOneWithoutRelatoriosInput = {
    create?: XOR<AdminCreateWithoutRelatoriosInput, AdminUncheckedCreateWithoutRelatoriosInput>
    connectOrCreate?: AdminCreateOrConnectWithoutRelatoriosInput
    connect?: AdminWhereUniqueInput
  }

  export type ProprietarioCreateNestedOneWithoutRelatoriosInput = {
    create?: XOR<ProprietarioCreateWithoutRelatoriosInput, ProprietarioUncheckedCreateWithoutRelatoriosInput>
    connectOrCreate?: ProprietarioCreateOrConnectWithoutRelatoriosInput
    connect?: ProprietarioWhereUniqueInput
  }

  export type AdminUpdateOneRequiredWithoutRelatoriosNestedInput = {
    create?: XOR<AdminCreateWithoutRelatoriosInput, AdminUncheckedCreateWithoutRelatoriosInput>
    connectOrCreate?: AdminCreateOrConnectWithoutRelatoriosInput
    upsert?: AdminUpsertWithoutRelatoriosInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutRelatoriosInput, AdminUpdateWithoutRelatoriosInput>, AdminUncheckedUpdateWithoutRelatoriosInput>
  }

  export type ProprietarioUpdateOneRequiredWithoutRelatoriosNestedInput = {
    create?: XOR<ProprietarioCreateWithoutRelatoriosInput, ProprietarioUncheckedCreateWithoutRelatoriosInput>
    connectOrCreate?: ProprietarioCreateOrConnectWithoutRelatoriosInput
    upsert?: ProprietarioUpsertWithoutRelatoriosInput
    connect?: ProprietarioWhereUniqueInput
    update?: XOR<XOR<ProprietarioUpdateToOneWithWhereWithoutRelatoriosInput, ProprietarioUpdateWithoutRelatoriosInput>, ProprietarioUncheckedUpdateWithoutRelatoriosInput>
  }

  export type ClienteCreateNestedOneWithoutReservasInput = {
    create?: XOR<ClienteCreateWithoutReservasInput, ClienteUncheckedCreateWithoutReservasInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutReservasInput
    connect?: ClienteWhereUniqueInput
  }

  export type MaquinaCreateNestedOneWithoutReservasInput = {
    create?: XOR<MaquinaCreateWithoutReservasInput, MaquinaUncheckedCreateWithoutReservasInput>
    connectOrCreate?: MaquinaCreateOrConnectWithoutReservasInput
    connect?: MaquinaWhereUniqueInput
  }

  export type PagamentoCreateNestedOneWithoutReservaInput = {
    create?: XOR<PagamentoCreateWithoutReservaInput, PagamentoUncheckedCreateWithoutReservaInput>
    connectOrCreate?: PagamentoCreateOrConnectWithoutReservaInput
    connect?: PagamentoWhereUniqueInput
  }

  export type EnumStatus_reservaFieldUpdateOperationsInput = {
    set?: $Enums.Status_reserva
  }

  export type ClienteUpdateOneRequiredWithoutReservasNestedInput = {
    create?: XOR<ClienteCreateWithoutReservasInput, ClienteUncheckedCreateWithoutReservasInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutReservasInput
    upsert?: ClienteUpsertWithoutReservasInput
    connect?: ClienteWhereUniqueInput
    update?: XOR<XOR<ClienteUpdateToOneWithWhereWithoutReservasInput, ClienteUpdateWithoutReservasInput>, ClienteUncheckedUpdateWithoutReservasInput>
  }

  export type MaquinaUpdateOneRequiredWithoutReservasNestedInput = {
    create?: XOR<MaquinaCreateWithoutReservasInput, MaquinaUncheckedCreateWithoutReservasInput>
    connectOrCreate?: MaquinaCreateOrConnectWithoutReservasInput
    upsert?: MaquinaUpsertWithoutReservasInput
    connect?: MaquinaWhereUniqueInput
    update?: XOR<XOR<MaquinaUpdateToOneWithWhereWithoutReservasInput, MaquinaUpdateWithoutReservasInput>, MaquinaUncheckedUpdateWithoutReservasInput>
  }

  export type PagamentoUpdateOneWithoutReservaNestedInput = {
    create?: XOR<PagamentoCreateWithoutReservaInput, PagamentoUncheckedCreateWithoutReservaInput>
    connectOrCreate?: PagamentoCreateOrConnectWithoutReservaInput
    upsert?: PagamentoUpsertWithoutReservaInput
    disconnect?: PagamentoWhereInput | boolean
    delete?: PagamentoWhereInput | boolean
    connect?: PagamentoWhereUniqueInput
    update?: XOR<XOR<PagamentoUpdateToOneWithWhereWithoutReservaInput, PagamentoUpdateWithoutReservaInput>, PagamentoUncheckedUpdateWithoutReservaInput>
  }

  export type ClienteCreateNestedOneWithoutAvaliacoesInput = {
    create?: XOR<ClienteCreateWithoutAvaliacoesInput, ClienteUncheckedCreateWithoutAvaliacoesInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutAvaliacoesInput
    connect?: ClienteWhereUniqueInput
  }

  export type LavanderiaCreateNestedOneWithoutAvaliacoesInput = {
    create?: XOR<LavanderiaCreateWithoutAvaliacoesInput, LavanderiaUncheckedCreateWithoutAvaliacoesInput>
    connectOrCreate?: LavanderiaCreateOrConnectWithoutAvaliacoesInput
    connect?: LavanderiaWhereUniqueInput
  }

  export type ClienteUpdateOneRequiredWithoutAvaliacoesNestedInput = {
    create?: XOR<ClienteCreateWithoutAvaliacoesInput, ClienteUncheckedCreateWithoutAvaliacoesInput>
    connectOrCreate?: ClienteCreateOrConnectWithoutAvaliacoesInput
    upsert?: ClienteUpsertWithoutAvaliacoesInput
    connect?: ClienteWhereUniqueInput
    update?: XOR<XOR<ClienteUpdateToOneWithWhereWithoutAvaliacoesInput, ClienteUpdateWithoutAvaliacoesInput>, ClienteUncheckedUpdateWithoutAvaliacoesInput>
  }

  export type LavanderiaUpdateOneRequiredWithoutAvaliacoesNestedInput = {
    create?: XOR<LavanderiaCreateWithoutAvaliacoesInput, LavanderiaUncheckedCreateWithoutAvaliacoesInput>
    connectOrCreate?: LavanderiaCreateOrConnectWithoutAvaliacoesInput
    upsert?: LavanderiaUpsertWithoutAvaliacoesInput
    connect?: LavanderiaWhereUniqueInput
    update?: XOR<XOR<LavanderiaUpdateToOneWithWhereWithoutAvaliacoesInput, LavanderiaUpdateWithoutAvaliacoesInput>, LavanderiaUncheckedUpdateWithoutAvaliacoesInput>
  }

  export type ReservaCreateNestedOneWithoutPagamentoInput = {
    create?: XOR<ReservaCreateWithoutPagamentoInput, ReservaUncheckedCreateWithoutPagamentoInput>
    connectOrCreate?: ReservaCreateOrConnectWithoutPagamentoInput
    connect?: ReservaWhereUniqueInput
  }

  export type ReservaUncheckedCreateNestedOneWithoutPagamentoInput = {
    create?: XOR<ReservaCreateWithoutPagamentoInput, ReservaUncheckedCreateWithoutPagamentoInput>
    connectOrCreate?: ReservaCreateOrConnectWithoutPagamentoInput
    connect?: ReservaWhereUniqueInput
  }

  export type EnumMetodo_PagamentoFieldUpdateOperationsInput = {
    set?: $Enums.Metodo_Pagamento
  }

  export type EnumStatus_PagamentoFieldUpdateOperationsInput = {
    set?: $Enums.Status_Pagamento
  }

  export type ReservaUpdateOneWithoutPagamentoNestedInput = {
    create?: XOR<ReservaCreateWithoutPagamentoInput, ReservaUncheckedCreateWithoutPagamentoInput>
    connectOrCreate?: ReservaCreateOrConnectWithoutPagamentoInput
    upsert?: ReservaUpsertWithoutPagamentoInput
    disconnect?: ReservaWhereInput | boolean
    delete?: ReservaWhereInput | boolean
    connect?: ReservaWhereUniqueInput
    update?: XOR<XOR<ReservaUpdateToOneWithWhereWithoutPagamentoInput, ReservaUpdateWithoutPagamentoInput>, ReservaUncheckedUpdateWithoutPagamentoInput>
  }

  export type ReservaUncheckedUpdateOneWithoutPagamentoNestedInput = {
    create?: XOR<ReservaCreateWithoutPagamentoInput, ReservaUncheckedCreateWithoutPagamentoInput>
    connectOrCreate?: ReservaCreateOrConnectWithoutPagamentoInput
    upsert?: ReservaUpsertWithoutPagamentoInput
    disconnect?: ReservaWhereInput | boolean
    delete?: ReservaWhereInput | boolean
    connect?: ReservaWhereUniqueInput
    update?: XOR<XOR<ReservaUpdateToOneWithWhereWithoutPagamentoInput, ReservaUpdateWithoutPagamentoInput>, ReservaUncheckedUpdateWithoutPagamentoInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumTipoUsuarioFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoUsuario | EnumTipoUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.TipoUsuario[] | ListEnumTipoUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoUsuario[] | ListEnumTipoUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoUsuarioFilter<$PrismaModel> | $Enums.TipoUsuario
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumTipoUsuarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoUsuario | EnumTipoUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.TipoUsuario[] | ListEnumTipoUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoUsuario[] | ListEnumTipoUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoUsuarioWithAggregatesFilter<$PrismaModel> | $Enums.TipoUsuario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoUsuarioFilter<$PrismaModel>
    _max?: NestedEnumTipoUsuarioFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumNiveis_privilegioFilter<$PrismaModel = never> = {
    equals?: $Enums.Niveis_privilegio | EnumNiveis_privilegioFieldRefInput<$PrismaModel>
    in?: $Enums.Niveis_privilegio[] | ListEnumNiveis_privilegioFieldRefInput<$PrismaModel>
    notIn?: $Enums.Niveis_privilegio[] | ListEnumNiveis_privilegioFieldRefInput<$PrismaModel>
    not?: NestedEnumNiveis_privilegioFilter<$PrismaModel> | $Enums.Niveis_privilegio
  }

  export type NestedEnumNiveis_privilegioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Niveis_privilegio | EnumNiveis_privilegioFieldRefInput<$PrismaModel>
    in?: $Enums.Niveis_privilegio[] | ListEnumNiveis_privilegioFieldRefInput<$PrismaModel>
    notIn?: $Enums.Niveis_privilegio[] | ListEnumNiveis_privilegioFieldRefInput<$PrismaModel>
    not?: NestedEnumNiveis_privilegioWithAggregatesFilter<$PrismaModel> | $Enums.Niveis_privilegio
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNiveis_privilegioFilter<$PrismaModel>
    _max?: NestedEnumNiveis_privilegioFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumTipo_maquinaFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_maquina | EnumTipo_maquinaFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_maquina[] | ListEnumTipo_maquinaFieldRefInput<$PrismaModel>
    notIn?: $Enums.Tipo_maquina[] | ListEnumTipo_maquinaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipo_maquinaFilter<$PrismaModel> | $Enums.Tipo_maquina
  }

  export type NestedEnumStatus_maquinaFilter<$PrismaModel = never> = {
    equals?: $Enums.Status_maquina | EnumStatus_maquinaFieldRefInput<$PrismaModel>
    in?: $Enums.Status_maquina[] | ListEnumStatus_maquinaFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status_maquina[] | ListEnumStatus_maquinaFieldRefInput<$PrismaModel>
    not?: NestedEnumStatus_maquinaFilter<$PrismaModel> | $Enums.Status_maquina
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumTipo_maquinaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tipo_maquina | EnumTipo_maquinaFieldRefInput<$PrismaModel>
    in?: $Enums.Tipo_maquina[] | ListEnumTipo_maquinaFieldRefInput<$PrismaModel>
    notIn?: $Enums.Tipo_maquina[] | ListEnumTipo_maquinaFieldRefInput<$PrismaModel>
    not?: NestedEnumTipo_maquinaWithAggregatesFilter<$PrismaModel> | $Enums.Tipo_maquina
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipo_maquinaFilter<$PrismaModel>
    _max?: NestedEnumTipo_maquinaFilter<$PrismaModel>
  }

  export type NestedEnumStatus_maquinaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status_maquina | EnumStatus_maquinaFieldRefInput<$PrismaModel>
    in?: $Enums.Status_maquina[] | ListEnumStatus_maquinaFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status_maquina[] | ListEnumStatus_maquinaFieldRefInput<$PrismaModel>
    not?: NestedEnumStatus_maquinaWithAggregatesFilter<$PrismaModel> | $Enums.Status_maquina
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatus_maquinaFilter<$PrismaModel>
    _max?: NestedEnumStatus_maquinaFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumStatus_reservaFilter<$PrismaModel = never> = {
    equals?: $Enums.Status_reserva | EnumStatus_reservaFieldRefInput<$PrismaModel>
    in?: $Enums.Status_reserva[] | ListEnumStatus_reservaFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status_reserva[] | ListEnumStatus_reservaFieldRefInput<$PrismaModel>
    not?: NestedEnumStatus_reservaFilter<$PrismaModel> | $Enums.Status_reserva
  }

  export type NestedEnumStatus_reservaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status_reserva | EnumStatus_reservaFieldRefInput<$PrismaModel>
    in?: $Enums.Status_reserva[] | ListEnumStatus_reservaFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status_reserva[] | ListEnumStatus_reservaFieldRefInput<$PrismaModel>
    not?: NestedEnumStatus_reservaWithAggregatesFilter<$PrismaModel> | $Enums.Status_reserva
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatus_reservaFilter<$PrismaModel>
    _max?: NestedEnumStatus_reservaFilter<$PrismaModel>
  }

  export type NestedEnumMetodo_PagamentoFilter<$PrismaModel = never> = {
    equals?: $Enums.Metodo_Pagamento | EnumMetodo_PagamentoFieldRefInput<$PrismaModel>
    in?: $Enums.Metodo_Pagamento[] | ListEnumMetodo_PagamentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Metodo_Pagamento[] | ListEnumMetodo_PagamentoFieldRefInput<$PrismaModel>
    not?: NestedEnumMetodo_PagamentoFilter<$PrismaModel> | $Enums.Metodo_Pagamento
  }

  export type NestedEnumStatus_PagamentoFilter<$PrismaModel = never> = {
    equals?: $Enums.Status_Pagamento | EnumStatus_PagamentoFieldRefInput<$PrismaModel>
    in?: $Enums.Status_Pagamento[] | ListEnumStatus_PagamentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status_Pagamento[] | ListEnumStatus_PagamentoFieldRefInput<$PrismaModel>
    not?: NestedEnumStatus_PagamentoFilter<$PrismaModel> | $Enums.Status_Pagamento
  }

  export type NestedEnumMetodo_PagamentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Metodo_Pagamento | EnumMetodo_PagamentoFieldRefInput<$PrismaModel>
    in?: $Enums.Metodo_Pagamento[] | ListEnumMetodo_PagamentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Metodo_Pagamento[] | ListEnumMetodo_PagamentoFieldRefInput<$PrismaModel>
    not?: NestedEnumMetodo_PagamentoWithAggregatesFilter<$PrismaModel> | $Enums.Metodo_Pagamento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMetodo_PagamentoFilter<$PrismaModel>
    _max?: NestedEnumMetodo_PagamentoFilter<$PrismaModel>
  }

  export type NestedEnumStatus_PagamentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status_Pagamento | EnumStatus_PagamentoFieldRefInput<$PrismaModel>
    in?: $Enums.Status_Pagamento[] | ListEnumStatus_PagamentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status_Pagamento[] | ListEnumStatus_PagamentoFieldRefInput<$PrismaModel>
    not?: NestedEnumStatus_PagamentoWithAggregatesFilter<$PrismaModel> | $Enums.Status_Pagamento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatus_PagamentoFilter<$PrismaModel>
    _max?: NestedEnumStatus_PagamentoFilter<$PrismaModel>
  }

  export type ClienteCreateWithoutUsuarioInput = {
    id?: string
    reservas?: ReservaCreateNestedManyWithoutClienteInput
    avaliacoes?: AvaliacaoCreateNestedManyWithoutClienteInput
  }

  export type ClienteUncheckedCreateWithoutUsuarioInput = {
    id?: string
    reservas?: ReservaUncheckedCreateNestedManyWithoutClienteInput
    avaliacoes?: AvaliacaoUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteCreateOrConnectWithoutUsuarioInput = {
    where: ClienteWhereUniqueInput
    create: XOR<ClienteCreateWithoutUsuarioInput, ClienteUncheckedCreateWithoutUsuarioInput>
  }

  export type ProprietarioCreateWithoutUsuarioInput = {
    id?: string
    nivel_privilegio?: $Enums.Niveis_privilegio
    lavanderias?: LavanderiaCreateNestedManyWithoutProprietarioInput
    Relatorios?: RelatorioCreateNestedManyWithoutProprietarioInput
  }

  export type ProprietarioUncheckedCreateWithoutUsuarioInput = {
    id?: string
    nivel_privilegio?: $Enums.Niveis_privilegio
    lavanderias?: LavanderiaUncheckedCreateNestedManyWithoutProprietarioInput
    Relatorios?: RelatorioUncheckedCreateNestedManyWithoutProprietarioInput
  }

  export type ProprietarioCreateOrConnectWithoutUsuarioInput = {
    where: ProprietarioWhereUniqueInput
    create: XOR<ProprietarioCreateWithoutUsuarioInput, ProprietarioUncheckedCreateWithoutUsuarioInput>
  }

  export type AdminCreateWithoutUsuarioInput = {
    id?: string
    relatorios?: RelatorioCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutUsuarioInput = {
    id?: string
    relatorios?: RelatorioUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutUsuarioInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUsuarioInput, AdminUncheckedCreateWithoutUsuarioInput>
  }

  export type ClienteUpsertWithoutUsuarioInput = {
    update: XOR<ClienteUpdateWithoutUsuarioInput, ClienteUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ClienteCreateWithoutUsuarioInput, ClienteUncheckedCreateWithoutUsuarioInput>
    where?: ClienteWhereInput
  }

  export type ClienteUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: ClienteWhereInput
    data: XOR<ClienteUpdateWithoutUsuarioInput, ClienteUncheckedUpdateWithoutUsuarioInput>
  }

  export type ClienteUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    reservas?: ReservaUpdateManyWithoutClienteNestedInput
    avaliacoes?: AvaliacaoUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    reservas?: ReservaUncheckedUpdateManyWithoutClienteNestedInput
    avaliacoes?: AvaliacaoUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type ProprietarioUpsertWithoutUsuarioInput = {
    update: XOR<ProprietarioUpdateWithoutUsuarioInput, ProprietarioUncheckedUpdateWithoutUsuarioInput>
    create: XOR<ProprietarioCreateWithoutUsuarioInput, ProprietarioUncheckedCreateWithoutUsuarioInput>
    where?: ProprietarioWhereInput
  }

  export type ProprietarioUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: ProprietarioWhereInput
    data: XOR<ProprietarioUpdateWithoutUsuarioInput, ProprietarioUncheckedUpdateWithoutUsuarioInput>
  }

  export type ProprietarioUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    nivel_privilegio?: EnumNiveis_privilegioFieldUpdateOperationsInput | $Enums.Niveis_privilegio
    lavanderias?: LavanderiaUpdateManyWithoutProprietarioNestedInput
    Relatorios?: RelatorioUpdateManyWithoutProprietarioNestedInput
  }

  export type ProprietarioUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    nivel_privilegio?: EnumNiveis_privilegioFieldUpdateOperationsInput | $Enums.Niveis_privilegio
    lavanderias?: LavanderiaUncheckedUpdateManyWithoutProprietarioNestedInput
    Relatorios?: RelatorioUncheckedUpdateManyWithoutProprietarioNestedInput
  }

  export type AdminUpsertWithoutUsuarioInput = {
    update: XOR<AdminUpdateWithoutUsuarioInput, AdminUncheckedUpdateWithoutUsuarioInput>
    create: XOR<AdminCreateWithoutUsuarioInput, AdminUncheckedCreateWithoutUsuarioInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutUsuarioInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutUsuarioInput, AdminUncheckedUpdateWithoutUsuarioInput>
  }

  export type AdminUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    relatorios?: RelatorioUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    relatorios?: RelatorioUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type UsuarioCreateWithoutClienteInput = {
    id?: string
    nome: string
    email: string
    senha: string
    tipo: $Enums.TipoUsuario
    createdAt?: Date | string
    updatedAt?: Date | string
    proprietario?: ProprietarioCreateNestedOneWithoutUsuarioInput
    admin?: AdminCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutClienteInput = {
    id?: string
    nome: string
    email: string
    senha: string
    tipo: $Enums.TipoUsuario
    createdAt?: Date | string
    updatedAt?: Date | string
    proprietario?: ProprietarioUncheckedCreateNestedOneWithoutUsuarioInput
    admin?: AdminUncheckedCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutClienteInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutClienteInput, UsuarioUncheckedCreateWithoutClienteInput>
  }

  export type ReservaCreateWithoutClienteInput = {
    id?: string
    status?: $Enums.Status_reserva
    inicio: Date | string
    fim: Date | string
    createAt?: Date | string
    updateAt?: Date | string
    maquina: MaquinaCreateNestedOneWithoutReservasInput
    pagamento?: PagamentoCreateNestedOneWithoutReservaInput
  }

  export type ReservaUncheckedCreateWithoutClienteInput = {
    id?: string
    status?: $Enums.Status_reserva
    maquina_id: string
    inicio: Date | string
    fim: Date | string
    createAt?: Date | string
    updateAt?: Date | string
    pagamento_id?: string | null
  }

  export type ReservaCreateOrConnectWithoutClienteInput = {
    where: ReservaWhereUniqueInput
    create: XOR<ReservaCreateWithoutClienteInput, ReservaUncheckedCreateWithoutClienteInput>
  }

  export type ReservaCreateManyClienteInputEnvelope = {
    data: ReservaCreateManyClienteInput | ReservaCreateManyClienteInput[]
    skipDuplicates?: boolean
  }

  export type AvaliacaoCreateWithoutClienteInput = {
    id?: string
    nota: number
    comentario: string
    createAt?: Date | string
    updateAt?: Date | string
    lavanderia: LavanderiaCreateNestedOneWithoutAvaliacoesInput
  }

  export type AvaliacaoUncheckedCreateWithoutClienteInput = {
    id?: string
    nota: number
    comentario: string
    lavanderia_id: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type AvaliacaoCreateOrConnectWithoutClienteInput = {
    where: AvaliacaoWhereUniqueInput
    create: XOR<AvaliacaoCreateWithoutClienteInput, AvaliacaoUncheckedCreateWithoutClienteInput>
  }

  export type AvaliacaoCreateManyClienteInputEnvelope = {
    data: AvaliacaoCreateManyClienteInput | AvaliacaoCreateManyClienteInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioUpsertWithoutClienteInput = {
    update: XOR<UsuarioUpdateWithoutClienteInput, UsuarioUncheckedUpdateWithoutClienteInput>
    create: XOR<UsuarioCreateWithoutClienteInput, UsuarioUncheckedCreateWithoutClienteInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutClienteInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutClienteInput, UsuarioUncheckedUpdateWithoutClienteInput>
  }

  export type UsuarioUpdateWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proprietario?: ProprietarioUpdateOneWithoutUsuarioNestedInput
    admin?: AdminUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proprietario?: ProprietarioUncheckedUpdateOneWithoutUsuarioNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUsuarioNestedInput
  }

  export type ReservaUpsertWithWhereUniqueWithoutClienteInput = {
    where: ReservaWhereUniqueInput
    update: XOR<ReservaUpdateWithoutClienteInput, ReservaUncheckedUpdateWithoutClienteInput>
    create: XOR<ReservaCreateWithoutClienteInput, ReservaUncheckedCreateWithoutClienteInput>
  }

  export type ReservaUpdateWithWhereUniqueWithoutClienteInput = {
    where: ReservaWhereUniqueInput
    data: XOR<ReservaUpdateWithoutClienteInput, ReservaUncheckedUpdateWithoutClienteInput>
  }

  export type ReservaUpdateManyWithWhereWithoutClienteInput = {
    where: ReservaScalarWhereInput
    data: XOR<ReservaUpdateManyMutationInput, ReservaUncheckedUpdateManyWithoutClienteInput>
  }

  export type ReservaScalarWhereInput = {
    AND?: ReservaScalarWhereInput | ReservaScalarWhereInput[]
    OR?: ReservaScalarWhereInput[]
    NOT?: ReservaScalarWhereInput | ReservaScalarWhereInput[]
    id?: StringFilter<"Reserva"> | string
    status?: EnumStatus_reservaFilter<"Reserva"> | $Enums.Status_reserva
    cliente_id?: StringFilter<"Reserva"> | string
    maquina_id?: StringFilter<"Reserva"> | string
    inicio?: DateTimeFilter<"Reserva"> | Date | string
    fim?: DateTimeFilter<"Reserva"> | Date | string
    createAt?: DateTimeFilter<"Reserva"> | Date | string
    updateAt?: DateTimeFilter<"Reserva"> | Date | string
    pagamento_id?: StringNullableFilter<"Reserva"> | string | null
  }

  export type AvaliacaoUpsertWithWhereUniqueWithoutClienteInput = {
    where: AvaliacaoWhereUniqueInput
    update: XOR<AvaliacaoUpdateWithoutClienteInput, AvaliacaoUncheckedUpdateWithoutClienteInput>
    create: XOR<AvaliacaoCreateWithoutClienteInput, AvaliacaoUncheckedCreateWithoutClienteInput>
  }

  export type AvaliacaoUpdateWithWhereUniqueWithoutClienteInput = {
    where: AvaliacaoWhereUniqueInput
    data: XOR<AvaliacaoUpdateWithoutClienteInput, AvaliacaoUncheckedUpdateWithoutClienteInput>
  }

  export type AvaliacaoUpdateManyWithWhereWithoutClienteInput = {
    where: AvaliacaoScalarWhereInput
    data: XOR<AvaliacaoUpdateManyMutationInput, AvaliacaoUncheckedUpdateManyWithoutClienteInput>
  }

  export type AvaliacaoScalarWhereInput = {
    AND?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
    OR?: AvaliacaoScalarWhereInput[]
    NOT?: AvaliacaoScalarWhereInput | AvaliacaoScalarWhereInput[]
    id?: StringFilter<"Avaliacao"> | string
    nota?: IntFilter<"Avaliacao"> | number
    comentario?: StringFilter<"Avaliacao"> | string
    cliente_id?: StringFilter<"Avaliacao"> | string
    lavanderia_id?: StringFilter<"Avaliacao"> | string
    createAt?: DateTimeFilter<"Avaliacao"> | Date | string
    updateAt?: DateTimeFilter<"Avaliacao"> | Date | string
  }

  export type UsuarioCreateWithoutProprietarioInput = {
    id?: string
    nome: string
    email: string
    senha: string
    tipo: $Enums.TipoUsuario
    createdAt?: Date | string
    updatedAt?: Date | string
    cliente?: ClienteCreateNestedOneWithoutUsuarioInput
    admin?: AdminCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutProprietarioInput = {
    id?: string
    nome: string
    email: string
    senha: string
    tipo: $Enums.TipoUsuario
    createdAt?: Date | string
    updatedAt?: Date | string
    cliente?: ClienteUncheckedCreateNestedOneWithoutUsuarioInput
    admin?: AdminUncheckedCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutProprietarioInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutProprietarioInput, UsuarioUncheckedCreateWithoutProprietarioInput>
  }

  export type LavanderiaCreateWithoutProprietarioInput = {
    id?: string
    nomeFantasia: string
    razaoSocial: string
    endereco: string
    telefone?: string | null
    horarioAbertura?: string | null
    horarioFechamento?: string | null
    descricao?: string | null
    fotoUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    destaque?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    maquinas?: MaquinaCreateNestedManyWithoutLavanderiaInput
    avaliacoes?: AvaliacaoCreateNestedManyWithoutLavanderiaInput
  }

  export type LavanderiaUncheckedCreateWithoutProprietarioInput = {
    id?: string
    nomeFantasia: string
    razaoSocial: string
    endereco: string
    telefone?: string | null
    horarioAbertura?: string | null
    horarioFechamento?: string | null
    descricao?: string | null
    fotoUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    destaque?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    maquinas?: MaquinaUncheckedCreateNestedManyWithoutLavanderiaInput
    avaliacoes?: AvaliacaoUncheckedCreateNestedManyWithoutLavanderiaInput
  }

  export type LavanderiaCreateOrConnectWithoutProprietarioInput = {
    where: LavanderiaWhereUniqueInput
    create: XOR<LavanderiaCreateWithoutProprietarioInput, LavanderiaUncheckedCreateWithoutProprietarioInput>
  }

  export type LavanderiaCreateManyProprietarioInputEnvelope = {
    data: LavanderiaCreateManyProprietarioInput | LavanderiaCreateManyProprietarioInput[]
    skipDuplicates?: boolean
  }

  export type RelatorioCreateWithoutProprietarioInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    admin: AdminCreateNestedOneWithoutRelatoriosInput
  }

  export type RelatorioUncheckedCreateWithoutProprietarioInput = {
    id?: string
    admin_id: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type RelatorioCreateOrConnectWithoutProprietarioInput = {
    where: RelatorioWhereUniqueInput
    create: XOR<RelatorioCreateWithoutProprietarioInput, RelatorioUncheckedCreateWithoutProprietarioInput>
  }

  export type RelatorioCreateManyProprietarioInputEnvelope = {
    data: RelatorioCreateManyProprietarioInput | RelatorioCreateManyProprietarioInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioUpsertWithoutProprietarioInput = {
    update: XOR<UsuarioUpdateWithoutProprietarioInput, UsuarioUncheckedUpdateWithoutProprietarioInput>
    create: XOR<UsuarioCreateWithoutProprietarioInput, UsuarioUncheckedCreateWithoutProprietarioInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutProprietarioInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutProprietarioInput, UsuarioUncheckedUpdateWithoutProprietarioInput>
  }

  export type UsuarioUpdateWithoutProprietarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUpdateOneWithoutUsuarioNestedInput
    admin?: AdminUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutProprietarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUncheckedUpdateOneWithoutUsuarioNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUsuarioNestedInput
  }

  export type LavanderiaUpsertWithWhereUniqueWithoutProprietarioInput = {
    where: LavanderiaWhereUniqueInput
    update: XOR<LavanderiaUpdateWithoutProprietarioInput, LavanderiaUncheckedUpdateWithoutProprietarioInput>
    create: XOR<LavanderiaCreateWithoutProprietarioInput, LavanderiaUncheckedCreateWithoutProprietarioInput>
  }

  export type LavanderiaUpdateWithWhereUniqueWithoutProprietarioInput = {
    where: LavanderiaWhereUniqueInput
    data: XOR<LavanderiaUpdateWithoutProprietarioInput, LavanderiaUncheckedUpdateWithoutProprietarioInput>
  }

  export type LavanderiaUpdateManyWithWhereWithoutProprietarioInput = {
    where: LavanderiaScalarWhereInput
    data: XOR<LavanderiaUpdateManyMutationInput, LavanderiaUncheckedUpdateManyWithoutProprietarioInput>
  }

  export type LavanderiaScalarWhereInput = {
    AND?: LavanderiaScalarWhereInput | LavanderiaScalarWhereInput[]
    OR?: LavanderiaScalarWhereInput[]
    NOT?: LavanderiaScalarWhereInput | LavanderiaScalarWhereInput[]
    id?: StringFilter<"Lavanderia"> | string
    nomeFantasia?: StringFilter<"Lavanderia"> | string
    razaoSocial?: StringFilter<"Lavanderia"> | string
    endereco?: StringFilter<"Lavanderia"> | string
    telefone?: StringNullableFilter<"Lavanderia"> | string | null
    horarioAbertura?: StringNullableFilter<"Lavanderia"> | string | null
    horarioFechamento?: StringNullableFilter<"Lavanderia"> | string | null
    descricao?: StringNullableFilter<"Lavanderia"> | string | null
    fotoUrl?: StringNullableFilter<"Lavanderia"> | string | null
    latitude?: FloatNullableFilter<"Lavanderia"> | number | null
    longitude?: FloatNullableFilter<"Lavanderia"> | number | null
    proprietario_id?: StringFilter<"Lavanderia"> | string
    destaque?: BoolFilter<"Lavanderia"> | boolean
    createdAt?: DateTimeFilter<"Lavanderia"> | Date | string
    updatedAt?: DateTimeFilter<"Lavanderia"> | Date | string
  }

  export type RelatorioUpsertWithWhereUniqueWithoutProprietarioInput = {
    where: RelatorioWhereUniqueInput
    update: XOR<RelatorioUpdateWithoutProprietarioInput, RelatorioUncheckedUpdateWithoutProprietarioInput>
    create: XOR<RelatorioCreateWithoutProprietarioInput, RelatorioUncheckedCreateWithoutProprietarioInput>
  }

  export type RelatorioUpdateWithWhereUniqueWithoutProprietarioInput = {
    where: RelatorioWhereUniqueInput
    data: XOR<RelatorioUpdateWithoutProprietarioInput, RelatorioUncheckedUpdateWithoutProprietarioInput>
  }

  export type RelatorioUpdateManyWithWhereWithoutProprietarioInput = {
    where: RelatorioScalarWhereInput
    data: XOR<RelatorioUpdateManyMutationInput, RelatorioUncheckedUpdateManyWithoutProprietarioInput>
  }

  export type RelatorioScalarWhereInput = {
    AND?: RelatorioScalarWhereInput | RelatorioScalarWhereInput[]
    OR?: RelatorioScalarWhereInput[]
    NOT?: RelatorioScalarWhereInput | RelatorioScalarWhereInput[]
    id?: StringFilter<"Relatorio"> | string
    admin_id?: StringFilter<"Relatorio"> | string
    proprietario_id?: StringFilter<"Relatorio"> | string
    createAt?: DateTimeFilter<"Relatorio"> | Date | string
    updateAt?: DateTimeFilter<"Relatorio"> | Date | string
  }

  export type UsuarioCreateWithoutAdminInput = {
    id?: string
    nome: string
    email: string
    senha: string
    tipo: $Enums.TipoUsuario
    createdAt?: Date | string
    updatedAt?: Date | string
    cliente?: ClienteCreateNestedOneWithoutUsuarioInput
    proprietario?: ProprietarioCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutAdminInput = {
    id?: string
    nome: string
    email: string
    senha: string
    tipo: $Enums.TipoUsuario
    createdAt?: Date | string
    updatedAt?: Date | string
    cliente?: ClienteUncheckedCreateNestedOneWithoutUsuarioInput
    proprietario?: ProprietarioUncheckedCreateNestedOneWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutAdminInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutAdminInput, UsuarioUncheckedCreateWithoutAdminInput>
  }

  export type RelatorioCreateWithoutAdminInput = {
    id?: string
    createAt?: Date | string
    updateAt?: Date | string
    proprietario: ProprietarioCreateNestedOneWithoutRelatoriosInput
  }

  export type RelatorioUncheckedCreateWithoutAdminInput = {
    id?: string
    proprietario_id: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type RelatorioCreateOrConnectWithoutAdminInput = {
    where: RelatorioWhereUniqueInput
    create: XOR<RelatorioCreateWithoutAdminInput, RelatorioUncheckedCreateWithoutAdminInput>
  }

  export type RelatorioCreateManyAdminInputEnvelope = {
    data: RelatorioCreateManyAdminInput | RelatorioCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioUpsertWithoutAdminInput = {
    update: XOR<UsuarioUpdateWithoutAdminInput, UsuarioUncheckedUpdateWithoutAdminInput>
    create: XOR<UsuarioCreateWithoutAdminInput, UsuarioUncheckedCreateWithoutAdminInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutAdminInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutAdminInput, UsuarioUncheckedUpdateWithoutAdminInput>
  }

  export type UsuarioUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUpdateOneWithoutUsuarioNestedInput
    proprietario?: ProprietarioUpdateOneWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoUsuarioFieldUpdateOperationsInput | $Enums.TipoUsuario
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUncheckedUpdateOneWithoutUsuarioNestedInput
    proprietario?: ProprietarioUncheckedUpdateOneWithoutUsuarioNestedInput
  }

  export type RelatorioUpsertWithWhereUniqueWithoutAdminInput = {
    where: RelatorioWhereUniqueInput
    update: XOR<RelatorioUpdateWithoutAdminInput, RelatorioUncheckedUpdateWithoutAdminInput>
    create: XOR<RelatorioCreateWithoutAdminInput, RelatorioUncheckedCreateWithoutAdminInput>
  }

  export type RelatorioUpdateWithWhereUniqueWithoutAdminInput = {
    where: RelatorioWhereUniqueInput
    data: XOR<RelatorioUpdateWithoutAdminInput, RelatorioUncheckedUpdateWithoutAdminInput>
  }

  export type RelatorioUpdateManyWithWhereWithoutAdminInput = {
    where: RelatorioScalarWhereInput
    data: XOR<RelatorioUpdateManyMutationInput, RelatorioUncheckedUpdateManyWithoutAdminInput>
  }

  export type ProprietarioCreateWithoutLavanderiasInput = {
    id?: string
    nivel_privilegio?: $Enums.Niveis_privilegio
    usuario: UsuarioCreateNestedOneWithoutProprietarioInput
    Relatorios?: RelatorioCreateNestedManyWithoutProprietarioInput
  }

  export type ProprietarioUncheckedCreateWithoutLavanderiasInput = {
    id?: string
    usuarioId: string
    nivel_privilegio?: $Enums.Niveis_privilegio
    Relatorios?: RelatorioUncheckedCreateNestedManyWithoutProprietarioInput
  }

  export type ProprietarioCreateOrConnectWithoutLavanderiasInput = {
    where: ProprietarioWhereUniqueInput
    create: XOR<ProprietarioCreateWithoutLavanderiasInput, ProprietarioUncheckedCreateWithoutLavanderiasInput>
  }

  export type MaquinaCreateWithoutLavanderiaInput = {
    id?: string
    tipo?: $Enums.Tipo_maquina
    status_maquina?: $Enums.Status_maquina
    capacidade?: number
    preco: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    reservas?: ReservaCreateNestedManyWithoutMaquinaInput
  }

  export type MaquinaUncheckedCreateWithoutLavanderiaInput = {
    id?: string
    tipo?: $Enums.Tipo_maquina
    status_maquina?: $Enums.Status_maquina
    capacidade?: number
    preco: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    reservas?: ReservaUncheckedCreateNestedManyWithoutMaquinaInput
  }

  export type MaquinaCreateOrConnectWithoutLavanderiaInput = {
    where: MaquinaWhereUniqueInput
    create: XOR<MaquinaCreateWithoutLavanderiaInput, MaquinaUncheckedCreateWithoutLavanderiaInput>
  }

  export type MaquinaCreateManyLavanderiaInputEnvelope = {
    data: MaquinaCreateManyLavanderiaInput | MaquinaCreateManyLavanderiaInput[]
    skipDuplicates?: boolean
  }

  export type AvaliacaoCreateWithoutLavanderiaInput = {
    id?: string
    nota: number
    comentario: string
    createAt?: Date | string
    updateAt?: Date | string
    cliente: ClienteCreateNestedOneWithoutAvaliacoesInput
  }

  export type AvaliacaoUncheckedCreateWithoutLavanderiaInput = {
    id?: string
    nota: number
    comentario: string
    cliente_id: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type AvaliacaoCreateOrConnectWithoutLavanderiaInput = {
    where: AvaliacaoWhereUniqueInput
    create: XOR<AvaliacaoCreateWithoutLavanderiaInput, AvaliacaoUncheckedCreateWithoutLavanderiaInput>
  }

  export type AvaliacaoCreateManyLavanderiaInputEnvelope = {
    data: AvaliacaoCreateManyLavanderiaInput | AvaliacaoCreateManyLavanderiaInput[]
    skipDuplicates?: boolean
  }

  export type ProprietarioUpsertWithoutLavanderiasInput = {
    update: XOR<ProprietarioUpdateWithoutLavanderiasInput, ProprietarioUncheckedUpdateWithoutLavanderiasInput>
    create: XOR<ProprietarioCreateWithoutLavanderiasInput, ProprietarioUncheckedCreateWithoutLavanderiasInput>
    where?: ProprietarioWhereInput
  }

  export type ProprietarioUpdateToOneWithWhereWithoutLavanderiasInput = {
    where?: ProprietarioWhereInput
    data: XOR<ProprietarioUpdateWithoutLavanderiasInput, ProprietarioUncheckedUpdateWithoutLavanderiasInput>
  }

  export type ProprietarioUpdateWithoutLavanderiasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nivel_privilegio?: EnumNiveis_privilegioFieldUpdateOperationsInput | $Enums.Niveis_privilegio
    usuario?: UsuarioUpdateOneRequiredWithoutProprietarioNestedInput
    Relatorios?: RelatorioUpdateManyWithoutProprietarioNestedInput
  }

  export type ProprietarioUncheckedUpdateWithoutLavanderiasInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    nivel_privilegio?: EnumNiveis_privilegioFieldUpdateOperationsInput | $Enums.Niveis_privilegio
    Relatorios?: RelatorioUncheckedUpdateManyWithoutProprietarioNestedInput
  }

  export type MaquinaUpsertWithWhereUniqueWithoutLavanderiaInput = {
    where: MaquinaWhereUniqueInput
    update: XOR<MaquinaUpdateWithoutLavanderiaInput, MaquinaUncheckedUpdateWithoutLavanderiaInput>
    create: XOR<MaquinaCreateWithoutLavanderiaInput, MaquinaUncheckedCreateWithoutLavanderiaInput>
  }

  export type MaquinaUpdateWithWhereUniqueWithoutLavanderiaInput = {
    where: MaquinaWhereUniqueInput
    data: XOR<MaquinaUpdateWithoutLavanderiaInput, MaquinaUncheckedUpdateWithoutLavanderiaInput>
  }

  export type MaquinaUpdateManyWithWhereWithoutLavanderiaInput = {
    where: MaquinaScalarWhereInput
    data: XOR<MaquinaUpdateManyMutationInput, MaquinaUncheckedUpdateManyWithoutLavanderiaInput>
  }

  export type MaquinaScalarWhereInput = {
    AND?: MaquinaScalarWhereInput | MaquinaScalarWhereInput[]
    OR?: MaquinaScalarWhereInput[]
    NOT?: MaquinaScalarWhereInput | MaquinaScalarWhereInput[]
    id?: StringFilter<"Maquina"> | string
    tipo?: EnumTipo_maquinaFilter<"Maquina"> | $Enums.Tipo_maquina
    status_maquina?: EnumStatus_maquinaFilter<"Maquina"> | $Enums.Status_maquina
    capacidade?: IntFilter<"Maquina"> | number
    preco?: DecimalFilter<"Maquina"> | Decimal | DecimalJsLike | number | string
    lavanderia_id?: StringFilter<"Maquina"> | string
    createAt?: DateTimeFilter<"Maquina"> | Date | string
    updateAt?: DateTimeFilter<"Maquina"> | Date | string
  }

  export type AvaliacaoUpsertWithWhereUniqueWithoutLavanderiaInput = {
    where: AvaliacaoWhereUniqueInput
    update: XOR<AvaliacaoUpdateWithoutLavanderiaInput, AvaliacaoUncheckedUpdateWithoutLavanderiaInput>
    create: XOR<AvaliacaoCreateWithoutLavanderiaInput, AvaliacaoUncheckedCreateWithoutLavanderiaInput>
  }

  export type AvaliacaoUpdateWithWhereUniqueWithoutLavanderiaInput = {
    where: AvaliacaoWhereUniqueInput
    data: XOR<AvaliacaoUpdateWithoutLavanderiaInput, AvaliacaoUncheckedUpdateWithoutLavanderiaInput>
  }

  export type AvaliacaoUpdateManyWithWhereWithoutLavanderiaInput = {
    where: AvaliacaoScalarWhereInput
    data: XOR<AvaliacaoUpdateManyMutationInput, AvaliacaoUncheckedUpdateManyWithoutLavanderiaInput>
  }

  export type LavanderiaCreateWithoutMaquinasInput = {
    id?: string
    nomeFantasia: string
    razaoSocial: string
    endereco: string
    telefone?: string | null
    horarioAbertura?: string | null
    horarioFechamento?: string | null
    descricao?: string | null
    fotoUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    destaque?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    proprietario: ProprietarioCreateNestedOneWithoutLavanderiasInput
    avaliacoes?: AvaliacaoCreateNestedManyWithoutLavanderiaInput
  }

  export type LavanderiaUncheckedCreateWithoutMaquinasInput = {
    id?: string
    nomeFantasia: string
    razaoSocial: string
    endereco: string
    telefone?: string | null
    horarioAbertura?: string | null
    horarioFechamento?: string | null
    descricao?: string | null
    fotoUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    proprietario_id: string
    destaque?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    avaliacoes?: AvaliacaoUncheckedCreateNestedManyWithoutLavanderiaInput
  }

  export type LavanderiaCreateOrConnectWithoutMaquinasInput = {
    where: LavanderiaWhereUniqueInput
    create: XOR<LavanderiaCreateWithoutMaquinasInput, LavanderiaUncheckedCreateWithoutMaquinasInput>
  }

  export type ReservaCreateWithoutMaquinaInput = {
    id?: string
    status?: $Enums.Status_reserva
    inicio: Date | string
    fim: Date | string
    createAt?: Date | string
    updateAt?: Date | string
    cliente: ClienteCreateNestedOneWithoutReservasInput
    pagamento?: PagamentoCreateNestedOneWithoutReservaInput
  }

  export type ReservaUncheckedCreateWithoutMaquinaInput = {
    id?: string
    status?: $Enums.Status_reserva
    cliente_id: string
    inicio: Date | string
    fim: Date | string
    createAt?: Date | string
    updateAt?: Date | string
    pagamento_id?: string | null
  }

  export type ReservaCreateOrConnectWithoutMaquinaInput = {
    where: ReservaWhereUniqueInput
    create: XOR<ReservaCreateWithoutMaquinaInput, ReservaUncheckedCreateWithoutMaquinaInput>
  }

  export type ReservaCreateManyMaquinaInputEnvelope = {
    data: ReservaCreateManyMaquinaInput | ReservaCreateManyMaquinaInput[]
    skipDuplicates?: boolean
  }

  export type LavanderiaUpsertWithoutMaquinasInput = {
    update: XOR<LavanderiaUpdateWithoutMaquinasInput, LavanderiaUncheckedUpdateWithoutMaquinasInput>
    create: XOR<LavanderiaCreateWithoutMaquinasInput, LavanderiaUncheckedCreateWithoutMaquinasInput>
    where?: LavanderiaWhereInput
  }

  export type LavanderiaUpdateToOneWithWhereWithoutMaquinasInput = {
    where?: LavanderiaWhereInput
    data: XOR<LavanderiaUpdateWithoutMaquinasInput, LavanderiaUncheckedUpdateWithoutMaquinasInput>
  }

  export type LavanderiaUpdateWithoutMaquinasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    horarioAbertura?: NullableStringFieldUpdateOperationsInput | string | null
    horarioFechamento?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destaque?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proprietario?: ProprietarioUpdateOneRequiredWithoutLavanderiasNestedInput
    avaliacoes?: AvaliacaoUpdateManyWithoutLavanderiaNestedInput
  }

  export type LavanderiaUncheckedUpdateWithoutMaquinasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    horarioAbertura?: NullableStringFieldUpdateOperationsInput | string | null
    horarioFechamento?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    proprietario_id?: StringFieldUpdateOperationsInput | string
    destaque?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    avaliacoes?: AvaliacaoUncheckedUpdateManyWithoutLavanderiaNestedInput
  }

  export type ReservaUpsertWithWhereUniqueWithoutMaquinaInput = {
    where: ReservaWhereUniqueInput
    update: XOR<ReservaUpdateWithoutMaquinaInput, ReservaUncheckedUpdateWithoutMaquinaInput>
    create: XOR<ReservaCreateWithoutMaquinaInput, ReservaUncheckedCreateWithoutMaquinaInput>
  }

  export type ReservaUpdateWithWhereUniqueWithoutMaquinaInput = {
    where: ReservaWhereUniqueInput
    data: XOR<ReservaUpdateWithoutMaquinaInput, ReservaUncheckedUpdateWithoutMaquinaInput>
  }

  export type ReservaUpdateManyWithWhereWithoutMaquinaInput = {
    where: ReservaScalarWhereInput
    data: XOR<ReservaUpdateManyMutationInput, ReservaUncheckedUpdateManyWithoutMaquinaInput>
  }

  export type AdminCreateWithoutRelatoriosInput = {
    id?: string
    usuario: UsuarioCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutRelatoriosInput = {
    id?: string
    usuarioId: string
  }

  export type AdminCreateOrConnectWithoutRelatoriosInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutRelatoriosInput, AdminUncheckedCreateWithoutRelatoriosInput>
  }

  export type ProprietarioCreateWithoutRelatoriosInput = {
    id?: string
    nivel_privilegio?: $Enums.Niveis_privilegio
    usuario: UsuarioCreateNestedOneWithoutProprietarioInput
    lavanderias?: LavanderiaCreateNestedManyWithoutProprietarioInput
  }

  export type ProprietarioUncheckedCreateWithoutRelatoriosInput = {
    id?: string
    usuarioId: string
    nivel_privilegio?: $Enums.Niveis_privilegio
    lavanderias?: LavanderiaUncheckedCreateNestedManyWithoutProprietarioInput
  }

  export type ProprietarioCreateOrConnectWithoutRelatoriosInput = {
    where: ProprietarioWhereUniqueInput
    create: XOR<ProprietarioCreateWithoutRelatoriosInput, ProprietarioUncheckedCreateWithoutRelatoriosInput>
  }

  export type AdminUpsertWithoutRelatoriosInput = {
    update: XOR<AdminUpdateWithoutRelatoriosInput, AdminUncheckedUpdateWithoutRelatoriosInput>
    create: XOR<AdminCreateWithoutRelatoriosInput, AdminUncheckedCreateWithoutRelatoriosInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutRelatoriosInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutRelatoriosInput, AdminUncheckedUpdateWithoutRelatoriosInput>
  }

  export type AdminUpdateWithoutRelatoriosInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuario?: UsuarioUpdateOneRequiredWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutRelatoriosInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
  }

  export type ProprietarioUpsertWithoutRelatoriosInput = {
    update: XOR<ProprietarioUpdateWithoutRelatoriosInput, ProprietarioUncheckedUpdateWithoutRelatoriosInput>
    create: XOR<ProprietarioCreateWithoutRelatoriosInput, ProprietarioUncheckedCreateWithoutRelatoriosInput>
    where?: ProprietarioWhereInput
  }

  export type ProprietarioUpdateToOneWithWhereWithoutRelatoriosInput = {
    where?: ProprietarioWhereInput
    data: XOR<ProprietarioUpdateWithoutRelatoriosInput, ProprietarioUncheckedUpdateWithoutRelatoriosInput>
  }

  export type ProprietarioUpdateWithoutRelatoriosInput = {
    id?: StringFieldUpdateOperationsInput | string
    nivel_privilegio?: EnumNiveis_privilegioFieldUpdateOperationsInput | $Enums.Niveis_privilegio
    usuario?: UsuarioUpdateOneRequiredWithoutProprietarioNestedInput
    lavanderias?: LavanderiaUpdateManyWithoutProprietarioNestedInput
  }

  export type ProprietarioUncheckedUpdateWithoutRelatoriosInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    nivel_privilegio?: EnumNiveis_privilegioFieldUpdateOperationsInput | $Enums.Niveis_privilegio
    lavanderias?: LavanderiaUncheckedUpdateManyWithoutProprietarioNestedInput
  }

  export type ClienteCreateWithoutReservasInput = {
    id?: string
    usuario: UsuarioCreateNestedOneWithoutClienteInput
    avaliacoes?: AvaliacaoCreateNestedManyWithoutClienteInput
  }

  export type ClienteUncheckedCreateWithoutReservasInput = {
    id?: string
    usuarioId: string
    avaliacoes?: AvaliacaoUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteCreateOrConnectWithoutReservasInput = {
    where: ClienteWhereUniqueInput
    create: XOR<ClienteCreateWithoutReservasInput, ClienteUncheckedCreateWithoutReservasInput>
  }

  export type MaquinaCreateWithoutReservasInput = {
    id?: string
    tipo?: $Enums.Tipo_maquina
    status_maquina?: $Enums.Status_maquina
    capacidade?: number
    preco: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
    lavanderia: LavanderiaCreateNestedOneWithoutMaquinasInput
  }

  export type MaquinaUncheckedCreateWithoutReservasInput = {
    id?: string
    tipo?: $Enums.Tipo_maquina
    status_maquina?: $Enums.Status_maquina
    capacidade?: number
    preco: Decimal | DecimalJsLike | number | string
    lavanderia_id: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MaquinaCreateOrConnectWithoutReservasInput = {
    where: MaquinaWhereUniqueInput
    create: XOR<MaquinaCreateWithoutReservasInput, MaquinaUncheckedCreateWithoutReservasInput>
  }

  export type PagamentoCreateWithoutReservaInput = {
    id?: string
    valor: Decimal | DecimalJsLike | number | string
    metodo?: $Enums.Metodo_Pagamento
    status?: $Enums.Status_Pagamento
    createAt?: Date | string
  }

  export type PagamentoUncheckedCreateWithoutReservaInput = {
    id?: string
    valor: Decimal | DecimalJsLike | number | string
    metodo?: $Enums.Metodo_Pagamento
    status?: $Enums.Status_Pagamento
    createAt?: Date | string
  }

  export type PagamentoCreateOrConnectWithoutReservaInput = {
    where: PagamentoWhereUniqueInput
    create: XOR<PagamentoCreateWithoutReservaInput, PagamentoUncheckedCreateWithoutReservaInput>
  }

  export type ClienteUpsertWithoutReservasInput = {
    update: XOR<ClienteUpdateWithoutReservasInput, ClienteUncheckedUpdateWithoutReservasInput>
    create: XOR<ClienteCreateWithoutReservasInput, ClienteUncheckedCreateWithoutReservasInput>
    where?: ClienteWhereInput
  }

  export type ClienteUpdateToOneWithWhereWithoutReservasInput = {
    where?: ClienteWhereInput
    data: XOR<ClienteUpdateWithoutReservasInput, ClienteUncheckedUpdateWithoutReservasInput>
  }

  export type ClienteUpdateWithoutReservasInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuario?: UsuarioUpdateOneRequiredWithoutClienteNestedInput
    avaliacoes?: AvaliacaoUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateWithoutReservasInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    avaliacoes?: AvaliacaoUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type MaquinaUpsertWithoutReservasInput = {
    update: XOR<MaquinaUpdateWithoutReservasInput, MaquinaUncheckedUpdateWithoutReservasInput>
    create: XOR<MaquinaCreateWithoutReservasInput, MaquinaUncheckedCreateWithoutReservasInput>
    where?: MaquinaWhereInput
  }

  export type MaquinaUpdateToOneWithWhereWithoutReservasInput = {
    where?: MaquinaWhereInput
    data: XOR<MaquinaUpdateWithoutReservasInput, MaquinaUncheckedUpdateWithoutReservasInput>
  }

  export type MaquinaUpdateWithoutReservasInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_maquinaFieldUpdateOperationsInput | $Enums.Tipo_maquina
    status_maquina?: EnumStatus_maquinaFieldUpdateOperationsInput | $Enums.Status_maquina
    capacidade?: IntFieldUpdateOperationsInput | number
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lavanderia?: LavanderiaUpdateOneRequiredWithoutMaquinasNestedInput
  }

  export type MaquinaUncheckedUpdateWithoutReservasInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_maquinaFieldUpdateOperationsInput | $Enums.Tipo_maquina
    status_maquina?: EnumStatus_maquinaFieldUpdateOperationsInput | $Enums.Status_maquina
    capacidade?: IntFieldUpdateOperationsInput | number
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lavanderia_id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoUpsertWithoutReservaInput = {
    update: XOR<PagamentoUpdateWithoutReservaInput, PagamentoUncheckedUpdateWithoutReservaInput>
    create: XOR<PagamentoCreateWithoutReservaInput, PagamentoUncheckedCreateWithoutReservaInput>
    where?: PagamentoWhereInput
  }

  export type PagamentoUpdateToOneWithWhereWithoutReservaInput = {
    where?: PagamentoWhereInput
    data: XOR<PagamentoUpdateWithoutReservaInput, PagamentoUncheckedUpdateWithoutReservaInput>
  }

  export type PagamentoUpdateWithoutReservaInput = {
    id?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metodo?: EnumMetodo_PagamentoFieldUpdateOperationsInput | $Enums.Metodo_Pagamento
    status?: EnumStatus_PagamentoFieldUpdateOperationsInput | $Enums.Status_Pagamento
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoUncheckedUpdateWithoutReservaInput = {
    id?: StringFieldUpdateOperationsInput | string
    valor?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metodo?: EnumMetodo_PagamentoFieldUpdateOperationsInput | $Enums.Metodo_Pagamento
    status?: EnumStatus_PagamentoFieldUpdateOperationsInput | $Enums.Status_Pagamento
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClienteCreateWithoutAvaliacoesInput = {
    id?: string
    usuario: UsuarioCreateNestedOneWithoutClienteInput
    reservas?: ReservaCreateNestedManyWithoutClienteInput
  }

  export type ClienteUncheckedCreateWithoutAvaliacoesInput = {
    id?: string
    usuarioId: string
    reservas?: ReservaUncheckedCreateNestedManyWithoutClienteInput
  }

  export type ClienteCreateOrConnectWithoutAvaliacoesInput = {
    where: ClienteWhereUniqueInput
    create: XOR<ClienteCreateWithoutAvaliacoesInput, ClienteUncheckedCreateWithoutAvaliacoesInput>
  }

  export type LavanderiaCreateWithoutAvaliacoesInput = {
    id?: string
    nomeFantasia: string
    razaoSocial: string
    endereco: string
    telefone?: string | null
    horarioAbertura?: string | null
    horarioFechamento?: string | null
    descricao?: string | null
    fotoUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    destaque?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    proprietario: ProprietarioCreateNestedOneWithoutLavanderiasInput
    maquinas?: MaquinaCreateNestedManyWithoutLavanderiaInput
  }

  export type LavanderiaUncheckedCreateWithoutAvaliacoesInput = {
    id?: string
    nomeFantasia: string
    razaoSocial: string
    endereco: string
    telefone?: string | null
    horarioAbertura?: string | null
    horarioFechamento?: string | null
    descricao?: string | null
    fotoUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    proprietario_id: string
    destaque?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    maquinas?: MaquinaUncheckedCreateNestedManyWithoutLavanderiaInput
  }

  export type LavanderiaCreateOrConnectWithoutAvaliacoesInput = {
    where: LavanderiaWhereUniqueInput
    create: XOR<LavanderiaCreateWithoutAvaliacoesInput, LavanderiaUncheckedCreateWithoutAvaliacoesInput>
  }

  export type ClienteUpsertWithoutAvaliacoesInput = {
    update: XOR<ClienteUpdateWithoutAvaliacoesInput, ClienteUncheckedUpdateWithoutAvaliacoesInput>
    create: XOR<ClienteCreateWithoutAvaliacoesInput, ClienteUncheckedCreateWithoutAvaliacoesInput>
    where?: ClienteWhereInput
  }

  export type ClienteUpdateToOneWithWhereWithoutAvaliacoesInput = {
    where?: ClienteWhereInput
    data: XOR<ClienteUpdateWithoutAvaliacoesInput, ClienteUncheckedUpdateWithoutAvaliacoesInput>
  }

  export type ClienteUpdateWithoutAvaliacoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuario?: UsuarioUpdateOneRequiredWithoutClienteNestedInput
    reservas?: ReservaUpdateManyWithoutClienteNestedInput
  }

  export type ClienteUncheckedUpdateWithoutAvaliacoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    reservas?: ReservaUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type LavanderiaUpsertWithoutAvaliacoesInput = {
    update: XOR<LavanderiaUpdateWithoutAvaliacoesInput, LavanderiaUncheckedUpdateWithoutAvaliacoesInput>
    create: XOR<LavanderiaCreateWithoutAvaliacoesInput, LavanderiaUncheckedCreateWithoutAvaliacoesInput>
    where?: LavanderiaWhereInput
  }

  export type LavanderiaUpdateToOneWithWhereWithoutAvaliacoesInput = {
    where?: LavanderiaWhereInput
    data: XOR<LavanderiaUpdateWithoutAvaliacoesInput, LavanderiaUncheckedUpdateWithoutAvaliacoesInput>
  }

  export type LavanderiaUpdateWithoutAvaliacoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    horarioAbertura?: NullableStringFieldUpdateOperationsInput | string | null
    horarioFechamento?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destaque?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proprietario?: ProprietarioUpdateOneRequiredWithoutLavanderiasNestedInput
    maquinas?: MaquinaUpdateManyWithoutLavanderiaNestedInput
  }

  export type LavanderiaUncheckedUpdateWithoutAvaliacoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    horarioAbertura?: NullableStringFieldUpdateOperationsInput | string | null
    horarioFechamento?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    proprietario_id?: StringFieldUpdateOperationsInput | string
    destaque?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maquinas?: MaquinaUncheckedUpdateManyWithoutLavanderiaNestedInput
  }

  export type ReservaCreateWithoutPagamentoInput = {
    id?: string
    status?: $Enums.Status_reserva
    inicio: Date | string
    fim: Date | string
    createAt?: Date | string
    updateAt?: Date | string
    cliente: ClienteCreateNestedOneWithoutReservasInput
    maquina: MaquinaCreateNestedOneWithoutReservasInput
  }

  export type ReservaUncheckedCreateWithoutPagamentoInput = {
    id?: string
    status?: $Enums.Status_reserva
    cliente_id: string
    maquina_id: string
    inicio: Date | string
    fim: Date | string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type ReservaCreateOrConnectWithoutPagamentoInput = {
    where: ReservaWhereUniqueInput
    create: XOR<ReservaCreateWithoutPagamentoInput, ReservaUncheckedCreateWithoutPagamentoInput>
  }

  export type ReservaUpsertWithoutPagamentoInput = {
    update: XOR<ReservaUpdateWithoutPagamentoInput, ReservaUncheckedUpdateWithoutPagamentoInput>
    create: XOR<ReservaCreateWithoutPagamentoInput, ReservaUncheckedCreateWithoutPagamentoInput>
    where?: ReservaWhereInput
  }

  export type ReservaUpdateToOneWithWhereWithoutPagamentoInput = {
    where?: ReservaWhereInput
    data: XOR<ReservaUpdateWithoutPagamentoInput, ReservaUncheckedUpdateWithoutPagamentoInput>
  }

  export type ReservaUpdateWithoutPagamentoInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatus_reservaFieldUpdateOperationsInput | $Enums.Status_reserva
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUpdateOneRequiredWithoutReservasNestedInput
    maquina?: MaquinaUpdateOneRequiredWithoutReservasNestedInput
  }

  export type ReservaUncheckedUpdateWithoutPagamentoInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatus_reservaFieldUpdateOperationsInput | $Enums.Status_reserva
    cliente_id?: StringFieldUpdateOperationsInput | string
    maquina_id?: StringFieldUpdateOperationsInput | string
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservaCreateManyClienteInput = {
    id?: string
    status?: $Enums.Status_reserva
    maquina_id: string
    inicio: Date | string
    fim: Date | string
    createAt?: Date | string
    updateAt?: Date | string
    pagamento_id?: string | null
  }

  export type AvaliacaoCreateManyClienteInput = {
    id?: string
    nota: number
    comentario: string
    lavanderia_id: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type ReservaUpdateWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatus_reservaFieldUpdateOperationsInput | $Enums.Status_reserva
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maquina?: MaquinaUpdateOneRequiredWithoutReservasNestedInput
    pagamento?: PagamentoUpdateOneWithoutReservaNestedInput
  }

  export type ReservaUncheckedUpdateWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatus_reservaFieldUpdateOperationsInput | $Enums.Status_reserva
    maquina_id?: StringFieldUpdateOperationsInput | string
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagamento_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReservaUncheckedUpdateManyWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatus_reservaFieldUpdateOperationsInput | $Enums.Status_reserva
    maquina_id?: StringFieldUpdateOperationsInput | string
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagamento_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AvaliacaoUpdateWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nota?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lavanderia?: LavanderiaUpdateOneRequiredWithoutAvaliacoesNestedInput
  }

  export type AvaliacaoUncheckedUpdateWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nota?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    lavanderia_id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvaliacaoUncheckedUpdateManyWithoutClienteInput = {
    id?: StringFieldUpdateOperationsInput | string
    nota?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    lavanderia_id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LavanderiaCreateManyProprietarioInput = {
    id?: string
    nomeFantasia: string
    razaoSocial: string
    endereco: string
    telefone?: string | null
    horarioAbertura?: string | null
    horarioFechamento?: string | null
    descricao?: string | null
    fotoUrl?: string | null
    latitude?: number | null
    longitude?: number | null
    destaque?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RelatorioCreateManyProprietarioInput = {
    id?: string
    admin_id: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type LavanderiaUpdateWithoutProprietarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    horarioAbertura?: NullableStringFieldUpdateOperationsInput | string | null
    horarioFechamento?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destaque?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maquinas?: MaquinaUpdateManyWithoutLavanderiaNestedInput
    avaliacoes?: AvaliacaoUpdateManyWithoutLavanderiaNestedInput
  }

  export type LavanderiaUncheckedUpdateWithoutProprietarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    horarioAbertura?: NullableStringFieldUpdateOperationsInput | string | null
    horarioFechamento?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destaque?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    maquinas?: MaquinaUncheckedUpdateManyWithoutLavanderiaNestedInput
    avaliacoes?: AvaliacaoUncheckedUpdateManyWithoutLavanderiaNestedInput
  }

  export type LavanderiaUncheckedUpdateManyWithoutProprietarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    nomeFantasia?: StringFieldUpdateOperationsInput | string
    razaoSocial?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    horarioAbertura?: NullableStringFieldUpdateOperationsInput | string | null
    horarioFechamento?: NullableStringFieldUpdateOperationsInput | string | null
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    fotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destaque?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelatorioUpdateWithoutProprietarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutRelatoriosNestedInput
  }

  export type RelatorioUncheckedUpdateWithoutProprietarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    admin_id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelatorioUncheckedUpdateManyWithoutProprietarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    admin_id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelatorioCreateManyAdminInput = {
    id?: string
    proprietario_id: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type RelatorioUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proprietario?: ProprietarioUpdateOneRequiredWithoutRelatoriosNestedInput
  }

  export type RelatorioUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    proprietario_id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RelatorioUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    proprietario_id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaquinaCreateManyLavanderiaInput = {
    id?: string
    tipo?: $Enums.Tipo_maquina
    status_maquina?: $Enums.Status_maquina
    capacidade?: number
    preco: Decimal | DecimalJsLike | number | string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type AvaliacaoCreateManyLavanderiaInput = {
    id?: string
    nota: number
    comentario: string
    cliente_id: string
    createAt?: Date | string
    updateAt?: Date | string
  }

  export type MaquinaUpdateWithoutLavanderiaInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_maquinaFieldUpdateOperationsInput | $Enums.Tipo_maquina
    status_maquina?: EnumStatus_maquinaFieldUpdateOperationsInput | $Enums.Status_maquina
    capacidade?: IntFieldUpdateOperationsInput | number
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservas?: ReservaUpdateManyWithoutMaquinaNestedInput
  }

  export type MaquinaUncheckedUpdateWithoutLavanderiaInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_maquinaFieldUpdateOperationsInput | $Enums.Tipo_maquina
    status_maquina?: EnumStatus_maquinaFieldUpdateOperationsInput | $Enums.Status_maquina
    capacidade?: IntFieldUpdateOperationsInput | number
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservas?: ReservaUncheckedUpdateManyWithoutMaquinaNestedInput
  }

  export type MaquinaUncheckedUpdateManyWithoutLavanderiaInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipo_maquinaFieldUpdateOperationsInput | $Enums.Tipo_maquina
    status_maquina?: EnumStatus_maquinaFieldUpdateOperationsInput | $Enums.Status_maquina
    capacidade?: IntFieldUpdateOperationsInput | number
    preco?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvaliacaoUpdateWithoutLavanderiaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nota?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUpdateOneRequiredWithoutAvaliacoesNestedInput
  }

  export type AvaliacaoUncheckedUpdateWithoutLavanderiaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nota?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    cliente_id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvaliacaoUncheckedUpdateManyWithoutLavanderiaInput = {
    id?: StringFieldUpdateOperationsInput | string
    nota?: IntFieldUpdateOperationsInput | number
    comentario?: StringFieldUpdateOperationsInput | string
    cliente_id?: StringFieldUpdateOperationsInput | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservaCreateManyMaquinaInput = {
    id?: string
    status?: $Enums.Status_reserva
    cliente_id: string
    inicio: Date | string
    fim: Date | string
    createAt?: Date | string
    updateAt?: Date | string
    pagamento_id?: string | null
  }

  export type ReservaUpdateWithoutMaquinaInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatus_reservaFieldUpdateOperationsInput | $Enums.Status_reserva
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cliente?: ClienteUpdateOneRequiredWithoutReservasNestedInput
    pagamento?: PagamentoUpdateOneWithoutReservaNestedInput
  }

  export type ReservaUncheckedUpdateWithoutMaquinaInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatus_reservaFieldUpdateOperationsInput | $Enums.Status_reserva
    cliente_id?: StringFieldUpdateOperationsInput | string
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagamento_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReservaUncheckedUpdateManyWithoutMaquinaInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumStatus_reservaFieldUpdateOperationsInput | $Enums.Status_reserva
    cliente_id?: StringFieldUpdateOperationsInput | string
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    createAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pagamento_id?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ClienteCountOutputTypeDefaultArgs instead
     */
    export type ClienteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClienteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProprietarioCountOutputTypeDefaultArgs instead
     */
    export type ProprietarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProprietarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminCountOutputTypeDefaultArgs instead
     */
    export type AdminCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LavanderiaCountOutputTypeDefaultArgs instead
     */
    export type LavanderiaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LavanderiaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaquinaCountOutputTypeDefaultArgs instead
     */
    export type MaquinaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaquinaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioDefaultArgs instead
     */
    export type UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClienteDefaultArgs instead
     */
    export type ClienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClienteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProprietarioDefaultArgs instead
     */
    export type ProprietarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProprietarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminDefaultArgs instead
     */
    export type AdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LavanderiaDefaultArgs instead
     */
    export type LavanderiaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LavanderiaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaquinaDefaultArgs instead
     */
    export type MaquinaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaquinaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RelatorioDefaultArgs instead
     */
    export type RelatorioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RelatorioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReservaDefaultArgs instead
     */
    export type ReservaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReservaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AvaliacaoDefaultArgs instead
     */
    export type AvaliacaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AvaliacaoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PagamentoDefaultArgs instead
     */
    export type PagamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PagamentoDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}